!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACCESS_ONCE	.\lib\fbi\util.h	28;"	d
APPEND_INT_FUNC	.\lib\mc\umbrella.c	/^APPEND_INT_FUNC(I32, int32_t)$/;"	f
APPEND_INT_FUNC	.\lib\mc\umbrella.c	564;"	d	file:
APPEND_INT_FUNC	.\lib\mc\umbrella.c	577;"	d	file:
APPEND_INT_FUNC	.\lib\mc\umbrella.h	158;"	d
APPEND_INT_FUNC	.\lib\mc\umbrella.h	168;"	d
ASCII_TERM	.\lib\mc\ascii_response.c	15;"	d	file:
ASOX_QUEUE_ENTRY_DELETE	.\lib\fbi\asox_queue.h	/^  ASOX_QUEUE_ENTRY_DELETE = 0x01,$/;"	e	enum:__anon5
ASOX_QUEUE_INTER_PROCESS	.\lib\fbi\asox_queue.h	/^  ASOX_QUEUE_INTER_PROCESS = 0x2,$/;"	e	enum:__anon6
ASOX_QUEUE_INTRA_PROCESS	.\lib\fbi\asox_queue.h	/^  ASOX_QUEUE_INTRA_PROCESS =  0x1,$/;"	e	enum:__anon6
ASOX_SEM_COMPATIBILITY_MODE	.\lib\fbi\asox_semaphore.h	/^  ASOX_SEM_COMPATIBILITY_MODE = 0x2,$/;"	e	enum:__anon7
ASOX_SEM_MULTI	.\lib\fbi\asox_semaphore.h	/^  ASOX_SEM_MULTI = 0x1,$/;"	e	enum:__anon7
ASOX_SEM_NONE	.\lib\fbi\asox_semaphore.h	/^  ASOX_SEM_NONE = 0x0,$/;"	e	enum:__anon7
ASSERT_FORMAT	.\lib\fbi\debug.c	41;"	d	file:
ASSERT_FORMAT	.\lib\fbi\debug.c	53;"	d	file:
ASYNCLOG_MAGIC	.\async.cpp	51;"	d	file:
ASYNCLOG_MAGIC2	.\async.cpp	52;"	d	file:
AWAITING	.\lib\fibers\Fiber.h	/^    AWAITING,                   \/**< Is currently blocked *\/$/;"	e	enum:facebook::memcache::Fiber::State
AWAITING_IMMEDIATE	.\lib\fibers\Fiber.h	/^    AWAITING_IMMEDIATE,         \/**< Was preempted to run an immediate function,$/;"	e	enum:facebook::memcache::Fiber::State
AcceptCallback	.\lib\network\AsyncMcServer.cpp	/^    AcceptCallback(McServerThread* mcServerThread, bool secure)$/;"	f	class:facebook::memcache::McServerThread::AcceptCallback
AcceptCallback	.\lib\network\AsyncMcServer.cpp	/^  class AcceptCallback :$/;"	c	class:facebook::memcache::McServerThread	file:
Acceptor	.\lib\network\AsyncMcServer.cpp	/^  enum AcceptorT { Acceptor };$/;"	e	enum:facebook::memcache::McServerThread::AcceptorT	file:
AcceptorT	.\lib\network\AsyncMcServer.cpp	/^  enum AcceptorT { Acceptor };$/;"	g	class:facebook::memcache::McServerThread	file:
AccessPoint	.\AccessPoint.cpp	/^AccessPoint::AccessPoint(const AccessPoint& other)$/;"	f	class:facebook::memcache::mcrouter::AccessPoint
AccessPoint	.\AccessPoint.cpp	/^AccessPoint::AccessPoint(std::string host, std::string port,$/;"	f	class:facebook::memcache::mcrouter::AccessPoint
AccessPoint	.\AccessPoint.h	/^struct AccessPoint {$/;"	s	namespace:facebook::memcache::mcrouter
AddTaskFinallyHelper	.\lib\fibers\FiberManager-inl.h	/^struct FiberManager::AddTaskFinallyHelper {$/;"	s	class:facebook::memcache::FiberManager
AdditionalLoggerIf	.\McrouterLogger.h	/^class AdditionalLoggerIf {$/;"	c	namespace:facebook::memcache::mcrouter
AllAsyncRoute	.\lib\routes\AllAsyncRoute.h	/^  AllAsyncRoute(RouteHandleFactory<RouteHandleIf>& factory,$/;"	f	class:facebook::memcache::AllAsyncRoute
AllAsyncRoute	.\lib\routes\AllAsyncRoute.h	/^  explicit AllAsyncRoute(std::vector<std::shared_ptr<RouteHandleIf>> rh)$/;"	f	class:facebook::memcache::AllAsyncRoute
AllAsyncRoute	.\lib\routes\AllAsyncRoute.h	/^class AllAsyncRoute {$/;"	c	namespace:facebook::memcache
AllFastestRoute	.\lib\routes\AllFastestRoute.h	/^  AllFastestRoute(RouteHandleFactory<RouteHandleIf>& factory,$/;"	f	class:facebook::memcache::AllFastestRoute
AllFastestRoute	.\lib\routes\AllFastestRoute.h	/^  AllFastestRoute(std::vector<std::shared_ptr<RouteHandleIf>> rh)$/;"	f	class:facebook::memcache::AllFastestRoute
AllFastestRoute	.\lib\routes\AllFastestRoute.h	/^class AllFastestRoute {$/;"	c	namespace:facebook::memcache
AllInitialRoute	.\lib\routes\AllInitialRoute.h	/^  AllInitialRoute(RouteHandleFactory<RouteHandleIf>& factory,$/;"	f	class:facebook::memcache::AllInitialRoute
AllInitialRoute	.\lib\routes\AllInitialRoute.h	/^  AllInitialRoute(std::vector<std::shared_ptr<RouteHandleIf>> rh) {$/;"	f	class:facebook::memcache::AllInitialRoute
AllInitialRoute	.\lib\routes\AllInitialRoute.h	/^class AllInitialRoute {$/;"	c	namespace:facebook::memcache
AllMajorityRoute	.\lib\routes\AllMajorityRoute.h	/^  AllMajorityRoute(RouteHandleFactory<RouteHandleIf>& factory,$/;"	f	class:facebook::memcache::AllMajorityRoute
AllMajorityRoute	.\lib\routes\AllMajorityRoute.h	/^  explicit AllMajorityRoute(std::vector<std::shared_ptr<RouteHandleIf>> rh)$/;"	f	class:facebook::memcache::AllMajorityRoute
AllMajorityRoute	.\lib\routes\AllMajorityRoute.h	/^class AllMajorityRoute {$/;"	c	namespace:facebook::memcache
AllSyncRoute	.\lib\routes\AllSyncRoute.h	/^  AllSyncRoute(RouteHandleFactory<RouteHandleIf>& factory,$/;"	f	class:facebook::memcache::AllSyncRoute
AllSyncRoute	.\lib\routes\AllSyncRoute.h	/^  explicit AllSyncRoute(std::vector<std::shared_ptr<RouteHandleIf>> rh)$/;"	f	class:facebook::memcache::AllSyncRoute
AllSyncRoute	.\lib\routes\AllSyncRoute.h	/^class AllSyncRoute {$/;"	c	namespace:facebook::memcache
Application	.\lib\fibers\test\FibersTestApp.cpp	/^  Application ()$/;"	f	struct:Application
Application	.\lib\fibers\test\FibersTestApp.cpp	/^struct Application {$/;"	s	file:
ArithmeticLike	.\lib\McOperationTraits.h	/^struct ArithmeticLike<McOperation<mc_op_decr>> {$/;"	s	namespace:facebook::memcache
ArithmeticLike	.\lib\McOperationTraits.h	/^struct ArithmeticLike<McOperation<mc_op_incr>> {$/;"	s	namespace:facebook::memcache
ArithmeticLike	.\lib\OperationTraits.h	/^struct ArithmeticLike {$/;"	s	namespace:facebook::memcache
AsciiSerializedReply	.\lib\network\WriteBuffer.cpp	/^AsciiSerializedReply::AsciiSerializedReply() {$/;"	f	class:facebook::memcache::AsciiSerializedReply
AsciiSerializedReply	.\lib\network\WriteBuffer.h	/^class AsciiSerializedReply {$/;"	c	namespace:facebook::memcache
AsciiState	.\lib\network\McServerRequestContext.h	/^  struct AsciiState {$/;"	s	class:facebook::memcache::McServerRequestContext
AsyncLogException	.\async.cpp	/^  explicit AsyncLogException(const std::string& msg)$/;"	f	class:facebook::memcache::mcrouter::__anon1::AsyncLogException
AsyncLogException	.\async.cpp	/^class AsyncLogException : public std::runtime_error {$/;"	c	namespace:facebook::memcache::mcrouter::__anon1	file:
AsyncMcClient	.\lib\network\AsyncMcClient-inl.h	/^inline AsyncMcClient::AsyncMcClient(folly::EventBase& eventBase,$/;"	f	class:facebook::memcache::AsyncMcClient
AsyncMcClient	.\lib\network\AsyncMcClient.h	/^class AsyncMcClient {$/;"	c	namespace:facebook::memcache
AsyncMcClientImpl	.\lib\network\AsyncMcClientImpl.cpp	/^AsyncMcClientImpl::AsyncMcClientImpl($/;"	f	class:facebook::memcache::AsyncMcClientImpl
AsyncMcClientImpl	.\lib\network\AsyncMcClientImpl.h	/^class AsyncMcClientImpl :$/;"	c	namespace:facebook::memcache
AsyncMcServer	.\lib\network\AsyncMcServer.cpp	/^AsyncMcServer::AsyncMcServer(Options opts)$/;"	f	class:facebook::memcache::AsyncMcServer
AsyncMcServer	.\lib\network\AsyncMcServer.h	/^class AsyncMcServer {$/;"	c	namespace:facebook::memcache
AsyncMcServerWorker	.\lib\network\AsyncMcServerWorker.cpp	/^AsyncMcServerWorker::AsyncMcServerWorker(AsyncMcServerWorkerOptions opts,$/;"	f	class:facebook::memcache::AsyncMcServerWorker
AsyncMcServerWorker	.\lib\network\AsyncMcServerWorker.h	/^class AsyncMcServerWorker {$/;"	c	namespace:facebook::memcache
AsyncMcServerWorkerOptions	.\lib\network\AsyncMcServerWorkerOptions.h	/^struct AsyncMcServerWorkerOptions {$/;"	s	namespace:facebook::memcache
AsyncWriter	.\async.cpp	/^AsyncWriter::AsyncWriter(size_t maxQueueSize)$/;"	f	class:facebook::memcache::mcrouter::AsyncWriter
AsyncWriter	.\awriter.h	/^class AsyncWriter {$/;"	c	namespace:facebook::memcache::mcrouter
AsynclogFunc	.\routes\AsynclogRoute.h	/^                           folly::StringPiece)> AsynclogFunc;$/;"	t	namespace:facebook::memcache::mcrouter
AsynclogFunc	.\routes\McRouteHandleProvider.cpp	/^                           folly::StringPiece poolName)> AsynclogFunc;$/;"	t	namespace:facebook::memcache::mcrouter	file:
AsynclogRoute	.\routes\AsynclogRoute.h	/^  AsynclogRoute(std::shared_ptr<RouteHandleIf> rh,$/;"	f	class:facebook::memcache::mcrouter::AsynclogRoute
AsynclogRoute	.\routes\AsynclogRoute.h	/^class AsynclogRoute {$/;"	c	namespace:facebook::memcache::mcrouter
AtomicCounter	.\test\cpp_unit_tests\awriter_test.cpp	/^  AtomicCounter() {$/;"	f	class:AtomicCounter
AtomicCounter	.\test\cpp_unit_tests\awriter_test.cpp	/^class AtomicCounter {$/;"	c	file:
AtomicLinkedList	.\lib\fbi\cpp\AtomicLinkedList.h	/^  AtomicLinkedList() {}$/;"	f	class:facebook::memcache::AtomicLinkedList
AtomicLinkedList	.\lib\fbi\cpp\AtomicLinkedList.h	/^class AtomicLinkedList {$/;"	c	namespace:facebook::memcache
AtomicLinkedListHook	.\lib\fbi\cpp\AtomicLinkedList.h	/^struct AtomicLinkedListHook {$/;"	s	namespace:facebook::memcache
AtomicTokenBucket	.\AtomicTokenBucket.h	/^  AtomicTokenBucket(double rate, double burstSize,$/;"	f	class:facebook::memcache::mcrouter::AtomicTokenBucket
AtomicTokenBucket	.\AtomicTokenBucket.h	/^class AtomicTokenBucket {$/;"	c	namespace:facebook::memcache::mcrouter
AtomicWrapper	.\lib\fbi\cpp\AtomicSharedPtr.h	/^  explicit AtomicWrapper(T&& data)$/;"	f	class:facebook::memcache::AtomicWrapper
AtomicWrapper	.\lib\fbi\cpp\AtomicSharedPtr.h	/^class AtomicWrapper {$/;"	c	namespace:facebook::memcache
BAD_KEY	.\lib\network\McSerializedRequest.h	/^    BAD_KEY,$/;"	m	class:facebook::memcache::McSerializedRequest::Result
BASE_BODY_SIZE	.\lib\mc\umbrella.h	112;"	d
BASE_ENTRIES_SIZE	.\lib\mc\umbrella.h	111;"	d
BENCHMARK	.\lib\fbi\cpp\test\TrieBenchmarks.cpp	/^BENCHMARK(Trie_get) {$/;"	f
BENCHMARK	.\lib\fbi\cpp\test\TrieBenchmarks.cpp	/^BENCHMARK(Trie_get_prefix) {$/;"	f
BENCHMARK	.\lib\fibers\test\FibersTest.cpp	/^BENCHMARK(FiberManagerBasicFiveAwaits, iters) {$/;"	f
BENCHMARK	.\lib\fibers\test\FibersTest.cpp	/^BENCHMARK(FiberManagerBasicOneAwait, iters) {$/;"	f
BMSG_ENTRIES_ARRAY_SIZE	.\lib\mc\umbrella.h	206;"	d
BOGUS_CONFIG	.\test\cpp_unit_tests\file_observer_test.cpp	/^const std::string BOGUS_CONFIG = "this\/file\/doesnot\/exists";$/;"	v
BSTRING	.\lib\mc\umbrella.h	/^  BSTRING,                  \/\/ char * (binary blob)$/;"	e	enum:entry_type_e
BaseDirectory	.\test\MCProcess.py	/^class BaseDirectory(object):$/;"	c
Baton	.\lib\fibers\Baton-inl.h	/^inline Baton::Baton() : Baton(NO_WAITER) {$/;"	f	class:facebook::memcache::Baton
Baton	.\lib\fibers\Baton.h	/^  explicit Baton(intptr_t state) : waitingFiber_(state) {};$/;"	f	class:facebook::memcache::Baton
Baton	.\lib\fibers\Baton.h	/^class Baton {$/;"	c	namespace:facebook::memcache
BigValueRoute	.\routes\BigValueRoute-inl.h	/^BigValueRoute<RouteHandleIf>::BigValueRoute(std::shared_ptr<RouteHandleIf> ch,$/;"	f	class:facebook::memcache::BigValueRoute
BigValueRoute	.\routes\BigValueRoute.h	/^class BigValueRoute {$/;"	c	namespace:facebook::memcache
BigValueRouteOptions	.\routes\BigValueRouteIf.h	/^  explicit BigValueRouteOptions(size_t threshold) :$/;"	f	struct:facebook::memcache::BigValueRouteOptions
BigValueRouteOptions	.\routes\BigValueRouteIf.h	/^struct BigValueRouteOptions {$/;"	s	namespace:facebook::memcache
BuiltIns	.\lib\config\ConfigPreprocessor.cpp	/^class ConfigPreprocessor::BuiltIns {$/;"	c	class:facebook::memcache::ConfigPreprocessor	file:
CACHE	.\lib\network\test\MockMc.h	/^      CACHE,$/;"	e	enum:facebook::memcache::MockMc::CacheItem::TLRUState
CLIENT_REPLY	.\priorities.h	/^  CLIENT_REPLY,$/;"	e	enum:facebook::memcache::mcrouter::event_priority_type_t
CLIENT_REQUEST	.\priorities.h	/^  CLIENT_REQUEST,$/;"	e	enum:facebook::memcache::mcrouter::event_priority_type_t
CLOSING	.\lib\network\McServerSession.h	/^    CLOSING,$/;"	e	enum:facebook::memcache::McServerSession::State
CONNECTING	.\lib\network\AsyncMcClientImpl.h	/^    CONNECTING, \/\/ Currently connecting.$/;"	m	class:facebook::memcache::AsyncMcClientImpl::ConnectionState
COUNTER_INFLATED_SIZE	.\lib\fbi\counter.h	31;"	d
COUNTER_INFLATION_THRESHOLD	.\lib\fbi\counter.h	34;"	d
COUNTER_LOG_INFLATED_SIZE	.\lib\fbi\counter.h	30;"	d
CSTRING	.\lib\mc\umbrella.h	/^  CSTRING,                  \/\/ char * (null terminated c string$/;"	e	enum:entry_type_e
CWLOCK_LOCKED	.\lib\fbi\cwlock.c	20;"	d	file:
CWLOCK_UNIT	.\lib\fbi\cwlock.c	22;"	d	file:
CWLOCK_WAITER	.\lib\fbi\cwlock.c	21;"	d	file:
CacheItem	.\lib\network\test\MockMc.h	/^    explicit CacheItem(Item it)$/;"	f	struct:facebook::memcache::MockMc::CacheItem
CacheItem	.\lib\network\test\MockMc.h	/^  struct CacheItem {$/;"	s	class:facebook::memcache::MockMc
Callback	.\ConfigApi.h	/^  typedef std::function<void()> Callback;$/;"	t	class:facebook::memcache::mcrouter::ConfigType::ConfigApi
CallbackHandle	.\CallbackPool.h	/^  typedef std::unique_ptr<CallbackHandleImpl> CallbackHandle;$/;"	t	class:facebook::memcache::mcrouter::CallbackPool
CallbackHandle	.\ConfigApi.h	/^  typedef CallbackPool<>::CallbackHandle CallbackHandle;$/;"	t	class:facebook::memcache::mcrouter::ConfigType::ConfigApi
CallbackHandle	.\Observable.h	/^  CallbackHandle;$/;"	t	class:facebook::memcache::mcrouter::Observable
CallbackHandleImpl	.\CallbackPool-inl.h	/^  CallbackHandleImpl(std::shared_ptr<Data> data, OnUpdateFunc func)$/;"	f	struct:facebook::memcache::mcrouter::CallbackPool::CallbackHandleImpl
CallbackHandleImpl	.\CallbackPool-inl.h	/^struct CallbackPool<Args...>::CallbackHandleImpl {$/;"	s	class:facebook::memcache::mcrouter::CallbackPool
CallbackPool	.\CallbackPool-inl.h	/^CallbackPool<Args...>::CallbackPool()$/;"	f	class:facebook::memcache::mcrouter::CallbackPool
CallbackPool	.\CallbackPool.h	/^class CallbackPool {$/;"	c	namespace:facebook::memcache::mcrouter
Category	.\lib\fbi\cpp\LogFailure.h	/^  Category() {}$/;"	f	class:facebook::memcache::failure::Category
Category	.\lib\fbi\cpp\LogFailure.h	/^class Category {$/;"	c	namespace:facebook::memcache::failure
CertPaths	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^struct CertPaths {$/;"	s	namespace:facebook::memcache	file:
CertPathsHasher	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^struct CertPathsHasher {$/;"	s	namespace:facebook::memcache	file:
Ch3HashFunc	.\lib\Ch3HashFunc.h	/^  Ch3HashFunc(const folly::dynamic& json, size_t n)$/;"	f	class:facebook::memcache::Ch3HashFunc
Ch3HashFunc	.\lib\Ch3HashFunc.h	/^  explicit Ch3HashFunc(size_t n)$/;"	f	class:facebook::memcache::Ch3HashFunc
Ch3HashFunc	.\lib\Ch3HashFunc.h	/^class Ch3HashFunc {$/;"	c	namespace:facebook::memcache
ChunkGetOP	.\routes\BigValueRoute.h	/^  typedef McOperation<mc_op_get> ChunkGetOP;$/;"	t	class:facebook::memcache::BigValueRoute
ChunkGetRequest	.\routes\BigValueRoute.h	/^struct ChunkGetRequest {$/;"	s	namespace:facebook::memcache
ChunkUpdateOP	.\routes\BigValueRoute.h	/^  typedef McOperation<mc_op_set> ChunkUpdateOP;$/;"	t	class:facebook::memcache::BigValueRoute
ChunkUpdateRequest	.\routes\BigValueRoute.h	/^struct ChunkUpdateRequest {$/;"	s	namespace:facebook::memcache
ChunksInfo	.\routes\BigValueRoute-inl.h	/^BigValueRoute<RouteHandleIf>::ChunksInfo::ChunksInfo($/;"	f	class:facebook::memcache::BigValueRoute::ChunksInfo
ChunksInfo	.\routes\BigValueRoute-inl.h	/^BigValueRoute<RouteHandleIf>::ChunksInfo::ChunksInfo(uint32_t num_chunks)$/;"	f	class:facebook::memcache::BigValueRoute::ChunksInfo
ChunksInfo	.\routes\BigValueRoute.h	/^  class ChunksInfo {$/;"	c	class:facebook::memcache::BigValueRoute
ClientParseCallback	.\lib\network\McParser.h	/^  class ClientParseCallback {$/;"	c	class:facebook::memcache::McParser
Clock	.\lib\fibers\LoopController.h	/^  typedef std::chrono::steady_clock Clock;$/;"	t	class:facebook::memcache::LoopController
Clock	.\lib\fibers\TimeoutController.h	/^  typedef TimeoutHandle::Clock Clock;$/;"	t	class:facebook::memcache::TimeoutController
Clock	.\lib\fibers\TimeoutController.h	/^  typedef std::chrono::steady_clock Clock;$/;"	t	class:facebook::memcache::TimeoutHandle
CommonStats	.\lib\network\test\AsyncMcClientTest.cpp	/^struct CommonStats {$/;"	s	namespace:__anon42	file:
ConcatLists	.\lib\fbi\cpp\TypeList.h	/^struct ConcatLists {};$/;"	s	namespace:facebook::memcache
ConcatLists	.\lib\fbi\cpp\TypeList.h	/^struct ConcatLists<List<Operations1...>, List<>> {$/;"	s	namespace:facebook::memcache
ConcatLists	.\lib\fbi\cpp\TypeList.h	/^struct ConcatLists<List<Operations1...>, List<Operation2, Operations2...>> {$/;"	s	namespace:facebook::memcache
ConfigApi	.\ConfigApi.cpp	/^ConfigApi::ConfigApi(const McrouterOptions& opts)$/;"	f	class:facebook::memcache::mcrouter::ConfigApi
ConfigApi	.\ConfigApi.h	/^class ConfigApi {$/;"	c	class:facebook::memcache::mcrouter::ConfigType
ConfigFile	.\ConfigApi.h	/^  ConfigFile = 0,$/;"	m	class:facebook::memcache::mcrouter::ConfigType
ConfigImport	.\ConfigApi.h	/^  ConfigImport = 1,$/;"	m	class:facebook::memcache::mcrouter::ConfigType
ConfigPreprocessor	.\lib\config\ConfigPreprocessor.cpp	/^ConfigPreprocessor::ConfigPreprocessor(ImportResolverIf& importResolver,$/;"	f	class:facebook::memcache::ConfigPreprocessor
ConfigPreprocessor	.\lib\config\ConfigPreprocessor.h	/^class ConfigPreprocessor {$/;"	c	namespace:facebook::memcache
ConfigType	.\ConfigApi.h	/^enum class ConfigType {$/;"	c	namespace:facebook::memcache::mcrouter
ConnectionOptions	.\lib\network\ConnectionOptions.h	/^  ConnectionOptions(folly::StringPiece host_,$/;"	f	struct:facebook::memcache::ConnectionOptions
ConnectionOptions	.\lib\network\ConnectionOptions.h	/^struct ConnectionOptions {$/;"	s	namespace:facebook::memcache
ConnectionState	.\lib\network\AsyncMcClientImpl.h	/^  enum class ConnectionState {$/;"	c	class:facebook::memcache::AsyncMcClientImpl
ConnectionStatusCallbacks	.\lib\network\AsyncMcClientImpl.h	/^  struct ConnectionStatusCallbacks {$/;"	s	class:facebook::memcache::AsyncMcClientImpl
Const	.\lib\config\ConfigPreprocessor.cpp	/^  Const(const ConfigPreprocessor& prep,$/;"	f	class:facebook::memcache::ConfigPreprocessor::Const
Const	.\lib\config\ConfigPreprocessor.cpp	/^class ConfigPreprocessor::Const {$/;"	c	class:facebook::memcache::ConfigPreprocessor	file:
ConstShardHashFunc	.\routes\ShardHashFunc.cpp	/^ConstShardHashFunc::ConstShardHashFunc(const folly::dynamic& json, size_t n)$/;"	f	class:facebook::memcache::mcrouter::ConstShardHashFunc
ConstShardHashFunc	.\routes\ShardHashFunc.cpp	/^ConstShardHashFunc::ConstShardHashFunc(size_t n)$/;"	f	class:facebook::memcache::mcrouter::ConstShardHashFunc
ConstShardHashFunc	.\routes\ShardHashFunc.h	/^class ConstShardHashFunc {$/;"	c	namespace:facebook::memcache::mcrouter
Context	.\lib\config\ConfigPreprocessor.h	/^  typedef std::unordered_map<std::string, folly::dynamic> Context;$/;"	t	class:facebook::memcache::ConfigPreprocessor
Context	.\lib\fibers\AddTasks.h	/^  struct Context {$/;"	s	class:facebook::memcache::fiber::TaskIterator
Context	.\lib\test\TestRequest.h	/^  explicit Context(std::function<void()> f) : onDestroyed(f) {}$/;"	f	struct:facebook::memcache::Context
Context	.\lib\test\TestRequest.h	/^struct Context {$/;"	s	namespace:facebook::memcache
ContextInfo	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^struct ContextInfo {$/;"	s	namespace:facebook::memcache	file:
ControllerCallback	.\lib\fibers\EventBaseLoopController-inl.h	/^  explicit ControllerCallback(EventBaseLoopController& controller)$/;"	f	class:facebook::memcache::mcrouter::EventBaseLoopController::ControllerCallback
ControllerCallback	.\lib\fibers\EventBaseLoopController-inl.h	/^class EventBaseLoopController::ControllerCallback :$/;"	c	class:facebook::memcache::mcrouter::EventBaseLoopController
Crc32HashFunc	.\lib\Crc32HashFunc.h	/^  Crc32HashFunc(const folly::dynamic& json, size_t n)$/;"	f	class:facebook::memcache::Crc32HashFunc
Crc32HashFunc	.\lib\Crc32HashFunc.h	/^  explicit Crc32HashFunc(size_t n)$/;"	f	class:facebook::memcache::Crc32HashFunc
Crc32HashFunc	.\lib\Crc32HashFunc.h	/^class Crc32HashFunc {$/;"	c	namespace:facebook::memcache
DEBUG_MAX_LEVEL	.\lib\fbi\debug.h	97;"	d
DEBUG_MAX_LEVEL	.\lib\fbi\debug.h	99;"	d
DEBUG_MAX_LEVEL	.\lib\fbi\test\log_tid_tests.cpp	20;"	d	file:
DEBUG_PRINCIPAL	.\lib\fbi\debug.h	80;"	d
DEFAULT_ASYNCLOG_LIFETIME	.\options.h	26;"	d
DEFAULT_FDLIMIT	.\standalone_options.h	29;"	d
DEFAULT_MAX_CLIENT_OUTSTANDING_REQS	.\standalone_options.h	26;"	d
DEFAULT_MAX_GLOBAL_OUTSTANDING_REQS	.\standalone_options.h	24;"	d
DEFAULT_NUM_PROXIES	.\options.h	21;"	d
DEFAULT_REALTIME_PRIORITY_LEVEL	.\options.h	28;"	d
DEFAULT_SHADOW_POLICY	.\proxy.h	/^  DEFAULT_SHADOW_POLICY = 0,$/;"	e	enum:facebook::memcache::mcrouter::shadow_policy_t
DEFAULT_STACK_SIZE	.\mcrouter_options_list.h	117;"	d
DEFAULT_STACK_SIZE	.\mcrouter_options_list.h	128;"	d
DEFAULT_STACK_SIZE	.\router.cpp	/^const size_t DEFAULT_STACK_SIZE = 8192 * 1024;$/;"	m	namespace:facebook::memcache::mcrouter::__anon56	file:
DEFAULT_TRACK_NUM_OUTSTANDING	.\lib\mc\msg.c	59;"	d	file:
DEFAULT_TRACK_NUM_OUTSTANDING	.\lib\mc\msg.c	61;"	d	file:
DOUBLE	.\lib\mc\umbrella.h	/^  DOUBLE,                   \/\/ double$/;"	e	enum:entry_type_e
DOWN	.\lib\network\AsyncMcClientImpl.h	/^    DOWN, \/\/ Connection is not open (or close), we need to reconnect.$/;"	m	class:facebook::memcache::AsyncMcClientImpl::ConnectionState
DYNAMIC_EXPECT	.\PoolFactory.cpp	33;"	d	file:
DYNAMIC_EXPECT	.\PoolFactory.cpp	661;"	d	file:
DYNAMIC_EXPECT_THROW	.\PoolFactory.cpp	39;"	d	file:
Data	.\CallbackPool-inl.h	/^struct CallbackPool<Args...>::Data {$/;"	s	class:facebook::memcache::mcrouter::CallbackPool
Data	.\proxy.cpp	/^proxy_pool_shadowing_policy_t::Data::Data()$/;"	f	class:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t::Data
Data	.\proxy.cpp	/^proxy_pool_shadowing_policy_t::Data::Data(const folly::dynamic& json)$/;"	f	class:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t::Data
Data	.\proxy.h	/^  struct Data {$/;"	s	struct:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t
DebugLockGuard	.\lib\fbi\test\log_tid_tests.cpp	/^  DebugLockGuard() {$/;"	f	struct:DebugLockGuard
DebugLockGuard	.\lib\fbi\test\log_tid_tests.cpp	/^struct DebugLockGuard {$/;"	s	file:
DefaultReply	.\lib\Reply.h	/^enum DefaultReplyT { DefaultReply };$/;"	e	enum:facebook::memcache::DefaultReplyT
DefaultReplyT	.\lib\Reply.h	/^enum DefaultReplyT { DefaultReply };$/;"	g	namespace:facebook::memcache
DefaultShadowPolicy	.\routes\DefaultShadowPolicy.h	/^class DefaultShadowPolicy {$/;"	c	namespace:facebook::memcache::mcrouter
DeleteLike	.\lib\McOperationTraits.h	/^struct DeleteLike<McOperation<mc_op_delete>> {$/;"	s	namespace:facebook::memcache
DeleteLike	.\lib\OperationTraits.h	/^struct DeleteLike {$/;"	s	namespace:facebook::memcache
DeleteRouteTestData	.\lib\test\RouteHandleTestUtil.h	/^  explicit DeleteRouteTestData(mc_res_t result = mc_res_unknown) :$/;"	f	struct:facebook::memcache::DeleteRouteTestData
DeleteRouteTestData	.\lib\test\RouteHandleTestUtil.h	/^struct DeleteRouteTestData {$/;"	s	namespace:facebook::memcache
Deleter	.\lib\McMsgRef.h	/^  class Deleter {$/;"	c	struct:facebook::memcache::McMsgRefPolicy
Deleter	.\lib\McRequestBase.h	/^    struct Deleter {$/;"	s	struct:facebook::memcache::McRequestBase::McFbtraceRefPolicy
Deleter	.\lib\network\AsyncMcClientImpl.h	/^    class Deleter {$/;"	c	class:facebook::memcache::AsyncMcClientImpl::ReqInfo
DestinationClient	.\DestinationClient.cpp	/^DestinationClient::DestinationClient(std::shared_ptr<ProxyDestination> pdstn)$/;"	f	class:facebook::memcache::mcrouter::DestinationClient
DestinationClient	.\DestinationClient.h	/^class DestinationClient {$/;"	c	namespace:facebook::memcache::mcrouter
DestinationMcClient	.\mcrouter_config.h	/^typedef DestinationClient DestinationMcClient;$/;"	t	namespace:facebook::memcache::mcrouter
DestinationRequestCtx	.\routes\DestinationRoute.h	/^  explicit DestinationRequestCtx(proxy_request_t* proxyReq)$/;"	f	struct:facebook::memcache::mcrouter::DestinationRequestCtx
DestinationRequestCtx	.\routes\DestinationRoute.h	/^struct DestinationRequestCtx {$/;"	s	namespace:facebook::memcache::mcrouter
DestinationRoute	.\routes\DestinationRoute.h	/^  DestinationRoute(std::shared_ptr<const ProxyClientCommon> client,$/;"	f	class:facebook::memcache::mcrouter::DestinationRoute
DestinationRoute	.\routes\DestinationRoute.h	/^class DestinationRoute {$/;"	c	namespace:facebook::memcache::mcrouter
DevNullRoute	.\routes\DevNullRoute.h	/^class DevNullRoute {$/;"	c	namespace:facebook::memcache::mcrouter
Duration	.\lib\fibers\TimeoutController.h	/^  typedef Clock::duration Duration;$/;"	t	class:facebook::memcache::TimeoutController
DynamicAtomicTokenBucket	.\AtomicTokenBucket.h	/^  DynamicAtomicTokenBucket() : zeroTime_(0) {$/;"	f	class:facebook::memcache::mcrouter::DynamicAtomicTokenBucket
DynamicAtomicTokenBucket	.\AtomicTokenBucket.h	/^class DynamicAtomicTokenBucket {$/;"	c	namespace:facebook::memcache::mcrouter
ENTRY_LIST_MAGIC_BYTE	.\lib\mc\umbrella_protocol.h	40;"	d
ENTRY_SENTINEL	.\lib\fbi\asox_queue.c	29;"	d	file:
EXIT_STATUS_TRANSIENT_ERROR	.\main.cpp	62;"	d	file:
EXIT_STATUS_UNRECOVERABLE_ERROR	.\main.cpp	63;"	d	file:
EXTREME_KEY_INTERVAL	.\lib\fbi\test\hash_test.cpp	26;"	d	file:
EchoServer	.\test\test_wch3.py	/^class EchoServer(MockServer):$/;"	c
ErrorReply	.\lib\Reply.h	/^enum ErrorReplyT { ErrorReply };$/;"	e	enum:facebook::memcache::ErrorReplyT
ErrorReplyT	.\lib\Reply.h	/^enum ErrorReplyT { ErrorReply };$/;"	g	namespace:facebook::memcache
ErrorRoute	.\lib\routes\ErrorRoute.h	/^  ErrorRoute() {}$/;"	f	struct:facebook::memcache::ErrorRoute
ErrorRoute	.\lib\routes\ErrorRoute.h	/^  explicit ErrorRoute(const folly::dynamic& json) {$/;"	f	struct:facebook::memcache::ErrorRoute
ErrorRoute	.\lib\routes\ErrorRoute.h	/^  explicit ErrorRoute(std::string valueToSet)$/;"	f	struct:facebook::memcache::ErrorRoute
ErrorRoute	.\lib\routes\ErrorRoute.h	/^struct ErrorRoute {$/;"	s	namespace:facebook::memcache
ErrorServer	.\test\test_ascii_error.py	/^class ErrorServer(MockServer):$/;"	c
EventBaseLoopController	.\lib\fibers\EventBaseLoopController-inl.h	/^inline EventBaseLoopController::EventBaseLoopController()$/;"	f	class:facebook::memcache::mcrouter::EventBaseLoopController
EventBaseLoopController	.\lib\fibers\EventBaseLoopController.h	/^class EventBaseLoopController : public LoopController {$/;"	c	namespace:facebook::memcache::mcrouter
ExceptionCallback	.\lib\fibers\FiberManager.h	/^  typedef std::function<void(std::exception_ptr)> ExceptionCallback;$/;"	t	class:facebook::memcache::FiberManager
ExponentialSmoothData	.\ExponentialSmoothData.cpp	/^ExponentialSmoothData::ExponentialSmoothData(double smoothingFactor)$/;"	f	class:facebook::memcache::mcrouter::ExponentialSmoothData
ExponentialSmoothData	.\ExponentialSmoothData.h	/^class ExponentialSmoothData {$/;"	c	namespace:facebook::memcache::mcrouter
ExtraRouteHandleProviderIf	.\routes\ExtraRouteHandleProviderIf.h	/^class ExtraRouteHandleProviderIf {$/;"	c	namespace:facebook::memcache::mcrouter
ExtractFirstMemfn	.\lib\fbi\cpp\traits.h	/^struct ExtractFirstMemfn<Ret (T::*)(First, Args...) const> {$/;"	s	namespace:facebook::memcache::detail
ExtractFirstMemfn	.\lib\fbi\cpp\traits.h	/^struct ExtractFirstMemfn<Ret (T::*)(First, Args...)> {$/;"	s	namespace:facebook::memcache::detail
FAILOVER	.\ProxyMcRequest.h	/^  FAILOVER,$/;"	m	class:facebook::memcache::mcrouter::RequestClass
FAILOVER_CONNECT_TIMEOUT	.\proxy.h	/^  FAILOVER_CONNECT_TIMEOUT,$/;"	e	enum:facebook::memcache::mcrouter::proxy_pool_failover_t
FAILOVER_DATA_MISS	.\proxy.h	/^  FAILOVER_DATA_MISS,$/;"	e	enum:facebook::memcache::mcrouter::proxy_pool_failover_t
FAILOVER_DATA_TIMEOUT	.\proxy.h	/^  FAILOVER_DATA_TIMEOUT,$/;"	e	enum:facebook::memcache::mcrouter::proxy_pool_failover_t
FAILOVER_MAX	.\proxy.h	/^  FAILOVER_MAX            \/\/ Must be last$/;"	e	enum:facebook::memcache::mcrouter::proxy_pool_failover_t
FAILOVER_NONE	.\proxy.h	197;"	d
FAILOVER_TKO	.\proxy.h	/^  FAILOVER_TKO,$/;"	e	enum:facebook::memcache::mcrouter::proxy_pool_failover_t
FBI_APPERR	.\lib\fbi\error.h	96;"	d
FBI_ASSERT	.\lib\fbi\debug.h	42;"	d
FBI_COUNTER_H	.\lib\fbi\counter.h	10;"	d
FBI_COUNTING_SEM_H	.\lib\fbi\counting_sem.h	10;"	d
FBI_CPP_ATOMIC_SHARED_PTR_H	.\lib\fbi\cpp\AtomicSharedPtr.h	10;"	d
FBI_CPP_SFRLOCK_H	.\lib\fbi\cpp\sfrlock.h	10;"	d
FBI_CPP_SHUTDOWN_LOCK_H	.\lib\fbi\cpp\ShutdownLock.h	10;"	d
FBI_CPP_TRAITS_H	.\lib\fbi\cpp\traits.h	10;"	d
FBI_CPP_TRIE_H	.\lib\fbi\cpp\Trie.h	10;"	d
FBI_CPP_TRIE_INL_H	.\lib\fbi\cpp\Trie-inl.h	10;"	d
FBI_CPP_UTIL_H	.\lib\fbi\cpp\util.h	10;"	d
FBI_CWLOCK_H	.\lib\fbi\cwlock.h	10;"	d
FBI_DBG_LOGFILE_ENVVAR	.\lib\fbi\debug.h	30;"	d
FBI_DEBUG_H	.\lib\fbi\debug.h	10;"	d
FBI_DECLS_H	.\lib\fbi\decls.h	10;"	d
FBI_ERROR_H	.\lib\fbi\error.h	10;"	d
FBI_ERR_OFFSET	.\lib\fbi\error.c	32;"	d	file:
FBI_FB_CPU_UTIL	.\lib\fbi\fb_cpu_util.h	10;"	d
FBI_LFCALLOC_H	.\lib\fbi\lfcalloc.h	10;"	d
FBI_LOG_CRITICAL	.\lib\fbi\debug.h	111;"	d
FBI_LOG_DEBUG	.\lib\fbi\debug.h	116;"	d
FBI_LOG_DEFAULT	.\lib\fbi\debug.h	121;"	d
FBI_LOG_ERROR	.\lib\fbi\debug.h	112;"	d
FBI_LOG_HIGH	.\lib\fbi\debug.h	120;"	d
FBI_LOG_INFO	.\lib\fbi\debug.h	115;"	d
FBI_LOG_LIMIT_H	.\lib\fbi\log_limit.h	10;"	d
FBI_LOG_LOW	.\lib\fbi\debug.h	118;"	d
FBI_LOG_MEDIUM	.\lib\fbi\debug.h	119;"	d
FBI_LOG_NOTIFY	.\lib\fbi\debug.h	114;"	d
FBI_LOG_SPEW	.\lib\fbi\debug.h	117;"	d
FBI_LOG_WARNING	.\lib\fbi\debug.h	113;"	d
FBI_NETWORK_H	.\lib\fbi\network.h	10;"	d
FBI_NSTRING_H	.\lib\fbi\nstring.h	10;"	d
FBI_QUEUE_H	.\lib\fbi\queue.h	10;"	d
FBI_REMOTEERR	.\lib\fbi\error.h	100;"	d
FBI_SFRLOCK_H	.\lib\fbi\sfrlock.h	10;"	d
FBI_SKIPLIST_H	.\lib\fbi\skiplist.h	10;"	d
FBI_SOCKERR	.\lib\fbi\error.h	92;"	d
FBI_STATIC_ASSERT	.\lib\fbi\debug.h	32;"	d
FBI_SYSERR	.\lib\fbi\error.h	88;"	d
FBI_TEST_UTIL_H	.\lib\fbi\test\test_util.h	10;"	d
FBI_TIMER_H	.\lib\fbi\timer.h	10;"	d
FBI_TIME_H	.\lib\fbi\time.h	10;"	d
FBI_UNIX_H	.\lib\fbi\unix.h	10;"	d
FBI_UTIL_H	.\lib\fbi\util.h	10;"	d
FBI_VERIFY	.\lib\fbi\debug.h	48;"	d
FBI_WAITABLE_COUNT_H	.\lib\fbi\waitable_count.h	10;"	d
FB_MEMCACHE_ASCII_RESPONSE_H	.\lib\mc\ascii_response.h	10;"	d
FB_MEMCACHE_ASOX_QUEUE_H	.\lib\fbi\asox_queue.h	10;"	d
FB_MEMCACHE_ASOX_SEMAPHORE_H	.\lib\fbi\asox_semaphore.h	10;"	d
FB_MEMCACHE_MC_ASCII_CLIENT_H	.\lib\mc\ascii_client.h	10;"	d
FB_MEMCACHE_MC_FBTRACE_H	.\lib\mc\mc_fbtrace_info.h	10;"	d
FB_MEMCACHE_MC_GENERIC_H	.\lib\mc\util.h	10;"	d
FB_MEMCACHE_MC_INTERNAL_PROTOCOL_H	.\lib\mc\_protocol.h	10;"	d
FB_MEMCACHE_MC_MSG_H	.\lib\mc\msg.h	10;"	d
FB_MEMCACHE_MC_PARSER_H	.\lib\mc\parser.h	10;"	d
FB_MEMCACHE_MC_PROTOCOL_H	.\lib\mc\protocol.h	10;"	d
FB_MEMCACHE_MC_UMBRELLA_H	.\lib\mc\umbrella.h	10;"	d
FB_MEMCACHE_MC_UMBRELLA_PROTOCOL_H	.\lib\mc\umbrella_protocol.h	10;"	d
FB_TIMER_DEFAULT_LATENCY_AVG_POWER	.\lib\fbi\timer.c	15;"	d	file:
FB_TIMER_DEFAULT_LATENCY_COUNTDOWN	.\lib\fbi\timer.c	14;"	d	file:
FContext	.\lib\fibers\BoostContextCompatibility.h	/^struct FContext {$/;"	s	namespace:facebook::memcache
FLOOD_MODE	.\lib\fbi\test\asox_queue_test.cpp	21;"	d	file:
FOLLY_ALIGN_TO_AVOID_FALSE_SHARING	.\AtomicTokenBucket.h	/^  std::atomic<double> zeroTime_ FOLLY_ALIGN_TO_AVOID_FALSE_SHARING;$/;"	m	class:facebook::memcache::mcrouter::DynamicAtomicTokenBucket
FURC_CACHE_SIZE	.\lib\fbi\hash.c	50;"	d	file:
FURC_SHIFT	.\lib\fbi\hash.c	47;"	d	file:
FailoverRoute	.\lib\routes\FailoverRoute.h	/^  FailoverRoute(RouteHandleFactory<RouteHandleIf>& factory,$/;"	f	class:facebook::memcache::FailoverRoute
FailoverRoute	.\lib\routes\FailoverRoute.h	/^  explicit FailoverRoute(std::vector<std::shared_ptr<RouteHandleIf>> targets)$/;"	f	class:facebook::memcache::FailoverRoute
FailoverRoute	.\lib\routes\FailoverRoute.h	/^class FailoverRoute {$/;"	c	namespace:facebook::memcache
FailoverServer	.\test\test_slow_box_tko.py	/^class FailoverServer(MockServer):$/;"	c
FailoverWithExptimeRoute	.\routes\FailoverWithExptimeRoute.h	/^  FailoverWithExptimeRoute($/;"	f	class:facebook::memcache::mcrouter::FailoverWithExptimeRoute
FailoverWithExptimeRoute	.\routes\FailoverWithExptimeRoute.h	/^  FailoverWithExptimeRoute(RouteHandleFactory<RouteHandleIf>& factory,$/;"	f	class:facebook::memcache::mcrouter::FailoverWithExptimeRoute
FailoverWithExptimeRoute	.\routes\FailoverWithExptimeRoute.h	/^class FailoverWithExptimeRoute {$/;"	c	namespace:facebook::memcache::mcrouter
FailoverWithExptimeSettings	.\routes\FailoverWithExptimeRouteIf.cpp	/^FailoverWithExptimeSettings::FailoverWithExptimeSettings($/;"	f	class:facebook::memcache::mcrouter::FailoverWithExptimeSettings
FailoverWithExptimeSettings	.\routes\FailoverWithExptimeRouteIf.h	/^struct FailoverWithExptimeSettings {$/;"	s	namespace:facebook::memcache::mcrouter
Fiber	.\lib\fibers\Fiber.cpp	/^Fiber::Fiber(FiberManager& fiberManager) :$/;"	f	class:facebook::memcache::Fiber
Fiber	.\lib\fibers\Fiber.h	/^class Fiber {$/;"	c	namespace:facebook::memcache
FiberManager	.\lib\fibers\FiberManager.cpp	/^FiberManager::FiberManager(std::unique_ptr<LoopController> loopController,$/;"	f	class:facebook::memcache::FiberManager
FiberManager	.\lib\fibers\FiberManager.h	/^class FiberManager {$/;"	c	namespace:facebook::memcache
FiberPromise	.\lib\fibers\FiberPromise-inl.h	/^FiberPromise<T>::FiberPromise(folly::wangle::Try<T>& value, Baton& baton) :$/;"	f	class:facebook::memcache::FiberPromise
FiberPromise	.\lib\fibers\FiberPromise.h	/^class FiberPromise {$/;"	c	namespace:facebook::memcache
FileDataProvider	.\FileDataProvider.cpp	/^FileDataProvider::FileDataProvider(std::string filePath)$/;"	f	class:facebook::memcache::mcrouter::FileDataProvider
FileDataProvider	.\FileDataProvider.h	/^class FileDataProvider {$/;"	c	namespace:facebook::memcache::mcrouter
FileInfo	.\ConfigApi.h	/^  struct FileInfo {$/;"	s	class:facebook::memcache::mcrouter::ConfigType::ConfigApi
FileObserver	.\FileObserver.h	/^class FileObserver {$/;"	c	namespace:facebook::memcache::mcrouter
Finally	.\lib\fibers\FiberManager-inl.h	/^    Finally(G&& finally,$/;"	f	class:facebook::memcache::FiberManager::AddTaskFinallyHelper::Finally
Finally	.\lib\fibers\FiberManager-inl.h	/^  class Finally {$/;"	c	struct:facebook::memcache::FiberManager::AddTaskFinallyHelper
FirstArgOf	.\lib\fbi\cpp\traits.h	/^struct FirstArgOf {$/;"	s	namespace:facebook::memcache
FirstArgOf	.\lib\fbi\cpp\traits.h	/^struct FirstArgOf<F, typename std::enable_if<std::is_class<F>::value>::type> {$/;"	s	namespace:facebook::memcache
Func	.\lib\config\ConfigPreprocessor.cpp	/^  typedef std::function<dynamic(const Context&)> Func;$/;"	t	class:facebook::memcache::ConfigPreprocessor::Macro	file:
Func	.\lib\fibers\FiberManager-inl.h	/^    Func(F&& func, Finally& finally) :$/;"	f	class:facebook::memcache::FiberManager::AddTaskFinallyHelper::Func
Func	.\lib\fibers\FiberManager-inl.h	/^  class Func {$/;"	c	struct:facebook::memcache::FiberManager::AddTaskFinallyHelper
GROUP	.\stat_list.h	104;"	d
GROUP	.\stat_list.h	105;"	d
GROUP	.\stat_list.h	10;"	d
GROUP	.\stat_list.h	115;"	d
GROUP	.\stat_list.h	116;"	d
GROUP	.\stat_list.h	127;"	d
GROUP	.\stat_list.h	128;"	d
GROUP	.\stat_list.h	16;"	d
GROUP	.\stat_list.h	173;"	d
GROUP	.\stat_list.h	174;"	d
GROUP	.\stat_list.h	17;"	d
GROUP	.\stat_list.h	220;"	d
GROUP	.\stat_list.h	221;"	d
GROUP	.\stat_list.h	244;"	d
GROUP	.\stat_list.h	245;"	d
GROUP	.\stat_list.h	269;"	d
GROUP	.\stat_list.h	26;"	d
GROUP	.\stat_list.h	270;"	d
GROUP	.\stat_list.h	277;"	d
GROUP	.\stat_list.h	278;"	d
GROUP	.\stat_list.h	27;"	d
GROUP	.\stat_list.h	283;"	d
GROUP	.\stat_list.h	284;"	d
GROUP	.\stat_list.h	289;"	d
GROUP	.\stat_list.h	290;"	d
GROUP	.\stat_list.h	311;"	d
GROUP	.\stat_list.h	312;"	d
GROUP	.\stat_list.h	333;"	d
GROUP	.\stat_list.h	334;"	d
GROUP	.\stat_list.h	336;"	d
GROUP	.\stat_list.h	337;"	d
GROUP	.\stat_list.h	342;"	d
GROUP	.\stat_list.h	343;"	d
GROUP	.\stat_list.h	345;"	d
GROUP	.\stat_list.h	57;"	d
GROUP	.\stat_list.h	58;"	d
GROUP	.\stat_list.h	60;"	d
GROUP	.\stat_list.h	61;"	d
GROUP	.\stat_list.h	82;"	d
GROUP	.\stat_list.h	83;"	d
GenericBaton	.\lib\fibers\GenericBaton.h	/^typedef Baton GenericBaton;$/;"	t	namespace:facebook::memcache
GenericProxyRequestContext	.\mcrouter_config.h	/^typedef LoggingProxyRequestContext GenericProxyRequestContext;$/;"	t	namespace:facebook::memcache::mcrouter
GetLike	.\lib\McOperationTraits.h	/^struct GetLike<McOperation<mc_op_get>> {$/;"	s	namespace:facebook::memcache
GetLike	.\lib\McOperationTraits.h	/^struct GetLike<McOperation<mc_op_get_count>> {$/;"	s	namespace:facebook::memcache
GetLike	.\lib\McOperationTraits.h	/^struct GetLike<McOperation<mc_op_get_unique_count>> {$/;"	s	namespace:facebook::memcache
GetLike	.\lib\McOperationTraits.h	/^struct GetLike<McOperation<mc_op_gets>> {$/;"	s	namespace:facebook::memcache
GetLike	.\lib\McOperationTraits.h	/^struct GetLike<McOperation<mc_op_lease_get>> {$/;"	s	namespace:facebook::memcache
GetLike	.\lib\McOperationTraits.h	/^struct GetLike<McOperation<mc_op_metaget>> {$/;"	s	namespace:facebook::memcache
GetLike	.\lib\OperationTraits.h	/^struct GetLike {$/;"	s	namespace:facebook::memcache
GetRouteTestData	.\lib\test\RouteHandleTestUtil.h	/^  GetRouteTestData($/;"	f	struct:facebook::memcache::GetRouteTestData
GetRouteTestData	.\lib\test\RouteHandleTestUtil.h	/^  GetRouteTestData() :$/;"	f	struct:facebook::memcache::GetRouteTestData
GetRouteTestData	.\lib\test\RouteHandleTestUtil.h	/^struct GetRouteTestData {$/;"	s	namespace:facebook::memcache
GuardPageAllocator	.\lib\fibers\GuardPageAllocator.h	/^class GuardPageAllocator {$/;"	c	namespace:facebook::memcache
HASH_STOP	.\lib\fbi\test\hash_test.cpp	25;"	d	file:
HandlerFunc	.\lib\fbi\cpp\LogFailure.h	/^HandlerFunc;$/;"	t	namespace:facebook::memcache::failure
HashFunc	.\lib\test\RouteHandleTest.cpp	/^  explicit HashFunc(size_t n) : n_(n) {}$/;"	f	class:HashFunc
HashFunc	.\lib\test\RouteHandleTest.cpp	/^class HashFunc {$/;"	c	file:
HashFunc	.\routes\test\ReliablePoolRouteTest.cpp	/^  explicit HashFunc(size_t n) : n_(n) {}$/;"	f	class:HashFunc
HashFunc	.\routes\test\ReliablePoolRouteTest.cpp	/^class HashFunc {$/;"	c	file:
HashRoute	.\lib\routes\HashRoute.h	/^  HashRoute(const folly::dynamic& json,$/;"	f	class:facebook::memcache::HashRoute
HashRoute	.\lib\routes\HashRoute.h	/^  HashRoute(std::vector<std::shared_ptr<RouteHandleIf>> rh,$/;"	f	class:facebook::memcache::HashRoute
HashRoute	.\lib\routes\HashRoute.h	/^class HashRoute {$/;"	c	namespace:facebook::memcache
HostIdRoute	.\lib\routes\HostIdRoute.h	/^  HostIdRoute(RouteHandleFactory<RouteHandleIf>& factory,$/;"	f	class:facebook::memcache::HostIdRoute
HostIdRoute	.\lib\routes\HostIdRoute.h	/^class HostIdRoute {$/;"	c	namespace:facebook::memcache
I32	.\lib\mc\umbrella.h	/^  I32,                      \/\/ int32_t$/;"	e	enum:entry_type_e
I64	.\lib\mc\umbrella.h	/^  I64,                      \/\/ int64_t$/;"	e	enum:entry_type_e
INOTIFY_BUF_SIZE	.\FileDataProvider.cpp	/^const size_t INOTIFY_BUF_SIZE = 1024;$/;"	m	namespace:facebook::memcache::mcrouter	file:
INOTIFY_MASK	.\FileDataProvider.cpp	/^const uint32_t INOTIFY_MASK =$/;"	m	namespace:facebook::memcache::mcrouter	file:
INVALID	.\lib\fibers\Fiber.h	/^    INVALID,                    \/**< Does't have task function *\/$/;"	e	enum:facebook::memcache::Fiber::State
IOV_FORMAT	.\lib\mc\ascii_response.c	31;"	d	file:
IOV_WRITE	.\lib\mc\ascii_response.c	17;"	d	file:
IOV_WRITE_CONST_STR	.\lib\mc\ascii_response.c	27;"	d	file:
IOV_WRITE_IP	.\lib\mc\ascii_response.c	43;"	d	file:
IOV_WRITE_NSTRING	.\lib\mc\ascii_response.c	29;"	d	file:
IOV_WRITE_STR	.\lib\mc\ascii_response.c	24;"	d	file:
ITERATIONS	.\lib\fbi\test\log_coalesce_test.cpp	20;"	d	file:
ImportResolverIf	.\lib\config\ImportResolverIf.h	/^class ImportResolverIf {$/;"	c	namespace:facebook::memcache
Info	.\lib\fbi\test\asox_queue_test.cpp	/^  Info() {}$/;"	f	struct:__anon19::Info
Info	.\lib\fbi\test\asox_queue_test.cpp	/^struct Info {$/;"	s	namespace:__anon19	file:
InstallDir	.\test\mcrouter_config.py	/^    InstallDir = '.'$/;"	v	class:McrouterGlobals
IsRvalueRefTry	.\lib\fibers\FiberManager-inl.h	/^struct IsRvalueRefTry { static const bool value = false; };$/;"	s	namespace:facebook::memcache
IsRvalueRefTry	.\lib\fibers\FiberManager-inl.h	/^struct IsRvalueRefTry<folly::wangle::Try<T>&&> { static const bool value = true; };$/;"	s	namespace:facebook::memcache
IsVector	.\options.cpp	/^template <class T> struct IsVector : public std::false_type {};$/;"	s	namespace:folly::__anon47	file:
IsVector	.\options.cpp	/^template <class T> struct IsVector<std::vector<T>> : public std::true_type {};$/;"	s	namespace:folly::__anon47	file:
Item	.\lib\network\test\MockMc.cpp	/^MockMc::Item::Item(const McRequest& req)$/;"	f	class:facebook::memcache::MockMc::Item
Item	.\lib\network\test\MockMc.cpp	/^MockMc::Item::Item(std::unique_ptr<folly::IOBuf> v)$/;"	f	class:facebook::memcache::MockMc::Item
Item	.\lib\network\test\MockMc.h	/^  struct Item {$/;"	s	class:facebook::memcache::MockMc
Item	.\routes\McOpList.h	/^  struct Item {};$/;"	s	struct:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item< 1> { typedef McOperation<mc_op_echo> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item< 2> { typedef McOperation<mc_op_version> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item< 3> { typedef McOperation<mc_op_replace> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item< 4> { typedef McOperation<mc_op_cas> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item< 5> { typedef McOperation<mc_op_decr> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item< 6> { typedef McOperation<mc_op_stats> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item< 7> { typedef McOperation<mc_op_metaget> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item< 8> { typedef McOperation<mc_op_gets> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item< 9> { typedef McOperation<mc_op_get_service_info> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item<10> { typedef McOperation<mc_op_bump_unique_count> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item<11> { typedef McOperation<mc_op_get_count> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item<12> { typedef McOperation<mc_op_bump_count> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item<13> { typedef McOperation<mc_op_get_unique_count> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item<14> { typedef McOperation<mc_op_incr> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item<15> { typedef McOperation<mc_op_add> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item<16> { typedef McOperation<mc_op_lease_set> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item<17> { typedef McOperation<mc_op_set> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item<18> { typedef McOperation<mc_op_delete> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item<19> { typedef McOperation<mc_op_lease_get> op; };$/;"	s	class:facebook::memcache::McOpList
Item	.\routes\McOpList.h	/^template <> struct McOpList::Item<20> { typedef McOperation<mc_op_get> op; };$/;"	s	class:facebook::memcache::McOpList
Join	.\lib\OperationTraits.h	/^struct Join$/;"	s	namespace:facebook::memcache::detail
Keys	.\lib\McRequestBase.h	/^    Keys() {}$/;"	f	struct:facebook::memcache::McRequestBase::Keys
Keys	.\lib\McRequestBase.h	/^  struct Keys {$/;"	s	class:facebook::memcache::McRequestBase
LIST_EMPTY	.\lib\fbi\queue.h	388;"	d
LIST_ENTRY	.\lib\fbi\queue.h	353;"	d
LIST_FIRST	.\lib\fbi\queue.h	390;"	d
LIST_FOREACH	.\lib\fbi\queue.h	392;"	d
LIST_FOREACH_SAFE	.\lib\fbi\queue.h	397;"	d
LIST_HEAD	.\lib\fbi\queue.h	345;"	d
LIST_HEAD_INITIALIZER	.\lib\fbi\queue.h	350;"	d
LIST_INIT	.\lib\fbi\queue.h	402;"	d
LIST_INSERT_AFTER	.\lib\fbi\queue.h	406;"	d
LIST_INSERT_BEFORE	.\lib\fbi\queue.h	415;"	d
LIST_INSERT_HEAD	.\lib\fbi\queue.h	423;"	d
LIST_NEXT	.\lib\fbi\queue.h	431;"	d
LIST_REMOVE	.\lib\fbi\queue.h	433;"	d
LIST_SWAP	.\lib\fbi\queue.h	444;"	d
LastItem	.\routes\McOpList.h	/^  typedef Item<kLastItemId> LastItem;$/;"	t	struct:facebook::memcache::McOpList
LatestRoute	.\lib\routes\LatestRoute.h	/^  LatestRoute(const folly::dynamic& json,$/;"	f	class:facebook::memcache::LatestRoute
LatestRoute	.\lib\routes\LatestRoute.h	/^  LatestRoute(std::vector<std::shared_ptr<RouteHandleIf>> targets,$/;"	f	class:facebook::memcache::LatestRoute
LatestRoute	.\lib\routes\LatestRoute.h	/^class LatestRoute {$/;"	c	namespace:facebook::memcache
LeaseSetResult	.\lib\network\test\MockMc.h	/^  enum LeaseSetResult {$/;"	g	class:facebook::memcache::MockMc
List	.\lib\fbi\cpp\TypeList.h	/^struct List {};$/;"	s	namespace:facebook::memcache
ListHook	.\lib\fibers\TimeoutController.h	/^    boost::intrusive::link_mode<boost::intrusive::auto_unlink>> ListHook;$/;"	t	class:facebook::memcache::TimeoutHandle
LoggingProxyRequestContext	.\LoggingProxyRequestContext.h	/^  explicit LoggingProxyRequestContext(Args&&... args)$/;"	f	class:facebook::memcache::mcrouter::LoggingProxyRequestContext
LoggingProxyRequestContext	.\LoggingProxyRequestContext.h	/^class LoggingProxyRequestContext {$/;"	c	namespace:facebook::memcache::mcrouter
LoopController	.\lib\fibers\LoopController.h	/^class LoopController {$/;"	c	namespace:facebook::memcache
LoopFn	.\lib\network\AsyncMcServer.h	/^                             facebook::memcache::AsyncMcServerWorker&)> LoopFn;$/;"	t	class:facebook::memcache::AsyncMcServer
MAX	.\lib\fbi\counting_sem.c	21;"	d	file:
MAX	.\lib\mc\util.h	17;"	d
MAXIMUM_BACKOFF	.\lib\fbi\debug.c	205;"	d	file:
MAXLEVEL	.\lib\fbi\skiplist.c	31;"	d	file:
MAX_COUNTER_INFLATIONS	.\lib\fbi\counter.h	135;"	d
MAX_EXTERN_STRINGS	.\lib\mc\umbrella.h	110;"	d
MAX_HASH_SALT_LEN	.\PoolFactory.cpp	/^const int MAX_HASH_SALT_LEN = 255;$/;"	m	namespace:facebook::memcache::mcrouter::__anon49	file:
MAX_KEY_LENGTH	.\lib\fbi\test\hash_test.cpp	17;"	d	file:
MAX_NUMBER_OF_STORED_ERRORS	.\lib\fbi\error.h	24;"	d
MAX_TRIES	.\lib\fbi\hash.c	42;"	d	file:
MCASCII_KEY_LVALUE_REQ_TO_HDR	.\lib\mc\protocol.c	74;"	d	file:
MCASCII_KEY_NUM_REQ_TO_HDR	.\lib\mc\protocol.c	92;"	d	file:
MCASCII_KEY_REQ_TO_HDR	.\lib\mc\protocol.c	24;"	d	file:
MCASCII_KEY_VALUE_REQ_TO_HDR	.\lib\mc\protocol.c	39;"	d	file:
MCASCII_NUM_REQ_TO_HDR	.\lib\mc\protocol.c	/^MCASCII_NUM_REQ_TO_HDR(flushall, flush_all)$/;"	f
MCASCII_NUM_REQ_TO_HDR	.\lib\mc\protocol.c	114;"	d	file:
MCPopen	.\test\MCProcess.py	/^def MCPopen(cmd, stdout=None, stderr=None, env=None):$/;"	f
MCProcess	.\test\MCProcess.py	/^class MCProcess(object):$/;"	c
MCROUTER_INSTALL_PATH	.\mcrouter_config.h	31;"	d
MCROUTER_LIB_FBI_ASOX_TIMER_H	.\lib\fbi\asox_timer.h	10;"	d
MCROUTER_PACKAGE_STRING	.\mcrouter_config.h	174;"	d
MCROUTER_PACKAGE_STRING	.\mcrouter_config.h	176;"	d
MCROUTER_RUNTIME_VARS_DEFAULT	.\mcrouter_config.h	29;"	d
MCROUTER_STATS_ROOT_DEFAULT	.\mcrouter_config.h	30;"	d
MCROUTER_TEST_CLIENT_H	.\test\cpp_unit_tests\mcrouter_test_client.h	10;"	d
MCRouterTestClient	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^MCRouterTestClient::MCRouterTestClient(const std::string& name,$/;"	f	class:MCRouterTestClient
MCRouterTestClient	.\test\cpp_unit_tests\mcrouter_test_client.h	/^class MCRouterTestClient {$/;"	c	namespace:facebook::memcache::test
MC_ASCII_EMPTY_REQ_TO_HDR	.\lib\mc\protocol.c	138;"	d	file:
MC_ASCII_EXPTIME_MAX_LEN	.\lib\mc\_protocol.h	22;"	d
MC_ASCII_FLAGS_MAX_LEN	.\lib\mc\_protocol.h	21;"	d
MC_ASCII_LEASE_TOKEN_MAX_LEN	.\lib\mc\_protocol.h	20;"	d
MC_ASCII_REPLY_HDR_MAX_LEN	.\lib\mc\_protocol.h	36;"	d
MC_ASCII_REPLY_HDR_MAX_TOKENS	.\lib\mc\_protocol.h	42;"	d
MC_ASCII_REQ_HDR_MAX_LEN	.\lib\mc\_protocol.h	24;"	d
MC_ASCII_REQ_HDR_MAX_TOKENS	.\lib\mc\_protocol.h	31;"	d
MC_ASCII_SIZE_MAX_LEN	.\lib\mc\_protocol.h	23;"	d
MC_ASCII_STRING_REQ_TO_HDR	.\lib\mc\protocol.c	124;"	d	file:
MC_KEY_MAX_LEN	.\lib\mc\protocol.h	24;"	d
MC_KEY_MAX_LEN_ASCII	.\lib\mc\protocol.h	22;"	d
MC_KEY_MAX_LEN_UMBRELLA	.\lib\mc\protocol.h	23;"	d
MC_MSG_FLAG_ASCII_INT_SERIALIZED	.\lib\mc\msg.h	/^    MC_MSG_FLAG_ASCII_INT_SERIALIZED = 0x10,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_BIG_VALUE	.\lib\mc\msg.h	/^    MC_MSG_FLAG_BIG_VALUE = 0X8000,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_COMPRESSED	.\lib\mc\msg.h	/^    MC_MSG_FLAG_COMPRESSED = 0x2,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_FB_COMPACT_SERIALIZED	.\lib\mc\msg.h	/^    MC_MSG_FLAG_FB_COMPACT_SERIALIZED = 0x8,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_FB_SERIALIZED	.\lib\mc\msg.h	/^    MC_MSG_FLAG_FB_SERIALIZED = 0x4,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_NEGATIVE_CACHE	.\lib\mc\msg.h	/^    MC_MSG_FLAG_NEGATIVE_CACHE = 0x10000,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_NZLIB_COMPRESSED	.\lib\mc\msg.h	/^    MC_MSG_FLAG_NZLIB_COMPRESSED = 0x800,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_PHP_SERIALIZED	.\lib\mc\msg.h	/^    MC_MSG_FLAG_PHP_SERIALIZED = 0x1,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_QUICKLZ_COMPRESSED	.\lib\mc\msg.h	/^    MC_MSG_FLAG_QUICKLZ_COMPRESSED = 0x2000,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_SNAPPY_COMPRESSED	.\lib\mc\msg.h	/^    MC_MSG_FLAG_SNAPPY_COMPRESSED = 0x4000,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_1	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_1 = 0x100000000LL,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_10	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_10 = 0x20000000000LL,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_11	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_11 = 0x40000000000LL,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_12	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_12 = 0x80000000000LL,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_13	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_13 = 0x100000000000LL,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_14	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_14 = 0x200000000000LL,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_15	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_15 = 0x400000000000LL,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_16	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_16 = 0x800000000000LL$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_2	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_2 = 0x200000000LL,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_3	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_3 = 0x400000000LL,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_4	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_4 = 0x800000000LL,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_5	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_5 = 0x1000000000LL,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_6	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_6 = 0x2000000000LL,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_7	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_7 = 0x4000000000LL,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_8	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_8 = 0x8000000000LL,$/;"	e	enum:mc_msg_flags_t
MC_MSG_FLAG_USER_9	.\lib\mc\msg.h	/^    MC_MSG_FLAG_USER_9 = 0x10000000000LL,$/;"	e	enum:mc_msg_flags_t
MC_OP	.\lib\McOpList.h	11;"	d
MC_OP	.\lib\McOpList.h	44;"	d
MC_OP	.\lib\network\McServerRequestContext-inl.h	18;"	d
MC_TOKEN_INCREMENT	.\lib\mc\parser.h	29;"	d
MC_TOKEN_MAX_LEN	.\lib\mc\parser.h	28;"	d
MC_VALUE_MAX_LEN	.\lib\mc\protocol.h	25;"	d
MEGAHERTZ	.\lib\fbi\fb_cpu_util.c	29;"	d	file:
MEMCACHE_CONFIG	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	44;"	d	file:
MEMCACHE_HASH_STOP	.\lib\mc\msg.h	23;"	d
MEMCACHE_LOCAL_H	.\test\cpp_unit_tests\MemcacheLocal.h	10;"	d
MEMCACHE_ROUTE	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	45;"	d	file:
MEMCACHE_SHADOW_POLICY	.\proxy.h	/^  MEMCACHE_SHADOW_POLICY,$/;"	e	enum:facebook::memcache::mcrouter::shadow_policy_t
MIGRATED_POOL	.\proxy.h	/^  MIGRATED_POOL,$/;"	e	enum:facebook::memcache::mcrouter::proxy_pool_type_t
MIN	.\lib\fbi\counting_sem.c	20;"	d	file:
MIN	.\lib\mc\util.h	16;"	d
MOVING_AVERAGE_BIN_SIZE_IN_SECOND	.\proxy.h	46;"	d
MOVING_AVERAGE_WINDOW_SIZE_IN_SECOND	.\proxy.h	43;"	d
MSG_NOT_REFCOUNTED	.\lib\mc\msg.h	22;"	d
Macro	.\lib\config\ConfigPreprocessor.cpp	/^  Macro(string name, const vector<dynamic>& params, Func f)$/;"	f	class:facebook::memcache::ConfigPreprocessor::Macro
Macro	.\lib\config\ConfigPreprocessor.cpp	/^class ConfigPreprocessor::Macro {$/;"	c	class:facebook::memcache::ConfigPreprocessor	file:
MainContextDeleter	.\proxy.cpp	/^struct MainContextDeleter {$/;"	s	namespace:facebook::memcache::mcrouter	file:
MarkHardTko	.\TkoLog.h	/^  MarkHardTko,$/;"	m	class:facebook::memcache::mcrouter::TkoLogEvent
MarkLatencyTko	.\TkoLog.h	/^  MarkLatencyTko,$/;"	m	class:facebook::memcache::mcrouter::TkoLogEvent
MarkSoftTko	.\TkoLog.h	/^  MarkSoftTko,$/;"	m	class:facebook::memcache::mcrouter::TkoLogEvent
McExtraRouteHandleProvider	.\routes\McExtraRouteHandleProvider.h	/^class McExtraRouteHandleProvider : public ExtraRouteHandleProviderIf {$/;"	c	namespace:facebook::memcache::mcrouter
McFbtraceRefPolicy	.\lib\McRequestBase.h	/^  struct McFbtraceRefPolicy {$/;"	s	class:facebook::memcache::McRequestBase
McImportResolver	.\routes\McImportResolver.cpp	/^McImportResolver::McImportResolver(ConfigApi* configApi)$/;"	f	class:facebook::memcache::mcrouter::McImportResolver
McImportResolver	.\routes\McImportResolver.h	/^class McImportResolver : public ImportResolverIf {$/;"	c	namespace:facebook::memcache::mcrouter
McMsgRef	.\lib\McMsgRef.h	/^typedef Ref<const mc_msg_t, McMsgRefPolicy> McMsgRef;$/;"	t	namespace:facebook::memcache
McMsgRefPolicy	.\lib\McMsgRef.h	/^struct McMsgRefPolicy {$/;"	s	namespace:facebook::memcache
McOpList	.\routes\McOpList.h	/^struct McOpList {$/;"	s	namespace:facebook::memcache
McOperation	.\lib\McOperation.h	/^struct McOperation {$/;"	s	namespace:facebook::memcache
McParser	.\lib\network\McParser.cpp	/^McParser::McParser(ClientParseCallback* callback,$/;"	f	class:facebook::memcache::McParser
McParser	.\lib\network\McParser.cpp	/^McParser::McParser(ServerParseCallback* callback,$/;"	f	class:facebook::memcache::McParser
McParser	.\lib\network\McParser.h	/^class McParser {$/;"	c	namespace:facebook::memcache
McReply	.\lib\McReply.h	/^  explicit McReply(Args&&... args)$/;"	f	class:facebook::memcache::McReply
McReply	.\lib\McReply.h	/^class McReply : public McReplyBase {$/;"	c	namespace:facebook::memcache
McReplyBase	.\lib\McReplyBase-inl.h	/^McReplyBase::McReplyBase(DefaultReplyT, Operation)$/;"	f	class:facebook::memcache::McReplyBase
McReplyBase	.\lib\McReplyBase.cpp	/^McReplyBase::McReplyBase() {$/;"	f	class:facebook::memcache::McReplyBase
McReplyBase	.\lib\McReplyBase.cpp	/^McReplyBase::McReplyBase(mc_res_t res)$/;"	f	class:facebook::memcache::McReplyBase
McReplyBase	.\lib\McReplyBase.cpp	/^McReplyBase::McReplyBase(mc_res_t res, McMsgRef&& msg)$/;"	f	class:facebook::memcache::McReplyBase
McReplyBase	.\lib\McReplyBase.cpp	/^McReplyBase::McReplyBase(mc_res_t res, const char* value)$/;"	f	class:facebook::memcache::McReplyBase
McReplyBase	.\lib\McReplyBase.cpp	/^McReplyBase::McReplyBase(mc_res_t res, const std::string& value)$/;"	f	class:facebook::memcache::McReplyBase
McReplyBase	.\lib\McReplyBase.cpp	/^McReplyBase::McReplyBase(mc_res_t res, folly::IOBuf val,$/;"	f	class:facebook::memcache::McReplyBase
McReplyBase	.\lib\McReplyBase.cpp	/^McReplyBase::McReplyBase(mc_res_t res, folly::StringPiece val)$/;"	f	class:facebook::memcache::McReplyBase
McReplyBase	.\lib\McReplyBase.h	/^  explicit McReplyBase(ErrorReplyT, folly::StringPiece valueToSet="")$/;"	f	class:facebook::memcache::McReplyBase
McReplyBase	.\lib\McReplyBase.h	/^  explicit McReplyBase(TkoReplyT)$/;"	f	class:facebook::memcache::McReplyBase
McReplyBase	.\lib\McReplyBase.h	/^class McReplyBase {$/;"	c	namespace:facebook::memcache
McRequest	.\lib\McRequest.h	/^  McRequest(const McRequest& other)$/;"	f	class:facebook::memcache::McRequest
McRequest	.\lib\McRequest.h	/^  explicit McRequest(Args&&... args)$/;"	f	class:facebook::memcache::McRequest
McRequest	.\lib\McRequest.h	/^class McRequest : public McRequestBase {$/;"	c	namespace:facebook::memcache
McRequestBase	.\lib\McRequestBase.cpp	/^McRequestBase::McRequestBase(McMsgRef&& msg)$/;"	f	class:facebook::memcache::McRequestBase
McRequestBase	.\lib\McRequestBase.cpp	/^McRequestBase::McRequestBase(const McRequestBase& other)$/;"	f	class:facebook::memcache::McRequestBase
McRequestBase	.\lib\McRequestBase.cpp	/^McRequestBase::McRequestBase(folly::StringPiece key)$/;"	f	class:facebook::memcache::McRequestBase
McRequestBase	.\lib\McRequestBase.h	/^  McRequestBase() {}$/;"	f	class:facebook::memcache::McRequestBase
McRequestBase	.\lib\McRequestBase.h	/^class McRequestBase {$/;"	c	namespace:facebook::memcache
McRequestWithContext	.\lib\McRequestWithContext-inl.h	/^McRequestWithContext<Ctx>::McRequestWithContext($/;"	f	class:facebook::memcache::McRequestWithContext
McRequestWithContext	.\lib\McRequestWithContext-inl.h	/^McRequestWithContext<Ctx>::McRequestWithContext(std::shared_ptr<Ctx> ctx,$/;"	f	class:facebook::memcache::McRequestWithContext
McRequestWithContext	.\lib\McRequestWithContext.h	/^class McRequestWithContext : public McRequestBase {$/;"	c	namespace:facebook::memcache
McRouteHandleProvider	.\routes\McRouteHandleProvider.cpp	/^McRouteHandleProvider::McRouteHandleProvider($/;"	f	class:facebook::memcache::mcrouter::McRouteHandleProvider
McRouteHandleProvider	.\routes\McRouteHandleProvider.h	/^class McRouteHandleProvider :$/;"	c	namespace:facebook::memcache::mcrouter
McSerializedRequest	.\lib\network\McSerializedRequest.cpp	/^McSerializedRequest::McSerializedRequest(const McRequest& req,$/;"	f	class:facebook::memcache::McSerializedRequest
McSerializedRequest	.\lib\network\McSerializedRequest.h	/^class McSerializedRequest {$/;"	c	namespace:facebook::memcache
McServerOnRequest	.\lib\network\McServerRequestContext.h	/^  McServerOnRequest() {}$/;"	f	class:facebook::memcache::McServerOnRequest
McServerOnRequest	.\lib\network\McServerRequestContext.h	/^class McServerOnRequest {$/;"	c	namespace:facebook::memcache
McServerOnRequestWrapper	.\lib\network\McServerRequestContext.h	/^  explicit McServerOnRequestWrapper(Args&&... args)$/;"	f	class:facebook::memcache::McServerOnRequestWrapper
McServerOnRequestWrapper	.\lib\network\McServerRequestContext.h	/^class McServerOnRequestWrapper : public McServerOnRequest {$/;"	c	namespace:facebook::memcache
McServerRequestContext	.\lib\network\McServerRequestContext.cpp	/^McServerRequestContext::McServerRequestContext($/;"	f	class:facebook::memcache::McServerRequestContext
McServerRequestContext	.\lib\network\McServerRequestContext.h	/^class McServerRequestContext {$/;"	c	namespace:facebook::memcache
McServerSession	.\lib\network\McServerSession.cpp	/^McServerSession::McServerSession($/;"	f	class:facebook::memcache::McServerSession
McServerSession	.\lib\network\McServerSession.h	/^class McServerSession :$/;"	c	namespace:facebook::memcache
McServerThread	.\lib\network\AsyncMcServer.cpp	/^  McServerThread($/;"	f	class:facebook::memcache::McServerThread
McServerThread	.\lib\network\AsyncMcServer.cpp	/^  explicit McServerThread(AsyncMcServer& server)$/;"	f	class:facebook::memcache::McServerThread
McServerThread	.\lib\network\AsyncMcServer.cpp	/^class McServerThread {$/;"	c	namespace:facebook::memcache	file:
Mcrouter	.\test\MCProcess.py	/^class Mcrouter(MCProcess):$/;"	c
Mcrouter	.\test\McrouterTestCase.py	/^from mcrouter.test.MCProcess import Mcrouter$/;"	i
Mcrouter	.\test\test_shadow_with_file.py	/^from mcrouter.test.MCProcess import Mcrouter$/;"	i
McrouterClient	.\test\MCProcess.py	/^class McrouterClient(MCProcess):$/;"	c
McrouterGlobals	.\test\MCProcess.py	/^from mcrouter.test.config import McrouterGlobals$/;"	i
McrouterGlobals	.\test\mcrouter_config.py	/^class McrouterGlobals:$/;"	c
McrouterGlobals	.\test\test_bad_params.py	/^from mcrouter.test.config import McrouterGlobals$/;"	i
McrouterGlobals	.\test\test_multiple_ports.py	/^from mcrouter.test.config import McrouterGlobals$/;"	i
McrouterGlobals	.\test\test_validate_config.py	/^from mcrouter.test.config import McrouterGlobals$/;"	i
McrouterLogger	.\McrouterLogger.cpp	/^McrouterLogger::McrouterLogger(mcrouter_t* router,$/;"	f	class:facebook::memcache::mcrouter::McrouterLogger
McrouterLogger	.\McrouterLogger.h	/^class McrouterLogger {$/;"	c	namespace:facebook::memcache::mcrouter
McrouterManager	.\router.cpp	/^class McrouterManager {$/;"	c	namespace:facebook::memcache::mcrouter::__anon56	file:
McrouterOptionData	.\options.h	/^struct McrouterOptionData {$/;"	s	namespace:facebook::memcache
McrouterOptionError	.\options.h	/^struct McrouterOptionError {$/;"	s	namespace:facebook::memcache
McrouterOptionsBase	.\options.h	/^class McrouterOptionsBase {$/;"	c	namespace:facebook::memcache
McrouterRouteHandle	.\routes\McrouterRouteHandle.h	/^  explicit McrouterRouteHandle(Args&&... args)$/;"	f	class:facebook::memcache::mcrouter::McrouterRouteHandle
McrouterRouteHandle	.\routes\McrouterRouteHandle.h	/^class McrouterRouteHandle :$/;"	c	namespace:facebook::memcache::mcrouter
McrouterRouteHandleIf	.\routes\McrouterRouteHandle.h	/^class McrouterRouteHandleIf :$/;"	c	namespace:facebook::memcache::mcrouter
McrouterRouteHandlePtr	.\routes\McrouterRouteHandle.h	/^typedef std::shared_ptr<McrouterRouteHandleIf> McrouterRouteHandlePtr;$/;"	t	namespace:facebook::memcache::mcrouter
McrouterTestCase	.\test\McrouterTestCase.py	/^class McrouterTestCase(unittest.TestCase):$/;"	c
McrouterTestCase	.\test\test_ascii_error.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_async_files.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_const_shard_hash.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_empty_pool.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_largeobj.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_logical_routing_policies.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_max_shadow_requests.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_mcrouter.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_mcrouter_basic.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_mcrouter_sanity.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_migrated_failover.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_miss_on_error_arith_ops.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_noreply.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_probe_timeout.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_rates.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_reliable_pool_policy.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_routing_prefixes.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_send_to_all_hosts.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_server_stats.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_service_info.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_shadow.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_shadow_with_file.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_shard_splits.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_slow_box_tko.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_umbrella_server.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_warmup.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
McrouterTestCase	.\test\test_wch3.py	/^from mcrouter.test.McrouterTestCase import McrouterTestCase$/;"	i
Md5Hash	.\lib\fbi\cpp\util.cpp	/^std::string Md5Hash(folly::StringPiece input) {$/;"	f	namespace:facebook::memcache
MemcacheLocal	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^MemcacheLocal::MemcacheLocal(const int port)$/;"	f	class:facebook::memcache::test::MemcacheLocal
MemcacheLocal	.\test\cpp_unit_tests\MemcacheLocal.h	/^class MemcacheLocal {$/;"	c	namespace:facebook::memcache::test
Memcached	.\test\MCProcess.py	/^class Memcached(MCProcess):$/;"	c
Memcached	.\test\test_const_shard_hash.py	/^from mcrouter.test.MCProcess import Memcached$/;"	i
Memcached	.\test\test_max_shadow_requests.py	/^from mcrouter.test.MCProcess import Memcached$/;"	i
Memcached	.\test\test_mcrouter.py	/^from mcrouter.test.MCProcess import Memcached$/;"	i
Memcached	.\test\test_mcrouter_sanity.py	/^from mcrouter.test.MCProcess import Memcached$/;"	i
Memcached	.\test\test_migrated_failover.py	/^from mcrouter.test.MCProcess import Memcached$/;"	i
Memcached	.\test\test_noreply.py	/^from mcrouter.test.MCProcess import Memcached$/;"	i
Memcached	.\test\test_rates.py	/^from mcrouter.test.MCProcess import Memcached$/;"	i
Memcached	.\test\test_reliable_pool_policy.py	/^from mcrouter.test.MCProcess import Memcached$/;"	i
Memcached	.\test\test_send_to_all_hosts.py	/^from mcrouter.test.MCProcess import Memcached$/;"	i
Memcached	.\test\test_service_info.py	/^from mcrouter.test.MCProcess import Memcached$/;"	i
Memcached	.\test\test_shadow.py	/^from mcrouter.test.MCProcess import Memcached$/;"	i
Memcached	.\test\test_shadow_with_file.py	/^from mcrouter.test.MCProcess import Memcached$/;"	i
Memcached	.\test\test_shard_splits.py	/^from mcrouter.test.MCProcess import Memcached$/;"	i
Memcached	.\test\test_umbrella_server.py	/^from mcrouter.test.MCProcess import Memcached$/;"	i
Memcached	.\test\test_warmup.py	/^from mcrouter.test.MCProcess import Memcached$/;"	i
MigrateRoute	.\lib\routes\MigrateRoute.h	/^  MigrateRoute(RouteHandleFactory<RouteHandleIf> factory,$/;"	f	class:facebook::memcache::MigrateRoute
MigrateRoute	.\lib\routes\MigrateRoute.h	/^  MigrateRoute(std::shared_ptr<RouteHandleIf> fh,$/;"	f	class:facebook::memcache::MigrateRoute
MigrateRoute	.\lib\routes\MigrateRoute.h	/^class MigrateRoute {$/;"	c	namespace:facebook::memcache
MissFailoverRoute	.\lib\routes\MissFailoverRoute.h	/^  MissFailoverRoute(RouteHandleFactory<RouteHandleIf>& factory,$/;"	f	class:facebook::memcache::MissFailoverRoute
MissFailoverRoute	.\lib\routes\MissFailoverRoute.h	/^  explicit MissFailoverRoute($/;"	f	class:facebook::memcache::MissFailoverRoute
MissFailoverRoute	.\lib\routes\MissFailoverRoute.h	/^class MissFailoverRoute {$/;"	c	namespace:facebook::memcache
MockAsyncSocket	.\lib\network\test\SessionTestHarness.cpp	/^  explicit MockAsyncSocket(SessionTestHarness& harness)$/;"	f	class:facebook::memcache::MockAsyncSocket
MockAsyncSocket	.\lib\network\test\SessionTestHarness.cpp	/^class MockAsyncSocket : public apache::thrift::async::TAsyncTransport {$/;"	c	namespace:facebook::memcache	file:
MockImportResolver	.\lib\config\test\config_preprocessor_test.cpp	/^class MockImportResolver : public ImportResolverIf {$/;"	c	file:
MockMc	.\lib\network\test\MockMc.h	/^class MockMc {$/;"	c	namespace:facebook::memcache
MockMcOnRequest	.\lib\network\test\MockMcServer.cpp	/^class MockMcOnRequest {$/;"	c	file:
MockPoolFactory	.\test\cpp_unit_tests\mc_route_handle_provider_test.cpp	/^class MockPoolFactory : public PoolFactoryIf {$/;"	c	file:
MockServer	.\test\mock_servers.py	/^class MockServer(threading.Thread):$/;"	c
MockServer	.\test\test_ascii_error.py	/^from mcrouter.test.mock_servers import MockServer$/;"	i
MockServer	.\test\test_max_shadow_requests.py	/^from mcrouter.test.mock_servers import MockServer$/;"	i
MockServer	.\test\test_slow_box_tko.py	/^from mcrouter.test.mock_servers import MockServer$/;"	i
MockServer	.\test\test_wch3.py	/^from mcrouter.test.mock_servers import MockServer$/;"	i
MultiOpParent	.\lib\network\MultiOpParent.cpp	/^MultiOpParent::MultiOpParent(McServerSession& session, uint64_t blockReqid)$/;"	f	class:facebook::memcache::MultiOpParent
MultiOpParent	.\lib\network\MultiOpParent.h	/^class MultiOpParent {$/;"	c	namespace:facebook::memcache
MutableMcMsgRef	.\lib\McMsgRef.h	/^typedef std::unique_ptr<mc_msg_t, McMsgRefPolicy::Deleter> MutableMcMsgRef;$/;"	t	namespace:facebook::memcache
NIL	.\lib\fbi\skiplist.c	33;"	d	file:
NORMAL	.\ProxyMcRequest.h	/^  NORMAL,$/;"	m	class:facebook::memcache::mcrouter::RequestClass
NOT_STARTED	.\lib\fibers\Fiber.h	/^    NOT_STARTED,                \/**< Has task function, not started *\/$/;"	e	enum:facebook::memcache::Fiber::State
NOT_STORED	.\lib\network\test\MockMc.h	/^    NOT_STORED,$/;"	e	enum:facebook::memcache::MockMc::LeaseSetResult
NO_SHADOW_POLICY	.\proxy.h	237;"	d
NO_WAITER	.\lib\fibers\Baton.h	/^  static constexpr intptr_t NO_WAITER = 0;$/;"	m	class:facebook::memcache::Baton
NPRIORITIES	.\priorities.cpp	/^static int NPRIORITIES = 4;$/;"	m	namespace:facebook::memcache::mcrouter	file:
NSTRING_CONST	.\lib\fbi\nstring.h	25;"	d
NSTRING_INIT	.\lib\fbi\nstring.h	22;"	d
NSTRING_LIT	.\lib\fbi\nstring.h	21;"	d
NUM_EVENT_PRIORITY_TYPES	.\priorities.h	/^  NUM_EVENT_PRIORITY_TYPES,$/;"	e	enum:facebook::memcache::mcrouter::event_priority_type_t
NUM_LOOKUPS	.\lib\fbi\test\hash_test.cpp	23;"	d	file:
NUM_POOLS	.\lib\fbi\test\hash_test.cpp	20;"	d	file:
NUM_POOL_TYPES	.\proxy.h	/^  NUM_POOL_TYPES$/;"	e	enum:facebook::memcache::mcrouter::proxy_pool_type_t
NUM_SAMPLES	.\lib\fbi\test\hash_test.cpp	19;"	d	file:
NUM_SERVERS	.\lib\fbi\test\hash_test.cpp	22;"	d	file:
NUM_SHADOW_POLICIES	.\proxy.h	/^  NUM_SHADOW_POLICIES \/\/ Must be the last entry$/;"	e	enum:facebook::memcache::mcrouter::shadow_policy_t
NUM_THREADS	.\lib\fbi\test\asox_queue_test.cpp	19;"	d	file:
NUM_THREADS	.\lib\fbi\test\asox_sem_test.cpp	20;"	d	file:
NUM_THREADS	.\lib\fbi\test\log_coalesce_test.cpp	71;"	d	file:
NUM_TIMER_OUTPUT_TYPES	.\lib\fbi\timer.h	/^  NUM_TIMER_OUTPUT_TYPES,$/;"	e	enum:__anon25
NUM_TIMER_STATES	.\lib\fbi\timer.h	/^  NUM_TIMER_STATES$/;"	e	enum:__anon24
NZLIB_MAGIC	.\lib\mc\msg.c	30;"	d	file:
NestedLimitGuard	.\lib\config\ConfigPreprocessor.cpp	/^  explicit NestedLimitGuard(size_t& nestedLimit)$/;"	f	class:facebook::memcache::__anon4::NestedLimitGuard
NestedLimitGuard	.\lib\config\ConfigPreprocessor.cpp	/^class NestedLimitGuard {$/;"	c	namespace:facebook::memcache::__anon4	file:
NoCopy	.\test\cpp_unit_tests\observable_test.cpp	/^  explicit NoCopy(int x_ = 0) : x(x_) {};$/;"	f	struct:NoCopy
NoCopy	.\test\cpp_unit_tests\observable_test.cpp	/^struct NoCopy {$/;"	s	file:
NoCopyNoMove	.\test\cpp_unit_tests\observable_test.cpp	/^struct NoCopyNoMove {$/;"	s	file:
NullRoute	.\lib\routes\NullRoute.h	/^struct NullRoute {$/;"	s	namespace:facebook::memcache
OK	.\lib\network\McSerializedRequest.h	/^    OK,$/;"	m	class:facebook::memcache::McSerializedRequest::Result
OPT	.\lib\mc\umbrella_protocol.c	128;"	d	file:
OPT	.\lib\mc\umbrella_protocol.c	131;"	d	file:
OPT	.\lib\mc\umbrella_protocol.c	133;"	d	file:
OPT	.\lib\mc\umbrella_protocol.c	136;"	d	file:
OPTIONS_FILE	.\options.h	84;"	d
OPTIONS_FILE	.\options.h	88;"	d
OPTIONS_FILE	.\standalone_options.h	31;"	d
OPTIONS_FILE	.\standalone_options.h	35;"	d
OPTIONS_NAME	.\options-template.h	/^class OPTIONS_NAME : public McrouterOptionsBase {$/;"	c
OPTIONS_NAME	.\options.h	85;"	d
OPTIONS_NAME	.\options.h	89;"	d
OPTIONS_NAME	.\standalone_options.h	32;"	d
OPTIONS_NAME	.\standalone_options.h	36;"	d
OUTSTANDING_REQ_BYTES	.\standalone_options.h	23;"	d
ObjectPool	.\lib\fbi\cpp\ObjectPool.h	/^  explicit ObjectPool(size_t maxCapacity = kInfinity)$/;"	f	class:facebook::memcache::ObjectPool
ObjectPool	.\lib\fbi\cpp\ObjectPool.h	/^class ObjectPool : boost::noncopyable {$/;"	c	namespace:facebook::memcache
Observable	.\Observable-inl.h	/^Observable<Data>::Observable(Data data)$/;"	f	class:facebook::memcache::mcrouter::Observable
Observable	.\Observable.h	/^class Observable {$/;"	c	namespace:facebook::memcache::mcrouter
ObservableRuntimeVars	.\_router.h	/^  ObservableRuntimeVars;$/;"	t	namespace:facebook::memcache::mcrouter
ObservableRuntimeVars	.\proxy.h	/^  ObservableRuntimeVars;$/;"	t	namespace:facebook::memcache::mcrouter
OnEventBaseDestructionCallback	.\lib\network\AsyncMcClientImpl.cpp	/^  explicit OnEventBaseDestructionCallback(AsyncMcClientImpl& client)$/;"	f	class:facebook::memcache::detail::OnEventBaseDestructionCallback
OnEventBaseDestructionCallback	.\lib\network\AsyncMcClientImpl.cpp	/^class OnEventBaseDestructionCallback : public folly::EventBase::LoopCallback {$/;"	c	namespace:facebook::memcache::detail	file:
OnRecordCallback	.\RecordingContext.h	/^  typedef std::function<void(const ProxyClientCommon&)> OnRecordCallback;$/;"	t	class:facebook::memcache::mcrouter::RecordingContext
OnRequest	.\lib\network\test\SessionTestHarness.h	/^    explicit OnRequest(SessionTestHarness& harness) :$/;"	f	class:facebook::memcache::SessionTestHarness::OnRequest
OnRequest	.\lib\network\test\SessionTestHarness.h	/^  class OnRequest {$/;"	c	class:facebook::memcache::SessionTestHarness
OnUpdateFunc	.\CallbackPool.h	/^  typedef std::function<void(Args...)> OnUpdateFunc;$/;"	t	class:facebook::memcache::mcrouter::CallbackPool
OnUpdateOldNew	.\Observable.h	/^  OnUpdateOldNew;$/;"	t	class:facebook::memcache::mcrouter::Observable
OperationSettings	.\routes\FailoverWithExptimeRouteIf.h	/^  struct OperationSettings {$/;"	s	struct:facebook::memcache::mcrouter::FailoverWithExptimeSettings
Options	.\PoolFactory.h	/^  struct Options {$/;"	s	class:facebook::memcache::mcrouter::PoolFactory
Options	.\lib\fibers\FiberManager.h	/^    constexpr Options() {}$/;"	f	struct:facebook::memcache::FiberManager::Options
Options	.\lib\fibers\FiberManager.h	/^  struct Options {$/;"	s	class:facebook::memcache::FiberManager
Options	.\lib\network\AsyncMcServer.h	/^  struct Options {$/;"	s	class:facebook::memcache::AsyncMcServer
OtherThan	.\lib\OperationTraits.h	/^struct OtherThan {$/;"	s	namespace:facebook::memcache
OtherThan	.\lib\OperationTraits.h	/^struct OtherThan<Operation, ArithmeticLike<>> {$/;"	s	namespace:facebook::memcache
OtherThan	.\lib\OperationTraits.h	/^struct OtherThan<Operation, DeleteLike<>> {$/;"	s	namespace:facebook::memcache
OtherThan	.\lib\OperationTraits.h	/^struct OtherThan<Operation, GetLike<>> {$/;"	s	namespace:facebook::memcache
OtherThan	.\lib\OperationTraits.h	/^struct OtherThan<Operation, OperationTraitOrType> {$/;"	s	namespace:facebook::memcache
OtherThan	.\lib\OperationTraits.h	/^struct OtherThan<Operation, UpdateLike<>> {$/;"	s	namespace:facebook::memcache
OtherThanT	.\lib\OperationTraits.h	145;"	d
OutputCheckerTestCase	.\test\test_bad_params.py	/^class OutputCheckerTestCase(unittest.TestCase):$/;"	c
PING_PONG_MODE	.\lib\fbi\test\asox_queue_test.cpp	22;"	d	file:
POOL_FAILOVER_ALWAYS	.\proxy.h	/^  POOL_FAILOVER_ALWAYS,$/;"	e	enum:facebook::memcache::mcrouter::proxy_pool_failover_type_t
POOL_FAILOVER_NEVER	.\proxy.h	/^  POOL_FAILOVER_NEVER,$/;"	e	enum:facebook::memcache::mcrouter::proxy_pool_failover_type_t
POOL_FAILOVER_NO_OVERRIDE	.\proxy.h	/^  POOL_FAILOVER_NO_OVERRIDE = 0,  \/\/ Must be 0 for memset to work!$/;"	e	enum:facebook::memcache::mcrouter::proxy_pool_failover_type_t
POOL_FAILOVER_NUM_TYPES	.\proxy.h	/^  POOL_FAILOVER_NUM_TYPES$/;"	e	enum:facebook::memcache::mcrouter::proxy_pool_failover_type_t
POOL_LOCALITY_CLUSTER	.\PoolFactory.cpp	/^const string POOL_LOCALITY_CLUSTER = "cluster";$/;"	m	namespace:facebook::memcache::mcrouter::__anon49	file:
POOL_LOCALITY_REGION	.\PoolFactory.cpp	/^const string POOL_LOCALITY_REGION = "region";$/;"	m	namespace:facebook::memcache::mcrouter::__anon49	file:
POSTED	.\lib\fibers\Baton.h	/^  static constexpr intptr_t POSTED = -1;$/;"	m	class:facebook::memcache::Baton
PRIORITIES	.\priorities.cpp	/^static int PRIORITIES[NUM_EVENT_PRIORITY_TYPES] =$/;"	m	namespace:facebook::memcache::mcrouter	file:
PROXY_CLIENT_NEW	.\ProxyDestination.h	/^  PROXY_CLIENT_NEW,           \/\/ never connected$/;"	e	enum:facebook::memcache::mcrouter::proxy_client_state_t
PROXY_CLIENT_NUM_STATES	.\ProxyDestination.h	/^  PROXY_CLIENT_NUM_STATES$/;"	e	enum:facebook::memcache::mcrouter::proxy_client_state_t
PROXY_CLIENT_TKO	.\ProxyDestination.h	/^  PROXY_CLIENT_TKO,           \/\/ waiting for retry timeout$/;"	e	enum:facebook::memcache::mcrouter::proxy_client_state_t
PROXY_CLIENT_UNKNOWN	.\ProxyDestination.h	/^  PROXY_CLIENT_UNKNOWN = 0,   \/\/ bug$/;"	e	enum:facebook::memcache::mcrouter::proxy_client_state_t
PROXY_CLIENT_UP	.\ProxyDestination.h	/^  PROXY_CLIENT_UP,            \/\/ currently connected$/;"	e	enum:facebook::memcache::mcrouter::proxy_client_state_t
PROXY_SEND_LOCAL_ERROR	.\route.h	/^  PROXY_SEND_LOCAL_ERROR,$/;"	e	enum:facebook::memcache::mcrouter::proxy_send_stat_result_t
PROXY_SEND_NUM_ERROR_TYPES	.\route.h	/^  PROXY_SEND_NUM_ERROR_TYPES$/;"	e	enum:facebook::memcache::mcrouter::proxy_send_stat_result_t
PROXY_SEND_OK	.\route.h	/^  PROXY_SEND_OK = 0,$/;"	e	enum:facebook::memcache::mcrouter::proxy_send_stat_result_t
PROXY_SEND_REMOTE_ERROR	.\route.h	/^  PROXY_SEND_REMOTE_ERROR,$/;"	e	enum:facebook::memcache::mcrouter::proxy_send_stat_result_t
ParserType	.\lib\network\McParser.h	/^  enum class ParserType {$/;"	c	class:facebook::memcache::McParser
PeriodicTaskScheduler	.\PeriodicTaskScheduler.cpp	/^PeriodicTaskScheduler::PeriodicTaskScheduler()$/;"	f	class:facebook::memcache::mcrouter::PeriodicTaskScheduler
PeriodicTaskScheduler	.\PeriodicTaskScheduler.h	/^class PeriodicTaskScheduler {$/;"	c	namespace:facebook::memcache::mcrouter
Pool	.\ConfigApi.h	/^  Pool = 2$/;"	m	class:facebook::memcache::mcrouter::ConfigType
PoolFactory	.\PoolFactory.cpp	/^PoolFactory::PoolFactory(const folly::dynamic& config,$/;"	f	class:facebook::memcache::mcrouter::PoolFactory
PoolFactory	.\PoolFactory.h	/^class PoolFactory : public PoolFactoryIf {$/;"	c	namespace:facebook::memcache::mcrouter
PoolFactoryIf	.\PoolFactoryIf.h	/^class PoolFactoryIf {$/;"	c	namespace:facebook::memcache::mcrouter
Popen	.\test\test_multiple_ports.py	/^from subprocess import Popen$/;"	i
Popen	.\test\test_validate_config.py	/^from subprocess import Popen$/;"	i
PreBlockAttempts	.\lib\fibers\Baton.h	/^    PreBlockAttempts = 300,$/;"	e	enum:facebook::memcache::Baton::__anon26
PrefixPolicyRoute	.\routes\PrefixPolicyRoute.h	/^   PrefixPolicyRoute(RouteHandleFactory<RouteHandleIf>& factory,$/;"	f	class:facebook::memcache::mcrouter::PrefixPolicyRoute
PrefixPolicyRoute	.\routes\PrefixPolicyRoute.h	/^  PrefixPolicyRoute($/;"	f	class:facebook::memcache::mcrouter::PrefixPolicyRoute
PrefixPolicyRoute	.\routes\PrefixPolicyRoute.h	/^class PrefixPolicyRoute {$/;"	c	namespace:facebook::memcache::mcrouter
PrefixRouteSelector	.\routes\PrefixRouteSelector.cpp	/^PrefixRouteSelector::PrefixRouteSelector($/;"	f	class:facebook::memcache::mcrouter::PrefixRouteSelector
PrefixRouteSelector	.\routes\PrefixRouteSelector.h	/^class PrefixRouteSelector {$/;"	c	namespace:facebook::memcache::mcrouter
ProxyClientCommon	.\ProxyClientCommon.cpp	/^ProxyClientCommon::ProxyClientCommon(unsigned index,$/;"	f	class:facebook::memcache::mcrouter::ProxyClientCommon
ProxyClientCommon	.\ProxyClientCommon.h	/^struct ProxyClientCommon {$/;"	s	namespace:facebook::memcache::mcrouter
ProxyClientOwner	.\pclient.h	/^struct ProxyClientOwner {$/;"	s	namespace:facebook::memcache::mcrouter
ProxyClientShared	.\pclient.cpp	/^ProxyClientShared::ProxyClientShared(const std::string& key_,$/;"	f	class:facebook::memcache::mcrouter::ProxyClientShared
ProxyClientShared	.\pclient.h	/^struct ProxyClientShared {$/;"	s	namespace:facebook::memcache::mcrouter
ProxyConfig	.\ProxyConfig.cpp	/^ProxyConfig::ProxyConfig(proxy_t* proxy,$/;"	f	class:facebook::memcache::mcrouter::ProxyConfig
ProxyConfig	.\ProxyConfig.h	/^class ProxyConfig : public ProxyConfigIf {$/;"	c	namespace:facebook::memcache::mcrouter
ProxyConfigBuilder	.\ProxyConfigBuilder.cpp	/^ProxyConfigBuilder::ProxyConfigBuilder(const McrouterOptions& opts,$/;"	f	class:facebook::memcache::mcrouter::ProxyConfigBuilder
ProxyConfigBuilder	.\ProxyConfigBuilder.h	/^class ProxyConfigBuilder {$/;"	c	namespace:facebook::memcache::mcrouter
ProxyConfigIf	.\ProxyConfigIf.h	/^class ProxyConfigIf {$/;"	c	namespace:facebook::memcache::mcrouter
ProxyDestination	.\ProxyDestination.cpp	/^ProxyDestination::ProxyDestination(proxy_t* proxy_,$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
ProxyDestination	.\ProxyDestination.h	/^struct ProxyDestination {$/;"	s	namespace:facebook::memcache::mcrouter
ProxyDestinationMap	.\ProxyDestinationMap.cpp	/^ProxyDestinationMap::ProxyDestinationMap(proxy_t* proxy)$/;"	f	class:facebook::memcache::mcrouter::ProxyDestinationMap
ProxyDestinationMap	.\ProxyDestinationMap.h	/^class ProxyDestinationMap {$/;"	c	namespace:facebook::memcache::mcrouter
ProxyDestinationStats	.\ProxyDestination.cpp	/^ProxyDestinationStats::ProxyDestinationStats(const McrouterOptions& opts)$/;"	f	class:facebook::memcache::mcrouter::ProxyDestinationStats
ProxyDestinationStats	.\ProxyDestination.h	/^struct ProxyDestinationStats {$/;"	s	namespace:facebook::memcache::mcrouter
ProxyGenericPool	.\proxy.h	/^  explicit ProxyGenericPool(std::string name)$/;"	f	class:facebook::memcache::mcrouter::ProxyGenericPool
ProxyGenericPool	.\proxy.h	/^class ProxyGenericPool {$/;"	c	namespace:facebook::memcache::mcrouter
ProxyMcReply	.\ProxyMcReply.cpp	/^ProxyMcReply::ProxyMcReply(McReplyBase reply)$/;"	f	class:facebook::memcache::mcrouter::ProxyMcReply
ProxyMcReply	.\ProxyMcReply.h	/^  explicit ProxyMcReply(Args&&... args)$/;"	f	class:facebook::memcache::mcrouter::ProxyMcReply
ProxyMcReply	.\ProxyMcReply.h	/^class ProxyMcReply : public McReplyBase {$/;"	c	namespace:facebook::memcache::mcrouter
ProxyMcRequest	.\ProxyMcRequest.h	/^  \/* implicit *\/ ProxyMcRequest($/;"	f	class:facebook::memcache::mcrouter::ProxyMcRequest
ProxyMcRequest	.\ProxyMcRequest.h	/^  explicit ProxyMcRequest(Args&&... args)$/;"	f	class:facebook::memcache::mcrouter::ProxyMcRequest
ProxyMcRequest	.\ProxyMcRequest.h	/^class ProxyMcRequest : public McRequestWithContext<GenericProxyRequestContext> {$/;"	c	namespace:facebook::memcache::mcrouter
ProxyMigratedPool	.\proxy.cpp	/^ProxyMigratedPool::ProxyMigratedPool(std::string name)$/;"	f	class:facebook::memcache::mcrouter::ProxyMigratedPool
ProxyMigratedPool	.\proxy.h	/^class ProxyMigratedPool : public ProxyGenericPool {$/;"	c	namespace:facebook::memcache::mcrouter
ProxyPool	.\proxy.cpp	/^ProxyPool::ProxyPool(std::string name)$/;"	f	class:facebook::memcache::mcrouter::ProxyPool
ProxyPool	.\proxy.h	/^class ProxyPool : public ProxyGenericPool {$/;"	c	namespace:facebook::memcache::mcrouter
ProxyRegionalPool	.\proxy.h	/^  explicit ProxyRegionalPool(std::string name)$/;"	f	class:facebook::memcache::mcrouter::ProxyRegionalPool
ProxyRegionalPool	.\proxy.h	/^class ProxyRegionalPool : public ProxyPool {$/;"	c	namespace:facebook::memcache::mcrouter
ProxyRegularPool	.\proxy.h	/^  explicit ProxyRegularPool(std::string name)$/;"	f	class:facebook::memcache::mcrouter::ProxyRegularPool
ProxyRegularPool	.\proxy.h	/^class ProxyRegularPool : public ProxyPool {$/;"	c	namespace:facebook::memcache::mcrouter
ProxyRequestContext	.\ProxyRequestContext.cpp	/^ProxyRequestContext::ProxyRequestContext($/;"	f	class:facebook::memcache::mcrouter::ProxyRequestContext
ProxyRequestContext	.\ProxyRequestContext.h	/^class ProxyRequestContext {$/;"	c	namespace:facebook::memcache::mcrouter
ProxyRequestLogger	.\ProxyRequestLogger.h	/^  explicit ProxyRequestLogger(proxy_t* proxy)$/;"	f	class:facebook::memcache::mcrouter::ProxyRequestLogger
ProxyRequestLogger	.\ProxyRequestLogger.h	/^class ProxyRequestLogger {$/;"	c	namespace:facebook::memcache::mcrouter
ProxyRoute	.\routes\ProxyRoute.h	/^  ProxyRoute(proxy_t* proxy, const RouteSelectorMap& routeSelectors)$/;"	f	class:facebook::memcache::mcrouter::ProxyRoute
ProxyRoute	.\routes\ProxyRoute.h	/^class ProxyRoute {$/;"	c	namespace:facebook::memcache::mcrouter
ProxyStatsContainer	.\mcrouter_config.h	/^  explicit ProxyStatsContainer(proxy_t*) {}$/;"	f	struct:facebook::memcache::mcrouter::ProxyStatsContainer
ProxyStatsContainer	.\mcrouter_config.h	/^struct ProxyStatsContainer {$/;"	s	namespace:facebook::memcache::mcrouter
ProxyThread	.\ProxyThread.cpp	/^ProxyThread::ProxyThread(std::unique_ptr<proxy_t> pr)$/;"	f	class:facebook::memcache::mcrouter::ProxyThread
ProxyThread	.\ProxyThread.h	/^class ProxyThread {$/;"	c	namespace:facebook::memcache::mcrouter
QMASKS	.\lib\mc\umbrella_protocol.c	63;"	d	file:
QMD_LIST_CHECK_HEAD	.\lib\fbi\queue.h	364;"	d
QMD_LIST_CHECK_HEAD	.\lib\fbi\queue.h	383;"	d
QMD_LIST_CHECK_NEXT	.\lib\fbi\queue.h	371;"	d
QMD_LIST_CHECK_NEXT	.\lib\fbi\queue.h	384;"	d
QMD_LIST_CHECK_PREV	.\lib\fbi\queue.h	378;"	d
QMD_LIST_CHECK_PREV	.\lib\fbi\queue.h	385;"	d
QMD_TAILQ_CHECK_HEAD	.\lib\fbi\queue.h	478;"	d
QMD_TAILQ_CHECK_HEAD	.\lib\fbi\queue.h	502;"	d
QMD_TAILQ_CHECK_NEXT	.\lib\fbi\queue.h	490;"	d
QMD_TAILQ_CHECK_NEXT	.\lib\fbi\queue.h	504;"	d
QMD_TAILQ_CHECK_PREV	.\lib\fbi\queue.h	497;"	d
QMD_TAILQ_CHECK_PREV	.\lib\fbi\queue.h	505;"	d
QMD_TAILQ_CHECK_TAIL	.\lib\fbi\queue.h	485;"	d
QMD_TAILQ_CHECK_TAIL	.\lib\fbi\queue.h	503;"	d
QMD_TRACE_ELEM	.\lib\fbi\queue.h	139;"	d
QMD_TRACE_ELEM	.\lib\fbi\queue.h	147;"	d
QMD_TRACE_HEAD	.\lib\fbi\queue.h	132;"	d
QMD_TRACE_HEAD	.\lib\fbi\queue.h	148;"	d
READY_TO_RUN	.\lib\fibers\Fiber.h	/^    READY_TO_RUN,               \/**< Was started, blocked, then unblocked *\/$/;"	e	enum:facebook::memcache::Fiber::State
REGIONAL_POOL	.\proxy.h	/^  REGIONAL_POOL,$/;"	e	enum:facebook::memcache::mcrouter::proxy_pool_type_t
REGULAR_POOL	.\proxy.h	/^  REGULAR_POOL = 0,$/;"	e	enum:facebook::memcache::mcrouter::proxy_pool_type_t
REPLY_STATE_NO_REPLY	.\proxy.h	/^  REPLY_STATE_NO_REPLY,$/;"	e	enum:facebook::memcache::mcrouter::reply_state_t
REPLY_STATE_REPLIED	.\proxy.h	/^  REPLY_STATE_REPLIED,$/;"	e	enum:facebook::memcache::mcrouter::reply_state_t
REPLY_STATE_REPLY_DELAYED	.\proxy.h	/^  REPLY_STATE_REPLY_DELAYED,$/;"	e	enum:facebook::memcache::mcrouter::reply_state_t
REQUEST_CLASS_ERROR_STATS	.\ProxyRequestLogger-inl.h	97;"	d
REQUEST_CLASS_STATS	.\ProxyRequestLogger-inl.h	19;"	d
RMASKS	.\lib\mc\umbrella_protocol.c	96;"	d	file:
RUNNING	.\lib\fibers\Fiber.h	/^    RUNNING,                    \/**< Is running right now *\/$/;"	e	enum:facebook::memcache::Fiber::State
RateLimitRoute	.\routes\RateLimitRoute.h	/^  RateLimitRoute(std::shared_ptr<RouteHandleIf> target,$/;"	f	class:facebook::memcache::mcrouter::RateLimitRoute
RateLimitRoute	.\routes\RateLimitRoute.h	/^class RateLimitRoute {$/;"	c	namespace:facebook::memcache::mcrouter
RateLimiter	.\routes\RateLimiter.cpp	/^RateLimiter::RateLimiter(const folly::dynamic& json) {$/;"	f	class:facebook::memcache::mcrouter::RateLimiter
RateLimiter	.\routes\RateLimiter.h	/^class RateLimiter {$/;"	c	namespace:facebook::memcache::mcrouter
RecordingContext	.\RecordingContext.cpp	/^RecordingContext::RecordingContext(OnRecordCallback callback)$/;"	f	class:facebook::memcache::mcrouter::RecordingContext
RecordingContext	.\RecordingContext.h	/^class RecordingContext {$/;"	c	namespace:facebook::memcache::mcrouter
RecordingMcRequest	.\RecordingContext.h	/^typedef McRequestWithContext<RecordingContext> RecordingMcRequest;$/;"	t	namespace:facebook::memcache::mcrouter
RecordingRoute	.\lib\test\RouteHandleTestUtil.h	/^  RecordingRoute(GetRouteTestData g_td,$/;"	f	struct:facebook::memcache::RecordingRoute
RecordingRoute	.\lib\test\RouteHandleTestUtil.h	/^struct RecordingRoute {$/;"	s	namespace:facebook::memcache
RecordingRouteHandle	.\lib\test\RouteHandleTestUtil.h	/^typedef TestRouteHandle<RecordingRoute<TestRouteHandleIf>> RecordingRouteHandle;$/;"	t	namespace:facebook::memcache
Ref	.\lib\McMsgRef.h	/^  Ref() : ref_(nullptr) {}$/;"	f	class:facebook::memcache::Ref
Ref	.\lib\McMsgRef.h	/^  \/* implicit *\/ Ref(std::unique_ptr<M, D>&& from) : ref_(from.release()) {$/;"	f	class:facebook::memcache::Ref
Ref	.\lib\McMsgRef.h	/^  explicit Ref(T* ref) : ref_(ref) {}$/;"	f	class:facebook::memcache::Ref
Ref	.\lib\McMsgRef.h	/^class Ref {$/;"	c	namespace:facebook::memcache
ReliablePoolRoute	.\routes\ReliablePoolRoute.h	/^  ReliablePoolRoute(std::vector<std::shared_ptr<RouteHandleIf>> destinations,$/;"	f	class:facebook::memcache::mcrouter::ReliablePoolRoute
ReliablePoolRoute	.\routes\ReliablePoolRoute.h	/^class ReliablePoolRoute {$/;"	c	namespace:facebook::memcache::mcrouter
RemoteTask	.\lib\fibers\FiberManager.h	/^    explicit RemoteTask(F&& f) : func(std::move(f)) {}$/;"	f	struct:facebook::memcache::FiberManager::RemoteTask
RemoteTask	.\lib\fibers\FiberManager.h	/^  struct RemoteTask {$/;"	s	class:facebook::memcache::FiberManager
ReplyType	.\ProxyMcRequest.h	/^struct ReplyType<Operation, mcrouter::ProxyMcRequest> {$/;"	s	namespace:facebook::memcache
ReplyType	.\RecordingContext.h	/^struct ReplyType<Operation, mcrouter::RecordingMcRequest> {$/;"	s	namespace:facebook::memcache
ReplyType	.\lib\McOperation.h	/^struct ReplyType<Operation, McRequest> {$/;"	s	namespace:facebook::memcache
ReplyType	.\lib\McOperation.h	/^struct ReplyType<Operation, McRequestWithContext<Ctx>> {$/;"	s	namespace:facebook::memcache
ReplyType	.\lib\test\TestRequest.h	/^struct ReplyType<Operation, TestRequest> {$/;"	s	namespace:facebook::memcache
ReqInfo	.\lib\network\AsyncMcClientImpl.h	/^    ReqInfo(const McRequest& request,$/;"	f	class:facebook::memcache::AsyncMcClientImpl::ReqInfo
ReqInfo	.\lib\network\AsyncMcClientImpl.h	/^  class ReqInfo {$/;"	c	class:facebook::memcache::AsyncMcClientImpl
RequestClass	.\ProxyMcRequest.h	/^enum class RequestClass {$/;"	c	namespace:facebook::memcache::mcrouter
Result	.\lib\fibers\FiberManager-inl.h	/^  typedef typename std::result_of<F()>::type Result;$/;"	t	struct:facebook::memcache::FiberManager::AddTaskFinallyHelper
Result	.\lib\network\McSerializedRequest.h	/^  enum class Result {$/;"	c	class:facebook::memcache::McSerializedRequest
ResultsSet	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^  ResultsSet() {$/;"	f	class:facebook::memcache::test::ResultsSet
ResultsSet	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^class ResultsSet {$/;"	c	namespace:facebook::memcache::test	file:
RootRoute	.\routes\RootRoute.h	/^  RootRoute(proxy_t* proxy, const RouteSelectorMap& routeSelectors)$/;"	f	class:facebook::memcache::mcrouter::RootRoute
RootRoute	.\routes\RootRoute.h	/^class RootRoute {$/;"	c	namespace:facebook::memcache::mcrouter
RouteHandle	.\lib\RouteHandleIf.h	/^  explicit RouteHandle(Args&&... args)$/;"	f	class:facebook::memcache::RouteHandle
RouteHandle	.\lib\RouteHandleIf.h	/^  explicit RouteHandle(const char* n, Args&&... args)$/;"	f	class:facebook::memcache::RouteHandle
RouteHandle	.\lib\RouteHandleIf.h	/^  explicit RouteHandle(std::string n, Args&&... args)$/;"	f	class:facebook::memcache::RouteHandle
RouteHandle	.\lib\RouteHandleIf.h	/^class RouteHandle<Route, RouteHandleIf, List<>, OpList, op_id> :$/;"	c	namespace:facebook::memcache
RouteHandle	.\lib\RouteHandleIf.h	/^class RouteHandle<Route,$/;"	c	namespace:facebook::memcache
RouteHandleFactory	.\lib\config\RouteHandleFactory-inl.h	/^RouteHandleFactory<RouteHandleIf>::RouteHandleFactory($/;"	f	class:facebook::memcache::RouteHandleFactory
RouteHandleFactory	.\lib\config\RouteHandleFactory.h	/^class RouteHandleFactory {$/;"	c	namespace:facebook::memcache
RouteHandleIf	.\lib\RouteHandleIf.h	/^class RouteHandleIf<RouteHandleIf_, List<Request>, OpList, 1> {$/;"	c	namespace:facebook::memcache
RouteHandleIf	.\lib\RouteHandleIf.h	/^class RouteHandleIf<RouteHandleIf_,$/;"	c	namespace:facebook::memcache
RouteHandleMap	.\routes\RouteHandleMap.cpp	/^RouteHandleMap::RouteHandleMap($/;"	f	class:facebook::memcache::mcrouter::RouteHandleMap
RouteHandleMap	.\routes\RouteHandleMap.h	/^class RouteHandleMap {$/;"	c	namespace:facebook::memcache::mcrouter
RouteHandleProvider	.\lib\config\RouteHandleProvider.h	/^class RouteHandleProvider : public RouteHandleProviderIf<RouteHandleIf> {$/;"	c	namespace:facebook::memcache
RouteHandleProviderIf	.\lib\config\RouteHandleProviderIf.h	/^class RouteHandleProviderIf {$/;"	c	namespace:facebook::memcache
RoutePolicyMap	.\routes\RoutePolicyMap.cpp	/^RoutePolicyMap::RoutePolicyMap($/;"	f	class:facebook::memcache::mcrouter::RoutePolicyMap
RoutePolicyMap	.\routes\RoutePolicyMap.h	/^class RoutePolicyMap {$/;"	c	namespace:facebook::memcache::mcrouter
RouteSelectorMap	.\routes\RouteSelectorMap.h	/^  RouteSelectorMap;$/;"	t	namespace:facebook::memcache::mcrouter
RouteSelectorVector	.\routes\RouteHandleMap.cpp	/^typedef std::vector<std::shared_ptr<PrefixRouteSelector>> RouteSelectorVector;$/;"	t	namespace:facebook::memcache::mcrouter::__anon58	file:
RouterLogger	.\mcrouter_config.h	/^struct RouterLogger {$/;"	s	namespace:facebook::memcache::mcrouter
RoutingPrefix	.\RoutingPrefix.cpp	/^RoutingPrefix::RoutingPrefix(const char* prefix)$/;"	f	class:facebook::memcache::mcrouter::RoutingPrefix
RoutingPrefix	.\RoutingPrefix.cpp	/^RoutingPrefix::RoutingPrefix(folly::StringPiece prefix)$/;"	f	class:facebook::memcache::mcrouter::RoutingPrefix
RoutingPrefix	.\RoutingPrefix.cpp	/^RoutingPrefix::RoutingPrefix(std::string prefix)$/;"	f	class:facebook::memcache::mcrouter::RoutingPrefix
RoutingPrefix	.\RoutingPrefix.h	/^class RoutingPrefix {$/;"	c	namespace:facebook::memcache::mcrouter
RuntimeVarsData	.\RuntimeVarsData.cpp	/^RuntimeVarsData::RuntimeVarsData(folly::StringPiece json) {$/;"	f	class:facebook::memcache::mcrouter::RuntimeVarsData
RuntimeVarsData	.\RuntimeVarsData.h	/^class RuntimeVarsData {$/;"	c	namespace:facebook::memcache::mcrouter
SCRATCH_BUFFER_LEN	.\lib\mc\ascii_response.h	19;"	d
SEED	.\lib\fbi\hash.c	39;"	d	file:
SERVER	.\lib\network\McParser.h	/^    SERVER,$/;"	m	class:facebook::memcache::McParser::ParserType
SERVER_ERROR_BUSY	.\lib\mc\msg.h	24;"	d
SERVER_REPLY	.\priorities.h	/^  SERVER_REPLY=0,$/;"	e	enum:facebook::memcache::mcrouter::event_priority_type_t
SERVER_REQUEST	.\priorities.h	/^  SERVER_REQUEST,$/;"	e	enum:facebook::memcache::mcrouter::event_priority_type_t
SFRLOCK_WRITE_LOCKED	.\lib\fbi\sfrlock.h	86;"	d
SFRLock	.\lib\fbi\cpp\sfrlock.h	/^  SFRLock() : readLock_(&lock_), writeLock_(&lock_) {$/;"	f	class:SFRLock
SFRLock	.\lib\fbi\cpp\sfrlock.h	/^class SFRLock {$/;"	c
SFRReadLock	.\lib\fbi\cpp\sfrlock.h	/^  explicit SFRReadLock(sfrlock_t* lck) : lock_(lck) {}$/;"	f	class:SFRReadLock
SFRReadLock	.\lib\fbi\cpp\sfrlock.h	/^class SFRReadLock {$/;"	c
SFRWriteLock	.\lib\fbi\cpp\sfrlock.h	/^  explicit SFRWriteLock(sfrlock_t* lck) : lock_(lck) {}$/;"	f	class:SFRWriteLock
SFRWriteLock	.\lib\fbi\cpp\sfrlock.h	/^class SFRWriteLock {$/;"	c
SHADOW	.\ProxyMcRequest.h	/^  SHADOW,$/;"	m	class:facebook::memcache::mcrouter::RequestClass
SHUTDOWN	.\lib\network\AsyncMcServer.h	/^    SHUTDOWN,$/;"	m	class:facebook::memcache::AsyncMcServer::SignalShutdownState
SKIPLIST_DUPLICATE_KEY	.\lib\fbi\skiplist.h	/^  SKIPLIST_DUPLICATE_KEY,$/;"	e	enum:__anon15
SKIPLIST_KEY_NOT_FOUND	.\lib\fbi\skiplist.h	/^  SKIPLIST_KEY_NOT_FOUND,$/;"	e	enum:__anon15
SKIPLIST_MEM_EXHAUSTED	.\lib\fbi\skiplist.h	/^  SKIPLIST_MEM_EXHAUSTED,$/;"	e	enum:__anon15
SKIPLIST_OK	.\lib\fbi\skiplist.h	/^  SKIPLIST_OK,$/;"	e	enum:__anon15
SKIPLIST_UNKNOWN_ERROR	.\lib\fbi\skiplist.h	/^  SKIPLIST_UNKNOWN_ERROR,$/;"	e	enum:__anon15
SLEEP	.\lib\fbi\test\log_coalesce_test.cpp	19;"	d	file:
SLIST_EMPTY	.\lib\fbi\queue.h	172;"	d
SLIST_ENTRY	.\lib\fbi\queue.h	164;"	d
SLIST_FIRST	.\lib\fbi\queue.h	174;"	d
SLIST_FOREACH	.\lib\fbi\queue.h	176;"	d
SLIST_FOREACH_PREVPTR	.\lib\fbi\queue.h	186;"	d
SLIST_FOREACH_SAFE	.\lib\fbi\queue.h	181;"	d
SLIST_HEAD	.\lib\fbi\queue.h	156;"	d
SLIST_HEAD_INITIALIZER	.\lib\fbi\queue.h	161;"	d
SLIST_INIT	.\lib\fbi\queue.h	191;"	d
SLIST_INSERT_AFTER	.\lib\fbi\queue.h	195;"	d
SLIST_INSERT_HEAD	.\lib\fbi\queue.h	200;"	d
SLIST_NEXT	.\lib\fbi\queue.h	205;"	d
SLIST_REMOVE	.\lib\fbi\queue.h	207;"	d
SLIST_REMOVE_AFTER	.\lib\fbi\queue.h	220;"	d
SLIST_REMOVE_HEAD	.\lib\fbi\queue.h	225;"	d
SPAWN_WAIT	.\main.cpp	66;"	d	file:
STAILQ_CONCAT	.\lib\fbi\queue.h	249;"	d
STAILQ_EMPTY	.\lib\fbi\queue.h	257;"	d
STAILQ_ENTRY	.\lib\fbi\queue.h	241;"	d
STAILQ_FIRST	.\lib\fbi\queue.h	259;"	d
STAILQ_FOREACH	.\lib\fbi\queue.h	261;"	d
STAILQ_FOREACH_SAFE	.\lib\fbi\queue.h	267;"	d
STAILQ_HEAD	.\lib\fbi\queue.h	232;"	d
STAILQ_HEAD_INITIALIZER	.\lib\fbi\queue.h	238;"	d
STAILQ_INIT	.\lib\fbi\queue.h	272;"	d
STAILQ_INSERT_AFTER	.\lib\fbi\queue.h	277;"	d
STAILQ_INSERT_HEAD	.\lib\fbi\queue.h	283;"	d
STAILQ_INSERT_TAIL	.\lib\fbi\queue.h	289;"	d
STAILQ_LAST	.\lib\fbi\queue.h	295;"	d
STAILQ_NEXT	.\lib\fbi\queue.h	301;"	d
STAILQ_REMOVE	.\lib\fbi\queue.h	303;"	d
STAILQ_REMOVE_AFTER	.\lib\fbi\queue.h	322;"	d
STAILQ_REMOVE_HEAD	.\lib\fbi\queue.h	316;"	d
STAILQ_SWAP	.\lib\fbi\queue.h	328;"	d
STALE_STORED	.\lib\network\test\MockMc.h	/^    STALE_STORED,$/;"	e	enum:facebook::memcache::MockMc::LeaseSetResult
STARTUP	.\lib\network\AsyncMcServer.h	/^    STARTUP,$/;"	m	class:facebook::memcache::AsyncMcServer::SignalShutdownState
STAT	.\stats.cpp	204;"	d	file:
STAT	.\stats.cpp	219;"	d	file:
STAT	.\stats.h	23;"	d
STAT	.\stats.h	32;"	d
STAT_UPDATE	.\route.cpp	96;"	d	file:
STORED	.\lib\network\test\MockMc.h	/^    STORED,$/;"	e	enum:facebook::memcache::MockMc::LeaseSetResult
STREAMING	.\lib\network\McServerSession.h	/^    STREAMING,$/;"	e	enum:facebook::memcache::McServerSession::State
STSI	.\stats.cpp	215;"	d	file:
STSI	.\stats.cpp	222;"	d	file:
STSI	.\stats.h	26;"	d
STSI	.\stats.h	35;"	d
STSS	.\stats.cpp	216;"	d	file:
STSS	.\stats.cpp	223;"	d	file:
STSS	.\stats.h	27;"	d
STSS	.\stats.h	36;"	d
STUI	.\stats.cpp	213;"	d	file:
STUI	.\stats.cpp	220;"	d	file:
STUI	.\stats.h	24;"	d
STUI	.\stats.h	33;"	d
STUIR	.\stats.cpp	214;"	d	file:
STUIR	.\stats.cpp	221;"	d	file:
STUIR	.\stats.h	25;"	d
STUIR	.\stats.h	34;"	d
SZ_FORMAT_STR	.\lib\fbi\debug.c	29;"	d	file:
SendWritesCallback	.\lib\network\McServerSession.h	/^    explicit SendWritesCallback(McServerSession& session) : session_(session) {}$/;"	f	struct:facebook::memcache::McServerSession::SendWritesCallback
SendWritesCallback	.\lib\network\McServerSession.h	/^  struct SendWritesCallback : public folly::EventBase::LoopCallback {$/;"	s	class:facebook::memcache::McServerSession
ServerOnRequest	.\lib\network\test\AsyncMcClientTest.cpp	/^  ServerOnRequest(bool& shutdown,$/;"	f	class:__anon42::ServerOnRequest
ServerOnRequest	.\lib\network\test\AsyncMcClientTest.cpp	/^class ServerOnRequest {$/;"	c	namespace:__anon42	file:
ServerOnRequest	.\server.cpp	/^  explicit ServerOnRequest(mcrouter_client_t* client)$/;"	f	class:facebook::memcache::mcrouter::__anon60::ServerOnRequest
ServerOnRequest	.\server.cpp	/^class ServerOnRequest {$/;"	c	namespace:facebook::memcache::mcrouter::__anon60	file:
ServerParseCallback	.\lib\network\McParser.h	/^  class ServerParseCallback {$/;"	c	class:facebook::memcache::McParser
ServerStat	.\stats.cpp	/^struct ServerStat {$/;"	s	namespace:facebook::memcache::mcrouter::__anon62	file:
ServiceInfo	.\ServiceInfo.cpp	/^ServiceInfo::ServiceInfo(proxy_t* proxy, const ProxyConfigIf& config)$/;"	f	class:facebook::memcache::mcrouter::ServiceInfo
ServiceInfo	.\ServiceInfo.h	/^class ServiceInfo {$/;"	c	namespace:facebook::memcache::mcrouter
ServiceInfoImpl	.\ServiceInfo.cpp	/^ServiceInfo::ServiceInfoImpl::ServiceInfoImpl(proxy_t* proxy,$/;"	f	class:facebook::memcache::mcrouter::ServiceInfo::ServiceInfoImpl
ServiceInfoImpl	.\ServiceInfo.cpp	/^struct ServiceInfo::ServiceInfoImpl {$/;"	s	class:facebook::memcache::mcrouter::ServiceInfo	file:
SessionTestHarness	.\lib\network\test\SessionTestHarness.cpp	/^SessionTestHarness::SessionTestHarness($/;"	f	class:facebook::memcache::SessionTestHarness
SessionTestHarness	.\lib\network\test\SessionTestHarness.h	/^class SessionTestHarness {$/;"	c	namespace:facebook::memcache
ShadowRoute	.\routes\ShadowRoute.h	/^  ShadowRoute(std::shared_ptr<RouteHandleIf> normalRoute,$/;"	f	class:facebook::memcache::mcrouter::ShadowRoute
ShadowRoute	.\routes\ShadowRoute.h	/^class ShadowRoute {$/;"	c	namespace:facebook::memcache::mcrouter
ShardSplitRoute	.\routes\ShardSplitRoute.h	/^  ShardSplitRoute(std::shared_ptr<RouteHandleIf> rh,$/;"	f	class:facebook::memcache::mcrouter::ShardSplitRoute
ShardSplitRoute	.\routes\ShardSplitRoute.h	/^class ShardSplitRoute {$/;"	c	namespace:facebook::memcache::mcrouter
ShardSplitter	.\routes\ShardSplitter.cpp	/^ShardSplitter::ShardSplitter(const folly::dynamic& json) {$/;"	f	class:facebook::memcache::mcrouter::ShardSplitter
ShardSplitter	.\routes\ShardSplitter.h	/^class ShardSplitter {$/;"	c	namespace:facebook::memcache::mcrouter
ShutdownLock	.\lib\fbi\cpp\ShutdownLock.h	/^  ShutdownLock()$/;"	f	class:facebook::memcache::ShutdownLock
ShutdownLock	.\lib\fbi\cpp\ShutdownLock.h	/^class ShutdownLock {$/;"	c	namespace:facebook::memcache
ShutdownPipe	.\lib\network\AsyncMcServer.cpp	/^  ShutdownPipe(AsyncMcServer& server,$/;"	f	class:facebook::memcache::ShutdownPipe
ShutdownPipe	.\lib\network\AsyncMcServer.cpp	/^class ShutdownPipe : public folly::EventHandler {$/;"	c	namespace:facebook::memcache	file:
SignalShutdownState	.\lib\network\AsyncMcServer.h	/^  enum class SignalShutdownState : uint64_t {$/;"	c	class:facebook::memcache::AsyncMcServer
SimpleHandshakeCallback	.\lib\network\AsyncMcServerWorker.cpp	/^class SimpleHandshakeCallback : public TAsyncSSLSocket::HandshakeCallback {$/;"	c	namespace:facebook::memcache::__anon39	file:
SimpleLoopController	.\lib\fibers\SimpleLoopController.h	/^  SimpleLoopController()$/;"	f	class:facebook::memcache::SimpleLoopController
SimpleLoopController	.\lib\fibers\SimpleLoopController.h	/^class SimpleLoopController : public LoopController {$/;"	c	namespace:facebook::memcache
SleepServer	.\test\mock_servers.py	/^class SleepServer(MockServer):$/;"	c
SleepServer	.\test\test_probe_timeout.py	/^from mcrouter.test.mock_servers import SleepServer$/;"	i
SleepServer	.\test\test_server_stats.py	/^from mcrouter.test.mock_servers import SleepServer$/;"	i
SocketOptions	.\lib\network\ConnectionOptions.h	/^  typedef apache::thrift::async::TAsyncSocket::OptionMap SocketOptions;$/;"	t	struct:facebook::memcache::ConnectionOptions
StartupLock	.\lib\fbi\cpp\StartupLock.h	/^  explicit StartupLock(size_t count)$/;"	f	class:facebook::memcache::StartupLock
StartupLock	.\lib\fbi\cpp\StartupLock.h	/^class StartupLock {$/;"	c	namespace:facebook::memcache
State	.\lib\fibers\Fiber.h	/^  enum State {$/;"	g	class:facebook::memcache::Fiber
State	.\lib\network\McServerSession.h	/^  enum State {$/;"	g	class:facebook::memcache::McServerSession
StateList	.\ProxyDestinationMap.cpp	/^struct ProxyDestinationMap::StateList {$/;"	s	class:facebook::memcache::mcrouter::ProxyDestinationMap	file:
StaticContainer	.\lib\fbi\cpp\LogFailure.cpp	/^struct StaticContainer {$/;"	s	namespace:facebook::memcache::failure::__anon9	file:
StatsReply	.\lib\StatsReply.h	/^class StatsReply {$/;"	c	namespace:facebook::memcache
StoreServer	.\test\mock_servers.py	/^class StoreServer(MockServer):$/;"	c
StoreServer	.\test\test_largeobj.py	/^from mcrouter.test.mock_servers import StoreServer$/;"	i
StringKeyedUnorderedMap	.\mcrouter_config.h	/^  StringKeyedUnorderedMap(const StringKeyedUnorderedMap& other)$/;"	f	class:facebook::memcache::mcrouter::StringKeyedUnorderedMap
StringKeyedUnorderedMap	.\mcrouter_config.h	/^  explicit StringKeyedUnorderedMap(size_type n = 0)$/;"	f	class:facebook::memcache::mcrouter::StringKeyedUnorderedMap
StringKeyedUnorderedMap	.\mcrouter_config.h	/^class StringKeyedUnorderedMap : public std::unordered_map<std::string, Value> {$/;"	c	namespace:facebook::memcache::mcrouter
TAILQ_CONCAT	.\lib\fbi\queue.h	508;"	d
TAILQ_EMPTY	.\lib\fbi\queue.h	519;"	d
TAILQ_ENTRY	.\lib\fbi\queue.h	467;"	d
TAILQ_FIRST	.\lib\fbi\queue.h	521;"	d
TAILQ_FOREACH	.\lib\fbi\queue.h	523;"	d
TAILQ_FOREACH_REVERSE	.\lib\fbi\queue.h	533;"	d
TAILQ_FOREACH_REVERSE_SAFE	.\lib\fbi\queue.h	538;"	d
TAILQ_FOREACH_SAFE	.\lib\fbi\queue.h	528;"	d
TAILQ_HEAD	.\lib\fbi\queue.h	457;"	d
TAILQ_HEAD_INITIALIZER	.\lib\fbi\queue.h	464;"	d
TAILQ_INIT	.\lib\fbi\queue.h	543;"	d
TAILQ_INSERT_AFTER	.\lib\fbi\queue.h	549;"	d
TAILQ_INSERT_BEFORE	.\lib\fbi\queue.h	564;"	d
TAILQ_INSERT_HEAD	.\lib\fbi\queue.h	574;"	d
TAILQ_INSERT_TAIL	.\lib\fbi\queue.h	587;"	d
TAILQ_LAST	.\lib\fbi\queue.h	597;"	d
TAILQ_NEXT	.\lib\fbi\queue.h	600;"	d
TAILQ_PREV	.\lib\fbi\queue.h	602;"	d
TAILQ_REMOVE	.\lib\fbi\queue.h	605;"	d
TAILQ_SWAP	.\lib\fbi\queue.h	621;"	d
TAO_SHADOW_POLICY	.\proxy.h	/^  TAO_SHADOW_POLICY,$/;"	e	enum:facebook::memcache::mcrouter::shadow_policy_t
TEST	.\lib\config\test\config_preprocessor_test.cpp	/^TEST(ConfigPreprocessorTest, comments) {$/;"	f
TEST	.\lib\config\test\config_preprocessor_test.cpp	/^TEST(ConfigPreprocessorTest, errors) {$/;"	f
TEST	.\lib\config\test\config_preprocessor_test.cpp	/^TEST(ConfigPreprocessorTest, macros) {$/;"	f
TEST	.\lib\config\test\routehandlefactory_test.cpp	/^TEST(RouteHandleFactoryTest, sanity) {$/;"	f
TEST	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^TEST(ObjectPool, Basic) {$/;"	f
TEST	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^TEST(ObjectPool, ThrowingType) {$/;"	f
TEST	.\lib\fbi\cpp\test\TrieTests.cpp	/^TEST(Trie, Const) {$/;"	f
TEST	.\lib\fbi\cpp\test\TrieTests.cpp	/^TEST(Trie, ConstructorTest) {$/;"	f
TEST	.\lib\fbi\cpp\test\TrieTests.cpp	/^TEST(Trie, IteratorTest) {$/;"	f
TEST	.\lib\fbi\cpp\test\TrieTests.cpp	/^TEST(Trie, PrefixTest) {$/;"	f
TEST	.\lib\fbi\cpp\test\TrieTests.cpp	/^TEST(Trie, PrefixTest2) {$/;"	f
TEST	.\lib\fbi\cpp\test\TrieTests.cpp	/^TEST(Trie, RandTestGet) {$/;"	f
TEST	.\lib\fbi\cpp\test\TrieTests.cpp	/^TEST(Trie, RandTestGetPrefix) {$/;"	f
TEST	.\lib\fbi\cpp\test\TrieTests.cpp	/^TEST(Trie, RandTestIter) {$/;"	f
TEST	.\lib\fbi\cpp\test\TrieTests.cpp	/^TEST(Trie, SanityTest) {$/;"	f
TEST	.\lib\fbi\test\asox_queue_test.cpp	/^TEST(libasox_queuetest, atonce) {$/;"	f
TEST	.\lib\fbi\test\asox_queue_test.cpp	/^TEST(libasox_queuetest, concurrent_enqueuing) {$/;"	f
TEST	.\lib\fbi\test\asox_queue_test.cpp	/^TEST(libasox_queuetest, disconnect) {$/;"	f
TEST	.\lib\fbi\test\asox_queue_test.cpp	/^TEST(libasox_queuetest, disconnect_from_callback) {$/;"	f
TEST	.\lib\fbi\test\asox_queue_test.cpp	/^TEST(libasox_queuetest, flood) {$/;"	f
TEST	.\lib\fbi\test\asox_queue_test.cpp	/^TEST(libasox_queuetest, multicount) {$/;"	f
TEST	.\lib\fbi\test\asox_queue_test.cpp	/^TEST(libasox_queuetest, pingpong) {$/;"	f
TEST	.\lib\fbi\test\asox_queue_test.cpp	/^TEST(libasox_queuetest, queuelimit) {$/;"	f
TEST	.\lib\fbi\test\asox_queue_test.cpp	/^TEST(libasox_queuetest, remote_disconnect) {$/;"	f
TEST	.\lib\fbi\test\asox_queue_test.cpp	/^TEST(libasox_queuetest, sweep) {$/;"	f
TEST	.\lib\fbi\test\asox_sem_test.cpp	/^TEST(libasox_semtest, compat_multi_1) {$/;"	f
TEST	.\lib\fbi\test\asox_sem_test.cpp	/^TEST(libasox_semtest, compat_multi_10) {$/;"	f
TEST	.\lib\fbi\test\asox_sem_test.cpp	/^TEST(libasox_semtest, compat_overflow) {$/;"	f
TEST	.\lib\fbi\test\asox_sem_test.cpp	/^TEST(libasox_semtest, compat_single_1) {$/;"	f
TEST	.\lib\fbi\test\asox_sem_test.cpp	/^TEST(libasox_semtest, compat_single_10) {$/;"	f
TEST	.\lib\fbi\test\asox_sem_test.cpp	/^TEST(libasox_semtest, early_termination_multi_mode) {$/;"	f
TEST	.\lib\fbi\test\asox_sem_test.cpp	/^TEST(libasox_semtest, early_termination_single_mode) {$/;"	f
TEST	.\lib\fbi\test\asox_sem_test.cpp	/^TEST(libasox_semtest, multi_1) {$/;"	f
TEST	.\lib\fbi\test\asox_sem_test.cpp	/^TEST(libasox_semtest, multi_10) {$/;"	f
TEST	.\lib\fbi\test\asox_sem_test.cpp	/^TEST(libasox_semtest, single_1) {$/;"	f
TEST	.\lib\fbi\test\asox_sem_test.cpp	/^TEST(libasox_semtest, single_10) {$/;"	f
TEST	.\lib\fbi\test\counter_test.cpp	/^TEST(counter, add_inflated) {$/;"	f
TEST	.\lib\fbi\test\counter_test.cpp	/^TEST(counter, add_nonlocked_inflated) {$/;"	f
TEST	.\lib\fbi\test\counter_test.cpp	/^TEST(counter, add_nonlocked_uninflated) {$/;"	f
TEST	.\lib\fbi\test\counter_test.cpp	/^TEST(counter, add_uninflated) {$/;"	f
TEST	.\lib\fbi\test\counter_test.cpp	/^TEST(counter, multithreaded_test) {$/;"	f
TEST	.\lib\fbi\test\cwlock_test.cpp	/^TEST(cwlock, contended_release_only_once_done) {$/;"	f
TEST	.\lib\fbi\test\cwlock_test.cpp	/^TEST(cwlock, contended_single_acquirer) {$/;"	f
TEST	.\lib\fbi\test\cwlock_test.cpp	/^TEST(cwlock, uncontended_acquire) {$/;"	f
TEST	.\lib\fbi\test\hash_test.cpp	/^TEST(ch3, timing) {$/;"	f
TEST	.\lib\fbi\test\hash_test.cpp	/^TEST(ch3, verify_correctness) {$/;"	f
TEST	.\lib\fbi\test\log_coalesce_test.cpp	/^TEST(log_coalesce, basic) {$/;"	f
TEST	.\lib\fbi\test\log_tid_tests.cpp	/^TEST(log_tid, LogLimit) {$/;"	f
TEST	.\lib\fbi\test\log_tid_tests.cpp	/^TEST(log_tid, MultiThreadedTest) {$/;"	f
TEST	.\lib\fbi\test\log_tid_tests.cpp	/^TEST(log_tid, SingleThreadTest) {$/;"	f
TEST	.\lib\fbi\test\sem_test.cpp	/^TEST(counting_semaphore, basic) {$/;"	f
TEST	.\lib\fbi\test\sem_test.cpp	/^TEST(counting_semaphore, nonblocking) {$/;"	f
TEST	.\lib\fbi\test\sfrlock_test.cpp	/^TEST(sfrlock, concurrent_read_cost) {$/;"	f
TEST	.\lib\fbi\test\sfrlock_test.cpp	/^TEST(sfrlock, concurrent_reads_sanity) {$/;"	f
TEST	.\lib\fbi\test\sfrlock_test.cpp	/^TEST(sfrlock, concurrent_reads_sanity_cpp) {$/;"	f
TEST	.\lib\fbi\test\sfrlock_test.cpp	/^TEST(sfrlock, contended_reads_write_sanity) {$/;"	f
TEST	.\lib\fbi\test\sfrlock_test.cpp	/^TEST(sfrlock, contended_reads_write_sanity_cpp) {$/;"	f
TEST	.\lib\fbi\test\sfrlock_test.cpp	/^TEST(sfrlock, contended_reads_writes_sanity) {$/;"	f
TEST	.\lib\fbi\test\sfrlock_test.cpp	/^TEST(sfrlock, contended_reads_writes_sanity_cpp) {$/;"	f
TEST	.\lib\fbi\test\sfrlock_test.cpp	/^TEST(sfrlock, contended_write_cost) {$/;"	f
TEST	.\lib\fbi\test\sfrlock_test.cpp	/^TEST(sfrlock, contended_writes_sanity) {$/;"	f
TEST	.\lib\fbi\test\sfrlock_test.cpp	/^TEST(sfrlock, contended_writes_sanity_cpp) {$/;"	f
TEST	.\lib\fbi\test\sfrlock_test.cpp	/^TEST(sfrlock, trivial_acquisition) {$/;"	f
TEST	.\lib\fbi\test\sfrlock_test.cpp	/^TEST(sfrlock, uncontended_read_cost) {$/;"	f
TEST	.\lib\fbi\test\sfrlock_test.cpp	/^TEST(sfrlock, uncontended_write_cost) {$/;"	f
TEST	.\lib\fbi\test\timer_tests.cpp	/^TEST(timer, no_data) {$/;"	f
TEST	.\lib\fbi\test\timer_tests.cpp	/^TEST(timer, one_stat) {$/;"	f
TEST	.\lib\fbi\test\timer_tests.cpp	/^TEST(timer, partial_window) {$/;"	f
TEST	.\lib\fbi\test\timer_tests.cpp	/^TEST(timer, random_usleep) {$/;"	f
TEST	.\lib\fbi\test\timer_tests.cpp	/^TEST(timer, recent_and_avg_peaks_and_mins) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, addTaskFinally) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, addTaskRemoteBasic) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, addTasksNoncopyable) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, addTasksThrow) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, addTasksVoid) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, addTasksVoidThrow) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, batonTimedWaitPost) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, batonTimedWaitPostEvb) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, batonTimedWaitTimeout) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, batonTimedWaitTimeoutEvb) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, batonTryWait) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, fibersPoolOverLimit) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, fibersPoolWithinLimit) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, forEach) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, genericBatonFiberWait) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, genericBatonThreadWait) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, remoteFiberBasic) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, remoteHasReadyTasks) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, remoteHasTasks) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, runInMainContext) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, whenAll) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, whenAllVoid) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, whenAny) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, whenN) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, whenNThrow) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, whenNVoid) {$/;"	f
TEST	.\lib\fibers\test\FibersTest.cpp	/^TEST(FiberManager, whenNVoidThrow) {$/;"	f
TEST	.\lib\mc\test\UmbrellaTest.cpp	/^TEST(umbrella, iovecSerialize) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, badKey) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, connectionError) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, connectionErrorSsl) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, eventBaseDestruction) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, eventBaseDestructionWhileConnecting) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, immeadiateConnectFail) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, immeadiateConnectFailSsl) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, inflightThrottle) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, inflightThrottleFlush) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, inflightThrottleFlushSsl) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, inflightThrottleSsl) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, invalidCerts) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, noServerTimeout) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, noServerTimeoutSsl) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, outstandingThrottle) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, outstandingThrottleSsl) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, reconnectAscii) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, reconnectUmbrella) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, serverShutdown) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, serverShutdownSsl) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, simpleAsciiTimeout) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, simpleAsciiTimeoutSsl) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, simpleUmbrellaTimeout) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, simpleUmbrellaTimeoutSsl) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, umbrella) {$/;"	f
TEST	.\lib\network\test\AsyncMcClientTest.cpp	/^TEST(AsyncMcClient, umbrellaSsl) {$/;"	f
TEST	.\lib\network\test\SessionTest.cpp	/^TEST(Session, basic) {$/;"	f
TEST	.\lib\network\test\SessionTest.cpp	/^TEST(Session, closeBeforeReply) {$/;"	f
TEST	.\lib\network\test\SessionTest.cpp	/^TEST(Session, quit) {$/;"	f
TEST	.\lib\network\test\SessionTest.cpp	/^TEST(Session, throttle) {$/;"	f
TEST	.\lib\network\test\SessionTest.cpp	/^TEST(Session, throttleBigPacket) {$/;"	f
TEST	.\lib\test\Ch3HashTest.cpp	/^TEST(Ch3Func, basic) {$/;"	f
TEST	.\lib\test\Ch3HashTest.cpp	/^TEST(Ch3Func, ch3_3) {$/;"	f
TEST	.\lib\test\Ch3HashTest.cpp	/^TEST(Ch3HashFunc, ch3_10) {$/;"	f
TEST	.\lib\test\Crc32HashTest.cpp	/^TEST(Crc32Func, basic) {$/;"	f
TEST	.\lib\test\FailoverRouteTest.cpp	/^TEST(failoverRouteTest, fail) {$/;"	f
TEST	.\lib\test\FailoverRouteTest.cpp	/^TEST(failoverRouteTest, once) {$/;"	f
TEST	.\lib\test\FailoverRouteTest.cpp	/^TEST(failoverRouteTest, success) {$/;"	f
TEST	.\lib\test\FailoverRouteTest.cpp	/^TEST(failoverRouteTest, twice) {$/;"	f
TEST	.\lib\test\LatestRouteTest.cpp	/^TEST(latestRouteTest, one) {$/;"	f
TEST	.\lib\test\MigrateRouteTest.cpp	/^TEST(migrateRouteTest, migrate) {$/;"	f
TEST	.\lib\test\MissFailoverRouteTest.cpp	/^TEST(missMissFailoverRouteTest, fail) {$/;"	f
TEST	.\lib\test\MissFailoverRouteTest.cpp	/^TEST(missMissFailoverRouteTest, nonGetLike) {$/;"	f
TEST	.\lib\test\MissFailoverRouteTest.cpp	/^TEST(missMissFailoverRouteTest, once) {$/;"	f
TEST	.\lib\test\MissFailoverRouteTest.cpp	/^TEST(missMissFailoverRouteTest, success) {$/;"	f
TEST	.\lib\test\MissFailoverRouteTest.cpp	/^TEST(missMissFailoverRouteTest, twice) {$/;"	f
TEST	.\lib\test\RequestReplyTest.cpp	/^TEST(requestReply, RequestMoveNoExcept) {$/;"	f
TEST	.\lib\test\RequestReplyTest.cpp	/^TEST(requestReply, dependentRef) {$/;"	f
TEST	.\lib\test\RequestReplyTest.cpp	/^TEST(requestReply, mutableReply) {$/;"	f
TEST	.\lib\test\RequestReplyTest.cpp	/^TEST(requestReply, mutableRequest) {$/;"	f
TEST	.\lib\test\RequestReplyTest.cpp	/^TEST(requestReply, ref) {$/;"	f
TEST	.\lib\test\RequestReplyTest.cpp	/^TEST(requestReply, replyBasic) {$/;"	f
TEST	.\lib\test\RequestReplyTest.cpp	/^TEST(requestReply, replyMcMsg) {$/;"	f
TEST	.\lib\test\RequestReplyTest.cpp	/^TEST(requestReply, replyReduce) {$/;"	f
TEST	.\lib\test\RequestReplyTest.cpp	/^TEST(requestReply, requestGroupContext) {$/;"	f
TEST	.\lib\test\RequestReplyTest.cpp	/^TEST(requestReply, requestWithRoute) {$/;"	f
TEST	.\lib\test\RequestReplyTest.cpp	/^TEST(requestReply, requestWithoutRoute) {$/;"	f
TEST	.\lib\test\RouteHandleTest.cpp	/^TEST(routeHandleTest, allAsync) {$/;"	f
TEST	.\lib\test\RouteHandleTest.cpp	/^TEST(routeHandleTest, allFastest) {$/;"	f
TEST	.\lib\test\RouteHandleTest.cpp	/^TEST(routeHandleTest, allInitial) {$/;"	f
TEST	.\lib\test\RouteHandleTest.cpp	/^TEST(routeHandleTest, allMajority) {$/;"	f
TEST	.\lib\test\RouteHandleTest.cpp	/^TEST(routeHandleTest, allMajorityEmpty) {$/;"	f
TEST	.\lib\test\RouteHandleTest.cpp	/^TEST(routeHandleTest, allMajorityTie) {$/;"	f
TEST	.\lib\test\RouteHandleTest.cpp	/^TEST(routeHandleTest, allSync) {$/;"	f
TEST	.\lib\test\RouteHandleTest.cpp	/^TEST(routeHandleTest, error) {$/;"	f
TEST	.\lib\test\RouteHandleTest.cpp	/^TEST(routeHandleTest, hashNoSalt) {$/;"	f
TEST	.\lib\test\RouteHandleTest.cpp	/^TEST(routeHandleTest, hashSalt) {$/;"	f
TEST	.\lib\test\RouteHandleTest.cpp	/^TEST(routeHandleTest, nullDelete) {$/;"	f
TEST	.\lib\test\RouteHandleTest.cpp	/^TEST(routeHandleTest, nullGet) {$/;"	f
TEST	.\lib\test\RouteHandleTest.cpp	/^TEST(routeHandleTest, nullIncr) {$/;"	f
TEST	.\lib\test\RouteHandleTest.cpp	/^TEST(routeHandleTest, nullSet) {$/;"	f
TEST	.\lib\test\WarmUpRouteTest.cpp	/^TEST(warmUpRouteTest, warmUp) {$/;"	f
TEST	.\lib\test\WeightedCh3HashFuncTest.cpp	/^TEST(WeightedCh3HashFunc, basic) {$/;"	f
TEST	.\lib\test\WeightedCh3HashFuncTest.cpp	/^TEST(WeightedCh3HashFunc, randomWeights) {$/;"	f
TEST	.\lib\test\WeightedCh3HashFuncTest.cpp	/^TEST(WeightedCh3HashFunc, reducedWeight) {$/;"	f
TEST	.\lib\test\WeightedCh3HashFuncTest.cpp	/^TEST(WeightedCh3HashFunc, zeroWeight) {$/;"	f
TEST	.\routes\test\BigValueRouteTest.cpp	/^TEST(BigValueRouteTest, bigvalue) {$/;"	f
TEST	.\routes\test\BigValueRouteTest.cpp	/^TEST(BigValueRouteTest, smallvalue) {$/;"	f
TEST	.\routes\test\ConstShardHashFuncTest.cpp	/^TEST(constShardHashFuncTest, ch3Fallback) {$/;"	f
TEST	.\routes\test\ConstShardHashFuncTest.cpp	/^TEST(constShardHashFuncTest, picksRightShard) {$/;"	f
TEST	.\routes\test\FailoverWithExptimeRouteTest.cpp	/^TEST(failoverWithExptimeRouteTest, fail) {$/;"	f
TEST	.\routes\test\FailoverWithExptimeRouteTest.cpp	/^TEST(failoverWithExptimeRouteTest, noFailoverOnArithmatic) {$/;"	f
TEST	.\routes\test\FailoverWithExptimeRouteTest.cpp	/^TEST(failoverWithExptimeRouteTest, noFailoverOnConnectTimeout) {$/;"	f
TEST	.\routes\test\FailoverWithExptimeRouteTest.cpp	/^TEST(failoverWithExptimeRouteTest, noFailoverOnDataTimeout) {$/;"	f
TEST	.\routes\test\FailoverWithExptimeRouteTest.cpp	/^TEST(failoverWithExptimeRouteTest, noFailoverOnTko) {$/;"	f
TEST	.\routes\test\FailoverWithExptimeRouteTest.cpp	/^TEST(failoverWithExptimeRouteTest, once) {$/;"	f
TEST	.\routes\test\FailoverWithExptimeRouteTest.cpp	/^TEST(failoverWithExptimeRouteTest, success) {$/;"	f
TEST	.\routes\test\FailoverWithExptimeRouteTest.cpp	/^TEST(failoverWithExptimeRouteTest, twice) {$/;"	f
TEST	.\routes\test\RateLimitRouteTest.cpp	/^TEST(rateLimitRouteTest, deletesBasic) { testDeletes(); }$/;"	f
TEST	.\routes\test\RateLimitRouteTest.cpp	/^TEST(rateLimitRouteTest, deletesBurst) { testDeletes(true); }$/;"	f
TEST	.\routes\test\RateLimitRouteTest.cpp	/^TEST(rateLimitRouteTest, getsBasic) { testGets(); }$/;"	f
TEST	.\routes\test\RateLimitRouteTest.cpp	/^TEST(rateLimitRouteTest, getsBurst) { testGets(true); }$/;"	f
TEST	.\routes\test\RateLimitRouteTest.cpp	/^TEST(rateLimitRouteTest, setsBasic) { testSets(); }$/;"	f
TEST	.\routes\test\RateLimitRouteTest.cpp	/^TEST(rateLimitRouteTest, setsBurst) { testSets(true); }$/;"	f
TEST	.\routes\test\ReliablePoolRouteTest.cpp	/^TEST(ReliablePoolRouteTest, deleteOps) {$/;"	f
TEST	.\routes\test\ReliablePoolRouteTest.cpp	/^TEST(ReliablePoolRouteTest, failoverOnce) {$/;"	f
TEST	.\routes\test\ReliablePoolRouteTest.cpp	/^TEST(ReliablePoolRouteTest, failoverTwice) {$/;"	f
TEST	.\routes\test\ReliablePoolRouteTest.cpp	/^TEST(ReliablePoolRouteTest, firstHostSuccess) {$/;"	f
TEST	.\routes\test\ShadowRouteTest.cpp	/^TEST(shadowRouteTest, defaultPolicy) {$/;"	f
TEST	.\test\cpp_unit_tests\AccessPointTest.cpp	/^TEST(AccessPoint, host_port) {$/;"	f	namespace:__anon64
TEST	.\test\cpp_unit_tests\AccessPointTest.cpp	/^TEST(AccessPoint, host_port_proto) {$/;"	f	namespace:__anon64
TEST	.\test\cpp_unit_tests\TokenBucketTest.cpp	/^TEST(AtomicTokenBucket, ReverseTime) {$/;"	f	namespace:__anon67
TEST	.\test\cpp_unit_tests\TokenBucketTest.cpp	/^TEST(AtomicTokenBucket, sanity) {$/;"	f	namespace:__anon67
TEST	.\test\cpp_unit_tests\TokenBucketTest.cpp	/^TEST(TokenBucket, ReverseTime) {$/;"	f	namespace:__anon67
TEST	.\test\cpp_unit_tests\TokenBucketTest.cpp	/^TEST(TokenBucket, sanity) {$/;"	f	namespace:__anon67
TEST	.\test\cpp_unit_tests\awriter_test.cpp	/^TEST(awriter, create_destroy) {$/;"	f
TEST	.\test\cpp_unit_tests\awriter_test.cpp	/^TEST(awriter, flush_queue) {$/;"	f
TEST	.\test\cpp_unit_tests\awriter_test.cpp	/^TEST(awriter, invalid_fd) {$/;"	f
TEST	.\test\cpp_unit_tests\awriter_test.cpp	/^TEST(awriter, max_queue_length) {$/;"	f
TEST	.\test\cpp_unit_tests\awriter_test.cpp	/^TEST(awriter, sanity) {$/;"	f
TEST	.\test\cpp_unit_tests\config_api_test.cpp	/^TEST(ConfigApi, file_change) {$/;"	f
TEST	.\test\cpp_unit_tests\file_observer_test.cpp	/^TEST(FileObserver, on_error_callback) {$/;"	f
TEST	.\test\cpp_unit_tests\file_observer_test.cpp	/^TEST(FileObserver, sanity) {$/;"	f
TEST	.\test\cpp_unit_tests\libmcrouter_test.cpp	/^TEST(libmcrouter, invalid_pools) {$/;"	f
TEST	.\test\cpp_unit_tests\libmcrouter_test.cpp	/^TEST(libmcrouter, listenSock) {$/;"	f
TEST	.\test\cpp_unit_tests\libmcrouter_test.cpp	/^TEST(libmcrouter, premature_disconnect) {$/;"	f
TEST	.\test\cpp_unit_tests\libmcrouter_test.cpp	/^TEST(libmcrouter, sanity) {$/;"	f
TEST	.\test\cpp_unit_tests\libmcrouter_test.cpp	/^TEST(libmcrouter, standalone) {$/;"	f
TEST	.\test\cpp_unit_tests\mc_route_handle_provider_test.cpp	/^TEST(McRouteHandleProvider, pool) {$/;"	f
TEST	.\test\cpp_unit_tests\mc_route_handle_provider_test.cpp	/^TEST(McRouteHandleProvider, pool_route) {$/;"	f
TEST	.\test\cpp_unit_tests\mc_route_handle_provider_test.cpp	/^TEST(McRouteHandleProvider, warmup) {$/;"	f
TEST	.\test\cpp_unit_tests\mc_route_handle_provider_test.cpp	/^TEST(McRouteHandleProviderTest, invalid_func) {$/;"	f
TEST	.\test\cpp_unit_tests\mc_route_handle_provider_test.cpp	/^TEST(McRouteHandleProviderTest, sanity) {$/;"	f
TEST	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	/^TEST(mcrouter, already_replied_failed_delete) {$/;"	f
TEST	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	/^TEST(mcrouter, disconnect_callback) {$/;"	f
TEST	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	/^TEST(mcrouter, fork) {$/;"	f
TEST	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	/^TEST(mcrouter, start_and_stop) {$/;"	f
TEST	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	/^TEST(mcrouter, test_zeroreqs_mcroutersend) {$/;"	f
TEST	.\test\cpp_unit_tests\observable_test.cpp	/^TEST(CallbackPool, sanity) {$/;"	f
TEST	.\test\cpp_unit_tests\observable_test.cpp	/^TEST(Observable, rand) {$/;"	f
TEST	.\test\cpp_unit_tests\observable_test.cpp	/^TEST(Observable, sanity) {$/;"	f
TEST	.\test\cpp_unit_tests\options_test.cpp	/^TEST(OptionsSetFromDictTest, sanity) {$/;"	f
TEST	.\test\cpp_unit_tests\periodic_task_scheduler_test.cpp	/^TEST(PeriodicTaskScheduler, test_sanity) {$/;"	f
TEST	.\test\cpp_unit_tests\route_test.cpp	/^TEST(MatchPatternRoute, sanity) {$/;"	f
TEST	.\test\cpp_unit_tests\runtime_vars_data_test.cpp	/^TEST(runtime_vars_data, register_callback) {$/;"	f
TEST	.\test\cpp_unit_tests\runtime_vars_data_test.cpp	/^TEST(runtime_vars_data, sanity) {$/;"	f
TEST_ASSERT	.\lib\fbi\test\counter_test.cpp	99;"	d	file:
THREAD_WAITING	.\lib\fibers\Baton.h	/^  static constexpr intptr_t THREAD_WAITING = -3;$/;"	m	class:facebook::memcache::Baton
TID_SCAN_STR	.\lib\fbi\test\log_tid_tests.cpp	75;"	d	file:
TIMEOUT	.\lib\fibers\Baton.h	/^  static constexpr intptr_t TIMEOUT = -2;$/;"	m	class:facebook::memcache::Baton
TIMER_ABS_MIN	.\lib\fbi\timer.h	/^  TIMER_ABS_MIN,$/;"	e	enum:__anon25
TIMER_AVG_MIN	.\lib\fbi\timer.h	/^  TIMER_AVG_MIN,$/;"	e	enum:__anon25
TIMER_AVG_PEAK	.\lib\fbi\timer.h	/^  TIMER_AVG_PEAK,$/;"	e	enum:__anon25
TIMER_RECENT_MIN	.\lib\fbi\timer.h	/^  TIMER_RECENT_MIN,$/;"	e	enum:__anon25
TIMER_RECENT_PEAK	.\lib\fbi\timer.h	/^  TIMER_RECENT_PEAK,$/;"	e	enum:__anon25
TIMER_RUNNING	.\lib\fbi\timer.h	/^  TIMER_RUNNING,$/;"	e	enum:__anon24
TIMER_STOPPED	.\lib\fbi\timer.h	/^  TIMER_STOPPED,$/;"	e	enum:__anon24
TIMER_TOTAL	.\lib\fbi\timer.h	/^  TIMER_TOTAL=0,$/;"	e	enum:__anon25
TLRU	.\lib\network\test\MockMc.h	/^      TLRU,$/;"	e	enum:facebook::memcache::MockMc::CacheItem::TLRUState
TLRUState	.\lib\network\test\MockMc.h	/^    enum TLRUState {$/;"	g	struct:facebook::memcache::MockMc::CacheItem
TLRU_HOT	.\lib\network\test\MockMc.h	/^      TLRU_HOT,$/;"	e	enum:facebook::memcache::MockMc::CacheItem::TLRUState
TRACEBUF	.\lib\fbi\queue.h	129;"	d
TRACEBUF	.\lib\fbi\queue.h	149;"	d
TRASHIT	.\lib\fbi\queue.h	130;"	d
TRASHIT	.\lib\fbi\queue.h	150;"	d
TaskIterator	.\lib\fibers\AddTasks-inl.h	/^TaskIterator<T>::TaskIterator(TaskIterator&& other)$/;"	f	class:facebook::memcache::fiber::TaskIterator
TaskIterator	.\lib\fibers\AddTasks-inl.h	/^TaskIterator<T>::TaskIterator(std::shared_ptr<Context> context)$/;"	f	class:facebook::memcache::fiber::TaskIterator
TaskIterator	.\lib\fibers\AddTasks.h	/^class TaskIterator {$/;"	c	namespace:facebook::memcache::fiber
TaskThread	.\PeriodicTaskScheduler.cpp	/^PeriodicTaskScheduler::TaskThread::TaskThread($/;"	f	class:facebook::memcache::mcrouter::PeriodicTaskScheduler::TaskThread
TaskThread	.\PeriodicTaskScheduler.h	/^  struct TaskThread {$/;"	s	class:facebook::memcache::mcrouter::PeriodicTaskScheduler
TestAllocator	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^struct TestAllocator : public std::allocator<T> {$/;"	s	file:
TestAsciiError	.\test\test_ascii_error.py	/^class TestAsciiError(McrouterTestCase):$/;"	c
TestAsyncFiles	.\test\test_async_files.py	/^class TestAsyncFiles(McrouterTestCase):$/;"	c
TestBadParams	.\test\test_bad_params.py	/^class TestBadParams(OutputCheckerTestCase):$/;"	c
TestBasicAllFirst	.\test\test_mcrouter_basic.py	/^class TestBasicAllFirst(McrouterTestCase):$/;"	c
TestBasicAllMajority	.\test\test_mcrouter_basic.py	/^class TestBasicAllMajority(McrouterTestCase):$/;"	c
TestBasicAllSync	.\test\test_mcrouter_basic.py	/^class TestBasicAllSync(McrouterTestCase):$/;"	c
TestBasicFailover	.\test\test_mcrouter_basic.py	/^class TestBasicFailover(McrouterTestCase):$/;"	c
TestBasicFailoverOverride	.\test\test_mcrouter_basic.py	/^class TestBasicFailoverOverride(McrouterTestCase):$/;"	c
TestClient	.\lib\network\test\AsyncMcClientTest.cpp	/^  TestClient(std::string host, uint16_t port, int timeoutMs,$/;"	f	class:__anon42::TestClient
TestClient	.\lib\network\test\AsyncMcClientTest.cpp	/^class TestClient {$/;"	c	namespace:__anon42	file:
TestConstShardHash	.\test\test_const_shard_hash.py	/^class TestConstShardHash(McrouterTestCase):$/;"	c
TestDevNull	.\test\test_mcrouter.py	/^class TestDevNull(McrouterTestCase):$/;"	c
TestDuplicateServers	.\test\test_mcrouter.py	/^class TestDuplicateServers(McrouterTestCase):$/;"	c
TestDuplicateServersDiffTimeouts	.\test\test_mcrouter.py	/^class TestDuplicateServersDiffTimeouts(McrouterTestCase):$/;"	c
TestEmptyPool	.\test\test_empty_pool.py	/^class TestEmptyPool(McrouterTestCase):$/;"	c
TestException	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^class TestException {$/;"	c	file:
TestFiberManager	.\lib\test\RouteHandleTestUtil.h	/^  TestFiberManager()$/;"	f	class:facebook::memcache::TestFiberManager
TestFiberManager	.\lib\test\RouteHandleTestUtil.h	/^class TestFiberManager {$/;"	c	namespace:facebook::memcache
TestGetFailover	.\test\test_mcrouter.py	/^class TestGetFailover(McrouterTestCase):$/;"	c
TestGetFailoverWithFailoverTag	.\test\test_mcrouter.py	/^class TestGetFailoverWithFailoverTag(TestGetFailover):$/;"	c
TestHandle	.\lib\test\RouteHandleTestUtil.h	/^  TestHandle(GetRouteTestData g_td,$/;"	f	struct:facebook::memcache::TestHandle
TestHandle	.\lib\test\RouteHandleTestUtil.h	/^  explicit TestHandle(DeleteRouteTestData td)$/;"	f	struct:facebook::memcache::TestHandle
TestHandle	.\lib\test\RouteHandleTestUtil.h	/^  explicit TestHandle(GetRouteTestData td)$/;"	f	struct:facebook::memcache::TestHandle
TestHandle	.\lib\test\RouteHandleTestUtil.h	/^  explicit TestHandle(UpdateRouteTestData td)$/;"	f	struct:facebook::memcache::TestHandle
TestHandle	.\lib\test\RouteHandleTestUtil.h	/^struct TestHandle {$/;"	s	namespace:facebook::memcache
TestLargeObj	.\test\test_largeobj.py	/^class TestLargeObj(McrouterTestCase):$/;"	c
TestLeaseGetFailover	.\test\test_mcrouter.py	/^class TestLeaseGetFailover(McrouterTestCase):$/;"	c
TestLogicalRoutingPolicies	.\test\test_logical_routing_policies.py	/^class TestLogicalRoutingPolicies(McrouterTestCase):$/;"	c
TestMcMsgRef	.\lib\test\RequestReplyTest.cpp	/^typedef Ref<mc_msg_t, TestRefPolicy> TestMcMsgRef;$/;"	t	file:
TestMcrouterBasic	.\test\test_mcrouter_basic.py	/^class TestMcrouterBasic(McrouterTestCase):$/;"	c
TestMcrouterBasic2	.\test\test_mcrouter_basic.py	/^class TestMcrouterBasic2(McrouterTestCase):$/;"	c
TestMcrouterBasicL1L2	.\test\test_mcrouter_basic.py	/^class TestMcrouterBasicL1L2(McrouterTestCase):$/;"	c
TestMcrouterInvalidRoute	.\test\test_mcrouter_basic.py	/^class TestMcrouterInvalidRoute(McrouterTestCase):$/;"	c
TestMcrouterRoutingPrefixAscii	.\test\test_routing_prefixes.py	/^class TestMcrouterRoutingPrefixAscii(McrouterTestCase):$/;"	c
TestMcrouterRoutingPrefixUmbrella	.\test\test_routing_prefixes.py	/^class TestMcrouterRoutingPrefixUmbrella(TestMcrouterRoutingPrefixAscii):$/;"	c
TestMcrouterSanity	.\test\test_mcrouter_sanity.py	/^class TestMcrouterSanity(McrouterTestCase):$/;"	c
TestMcrouterSanityOverUmbrella	.\test\test_mcrouter_sanity.py	/^class TestMcrouterSanityOverUmbrella(TestMcrouterSanity):$/;"	c
TestMetaGetFailover	.\test\test_mcrouter.py	/^class TestMetaGetFailover(McrouterTestCase):$/;"	c
TestMigratedFailover	.\test\test_migrated_failover.py	/^class TestMigratedFailover(McrouterTestCase):$/;"	c
TestMigratedPools	.\test\test_mcrouter.py	/^class TestMigratedPools(McrouterTestCase):$/;"	c
TestMigratedPoolsFailover	.\test\test_mcrouter.py	/^class TestMigratedPoolsFailover(McrouterTestCase):$/;"	c
TestMissOnErrorArithOps	.\test\test_miss_on_error_arith_ops.py	/^class TestMissOnErrorArithOps(McrouterTestCase):$/;"	c
TestMultiplePorts	.\test\test_multiple_ports.py	/^class TestMultiplePorts(unittest.TestCase):$/;"	c
TestNoreply	.\test\test_noreply.py	/^class TestNoreply(McrouterTestCase):$/;"	c
TestProbeTimeout	.\test\test_probe_timeout.py	/^class TestProbeTimeout(McrouterTestCase):$/;"	c
TestRates	.\test\test_rates.py	/^class TestRates(McrouterTestCase):$/;"	c
TestRefPolicy	.\lib\test\RequestReplyTest.cpp	/^struct TestRefPolicy {$/;"	s	file:
TestReliablePoolPolicy	.\test\test_reliable_pool_policy.py	/^class TestReliablePoolPolicy(McrouterTestCase):$/;"	c
TestRequest	.\lib\test\TestRequest.h	/^typedef McRequestWithContext<Context> TestRequest;$/;"	t	namespace:facebook::memcache
TestRequestTimeout	.\test\test_probe_timeout.py	/^class TestRequestTimeout(TestProbeTimeout):$/;"	c
TestRouteHandleIf	.\lib\test\TestRouteHandle.h	/^class TestRouteHandleIf : public RouteHandleIf<TestRouteHandleIf,$/;"	c	namespace:facebook::memcache
TestRouteHandlePtr	.\lib\test\TestRouteHandle.h	/^typedef std::shared_ptr<TestRouteHandleIf> TestRouteHandlePtr;$/;"	t	namespace:facebook::memcache
TestSamePoolFailover	.\test\test_mcrouter.py	/^class TestSamePoolFailover(McrouterTestCase):$/;"	c
TestSendToAllHosts	.\test\test_send_to_all_hosts.py	/^class TestSendToAllHosts(McrouterTestCase):$/;"	c
TestServer	.\lib\network\test\AsyncMcClientTest.cpp	/^  TestServer(bool outOfOrder, bool useSsl,$/;"	f	class:__anon42::TestServer
TestServer	.\lib\network\test\AsyncMcClientTest.cpp	/^class TestServer {$/;"	c	namespace:__anon42	file:
TestServerListFromAnotherPool	.\test\test_mcrouter.py	/^class TestServerListFromAnotherPool(McrouterTestCase):$/;"	c
TestServerStatsOutstandingRequests	.\test\test_max_shadow_requests.py	/^class TestServerStatsOutstandingRequests(McrouterTestCase):$/;"	c
TestServerStatsOutstandingRequests	.\test\test_server_stats.py	/^class TestServerStatsOutstandingRequests(McrouterTestCase):$/;"	c
TestServiceInfo	.\test\test_service_info.py	/^class TestServiceInfo(McrouterTestCase):$/;"	c
TestShadow	.\test\test_shadow.py	/^class TestShadow(McrouterTestCase):$/;"	c
TestShadowWithFile	.\test\test_shadow_with_file.py	/^class TestShadowWithFile(McrouterTestCase):$/;"	c
TestShardSplits	.\test\test_shard_splits.py	/^class TestShardSplits(McrouterTestCase):$/;"	c
TestSlowBoxTko	.\test\test_slow_box_tko.py	/^class TestSlowBoxTko(McrouterTestCase):$/;"	c
TestType	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  TestType() : TestType{0,0} {}$/;"	f	struct:TestType
TestType	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  TestType(int a, int b) {$/;"	f	struct:TestType
TestType	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^struct TestType {$/;"	s	file:
TestTypeThrowing	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  TestTypeThrowing(int val, bool throwEx) {$/;"	f	struct:TestTypeThrowing
TestTypeThrowing	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^struct TestTypeThrowing {$/;"	s	file:
TestUmbrellaServer	.\test\test_umbrella_server.py	/^class TestUmbrellaServer(McrouterTestCase):$/;"	c
TestValidateConfig	.\test\test_validate_config.py	/^class TestValidateConfig(unittest.TestCase):$/;"	c
TestWCH3	.\test\test_wch3.py	/^class TestWCH3(McrouterTestCase):$/;"	c
TestWarmup	.\test\test_warmup.py	/^class TestWarmup(McrouterTestCase):$/;"	c
ThreadSafeObjectPool	.\lib\fbi\cpp\ObjectPool.h	/^  explicit ThreadSafeObjectPool(size_t maxCapacity) : objectPool(maxCapacity) {}$/;"	f	class:facebook::memcache::ThreadSafeObjectPool
ThreadSafeObjectPool	.\lib\fbi\cpp\ObjectPool.h	/^class ThreadSafeObjectPool {$/;"	c	namespace:facebook::memcache
TimePoint	.\lib\fibers\LoopController.h	/^  typedef std::chrono::time_point<Clock> TimePoint;$/;"	t	class:facebook::memcache::LoopController
TimePoint	.\lib\fibers\TimeoutController.h	/^  typedef TimeoutHandle::TimePoint TimePoint;$/;"	t	class:facebook::memcache::TimeoutController
TimePoint	.\lib\fibers\TimeoutController.h	/^  typedef std::chrono::time_point<Clock> TimePoint;$/;"	t	class:facebook::memcache::TimeoutHandle
TimeProviderFunc	.\routes\TimeProviderFunc.h	/^class TimeProviderFunc {$/;"	c	namespace:facebook::memcache::mcrouter
TimeoutCallback	.\lib\network\AsyncMcClientImpl.cpp	/^  TimeoutCallback(AsyncMcClientImpl& client) : client_(client) {$/;"	f	class:facebook::memcache::AsyncMcClientImpl::TimeoutCallback
TimeoutCallback	.\lib\network\AsyncMcClientImpl.cpp	/^class AsyncMcClientImpl::TimeoutCallback : public folly::AsyncTimeout {$/;"	c	class:facebook::memcache::AsyncMcClientImpl	file:
TimeoutController	.\lib\fibers\TimeoutController.cpp	/^TimeoutController::TimeoutController(LoopController& loopController) :$/;"	f	class:facebook::memcache::TimeoutController
TimeoutController	.\lib\fibers\TimeoutController.h	/^class TimeoutController {$/;"	c	namespace:facebook::memcache
TimeoutHandle	.\lib\fibers\TimeoutController.cpp	/^TimeoutHandle::TimeoutHandle(std::function<void()> timeoutFunc) :$/;"	f	class:facebook::memcache::TimeoutHandle
TimeoutHandle	.\lib\fibers\TimeoutController.h	/^class TimeoutHandle {$/;"	c	namespace:facebook::memcache
TimeoutHandleList	.\lib\fibers\TimeoutController.h	/^    boost::intrusive::constant_time_size<false>> TimeoutHandleList;$/;"	t	class:facebook::memcache::TimeoutController
TimeoutHandleListHook	.\lib\fibers\TimeoutController.h	/^    &TimeoutHandle::listHook_> TimeoutHandleListHook;$/;"	t	class:facebook::memcache::TimeoutController
TimeoutServer	.\test\test_max_shadow_requests.py	/^class TimeoutServer(MockServer):$/;"	c
TkoCounters	.\TkoCounters.h	/^struct TkoCounters {$/;"	s	namespace:facebook::memcache::mcrouter
TkoLog	.\TkoLog.cpp	/^TkoLog::TkoLog(const AccessPoint& ap, const TkoCounters& gt)$/;"	f	class:facebook::memcache::mcrouter::TkoLog
TkoLog	.\TkoLog.h	/^struct TkoLog {$/;"	s	namespace:facebook::memcache::mcrouter
TkoLogEvent	.\TkoLog.h	/^enum class TkoLogEvent {$/;"	c	namespace:facebook::memcache::mcrouter
TkoReply	.\lib\Reply.h	/^enum TkoReplyT { TkoReply };$/;"	e	enum:facebook::memcache::TkoReplyT
TkoReplyT	.\lib\Reply.h	/^enum TkoReplyT { TkoReply };$/;"	g	namespace:facebook::memcache
TkoServer	.\test\test_slow_box_tko.py	/^class TkoServer(MockServer):$/;"	c
TkoTracker	.\TkoTracker.cpp	/^TkoTracker::TkoTracker(size_t tkoThreshold,$/;"	f	class:facebook::memcache::mcrouter::TkoTracker
TkoTracker	.\TkoTracker.h	/^class TkoTracker {$/;"	c	namespace:facebook::memcache::mcrouter
TokenBucket	.\TokenBucket.h	/^  TokenBucket(double rate, double burstSize, double nowInSeconds)$/;"	f	class:facebook::memcache::mcrouter::TokenBucket
TokenBucket	.\TokenBucket.h	/^class TokenBucket {$/;"	c	namespace:facebook::memcache::mcrouter
Transaction	.\lib\network\test\SessionTestHarness.h	/^    Transaction(McServerRequestContext&& c, McRequest&& r, McReply p)$/;"	f	struct:facebook::memcache::SessionTestHarness::Transaction
Transaction	.\lib\network\test\SessionTestHarness.h	/^  struct Transaction {$/;"	s	class:facebook::memcache::SessionTestHarness
Trie	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::Trie()$/;"	f	class:facebook::memcache::Trie
Trie	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::Trie(Trie&& other)$/;"	f	class:facebook::memcache::Trie
Trie	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::Trie(const Trie& other)$/;"	f	class:facebook::memcache::Trie
Trie	.\lib\fbi\cpp\Trie.h	/^class Trie {$/;"	c	namespace:facebook::memcache
Type	.\lib\McOperationTraits.h	/^  typedef void* Type;$/;"	t	struct:facebook::memcache::ArithmeticLike
Type	.\lib\McOperationTraits.h	/^  typedef void* Type;$/;"	t	struct:facebook::memcache::DeleteLike
Type	.\lib\McOperationTraits.h	/^  typedef void* Type;$/;"	t	struct:facebook::memcache::GetLike
Type	.\lib\McOperationTraits.h	/^  typedef void* Type;$/;"	t	struct:facebook::memcache::UpdateLike
Type	.\options.h	/^  enum class Type {$/;"	c	struct:facebook::memcache::McrouterOptionData
U32	.\lib\mc\umbrella.h	/^  U32,                      \/\/ uint32_t$/;"	e	enum:entry_type_e
U64	.\lib\mc\umbrella.h	/^  U64,                      \/\/ uint64_t$/;"	e	enum:entry_type_e
UMBRELLA_VERSION_BASIC	.\lib\mc\umbrella.h	25;"	d
UM_NOPS	.\lib\mc\umbrella.h	247;"	d
UM_OP	.\lib\mc\umbrella_conv.h	10;"	d
UM_OP	.\lib\mc\umbrella_conv.h	86;"	d
UM_OP	.\lib\mc\umbrella_protocol.c	22;"	d	file:
UM_OP	.\lib\mc\umbrella_protocol.c	27;"	d	file:
UM_RES	.\lib\mc\umbrella_conv.h	14;"	d
UM_RES	.\lib\mc\umbrella_conv.h	87;"	d
UM_RES	.\lib\mc\umbrella_protocol.c	32;"	d	file:
UM_RES	.\lib\mc\umbrella_protocol.c	37;"	d	file:
UNDEF	.\lib\mc\umbrella.h	/^  UNDEF = 0,$/;"	e	enum:entry_type_e
UP	.\lib\network\AsyncMcClientImpl.h	/^    UP, \/\/ Connection is open and we can write into it.$/;"	m	class:facebook::memcache::AsyncMcClientImpl::ConnectionState
UmbrellaSerializedReply	.\lib\network\UmbrellaProtocol.cpp	/^UmbrellaSerializedReply::UmbrellaSerializedReply() {$/;"	f	class:facebook::memcache::UmbrellaSerializedReply
UmbrellaSerializedReply	.\lib\network\UmbrellaProtocol.h	/^class UmbrellaSerializedReply {$/;"	c	namespace:facebook::memcache
UniqueIntrusiveList	.\lib\network\UniqueIntrusiveList.h	/^  UniqueIntrusiveList() {}$/;"	f	class:facebook::memcache::UniqueIntrusiveList
UniqueIntrusiveList	.\lib\network\UniqueIntrusiveList.h	/^class UniqueIntrusiveList {$/;"	c	namespace:facebook::memcache
UniqueVectorMap	.\routes\RouteHandleMap.cpp	/^        VectorHash> UniqueVectorMap;$/;"	t	namespace:facebook::memcache::mcrouter::__anon58	file:
UpdateLike	.\lib\McOperationTraits.h	/^struct UpdateLike<McOperation<mc_op_add>> {$/;"	s	namespace:facebook::memcache
UpdateLike	.\lib\McOperationTraits.h	/^struct UpdateLike<McOperation<mc_op_append>> {$/;"	s	namespace:facebook::memcache
UpdateLike	.\lib\McOperationTraits.h	/^struct UpdateLike<McOperation<mc_op_bump_count>> {$/;"	s	namespace:facebook::memcache
UpdateLike	.\lib\McOperationTraits.h	/^struct UpdateLike<McOperation<mc_op_bump_unique_count>> {$/;"	s	namespace:facebook::memcache
UpdateLike	.\lib\McOperationTraits.h	/^struct UpdateLike<McOperation<mc_op_cas>> {$/;"	s	namespace:facebook::memcache
UpdateLike	.\lib\McOperationTraits.h	/^struct UpdateLike<McOperation<mc_op_lease_set>> {$/;"	s	namespace:facebook::memcache
UpdateLike	.\lib\McOperationTraits.h	/^struct UpdateLike<McOperation<mc_op_prepend>> {$/;"	s	namespace:facebook::memcache
UpdateLike	.\lib\McOperationTraits.h	/^struct UpdateLike<McOperation<mc_op_replace>> {$/;"	s	namespace:facebook::memcache
UpdateLike	.\lib\McOperationTraits.h	/^struct UpdateLike<McOperation<mc_op_set>> {$/;"	s	namespace:facebook::memcache
UpdateLike	.\lib\OperationTraits.h	/^struct UpdateLike {$/;"	s	namespace:facebook::memcache
UpdateRouteTestData	.\lib\test\RouteHandleTestUtil.h	/^  UpdateRouteTestData() :$/;"	f	struct:facebook::memcache::UpdateRouteTestData
UpdateRouteTestData	.\lib\test\RouteHandleTestUtil.h	/^  explicit UpdateRouteTestData(mc_res_t result,$/;"	f	struct:facebook::memcache::UpdateRouteTestData
UpdateRouteTestData	.\lib\test\RouteHandleTestUtil.h	/^struct UpdateRouteTestData {$/;"	s	namespace:facebook::memcache
VectorHash	.\routes\RouteHandleMap.cpp	/^struct VectorHash {$/;"	s	namespace:facebook::memcache::mcrouter::__anon58	file:
WAITABLE_COUNTER_MAX	.\lib\fbi\waitable_count.c	20;"	d	file:
WAITABLE_COUNTER_STOPPED	.\lib\fbi\waitable_count.c	19;"	d	file:
WRITE_STRING	.\test\cpp_unit_tests\awriter_test.cpp	28;"	d	file:
WRITE_STRING_LEN	.\test\cpp_unit_tests\awriter_test.cpp	29;"	d	file:
WarmUpRoute	.\lib\routes\WarmUpRoute.h	/^  WarmUpRoute(RouteHandleFactory<RouteHandleIf>& factory,$/;"	f	class:facebook::memcache::WarmUpRoute
WarmUpRoute	.\lib\routes\WarmUpRoute.h	/^  WarmUpRoute(std::shared_ptr<RouteHandleIf> warmh,$/;"	f	class:facebook::memcache::WarmUpRoute
WarmUpRoute	.\lib\routes\WarmUpRoute.h	/^class WarmUpRoute {$/;"	c	namespace:facebook::memcache
WeightedCh3HashFunc	.\lib\WeightedCh3HashFunc.cpp	/^WeightedCh3HashFunc::WeightedCh3HashFunc($/;"	f	class:facebook::memcache::WeightedCh3HashFunc
WeightedCh3HashFunc	.\lib\WeightedCh3HashFunc.cpp	/^WeightedCh3HashFunc::WeightedCh3HashFunc(const folly::dynamic& json, size_t n) {$/;"	f	class:facebook::memcache::WeightedCh3HashFunc
WeightedCh3HashFunc	.\lib\WeightedCh3HashFunc.h	/^class WeightedCh3HashFunc {$/;"	c	namespace:facebook::memcache
WriteBuffer	.\lib\network\WriteBuffer.cpp	/^WriteBuffer::WriteBuffer(mc_protocol_t protocol)$/;"	f	class:facebook::memcache::WriteBuffer
WriteBuffer	.\lib\network\WriteBuffer.h	/^class WriteBuffer {$/;"	c	namespace:facebook::memcache
WriteBufferQueue	.\lib\network\WriteBuffer.h	/^  explicit WriteBufferQueue(mc_protocol_t protocol)$/;"	f	class:facebook::memcache::WriteBufferQueue
WriteBufferQueue	.\lib\network\WriteBuffer.h	/^class WriteBufferQueue {$/;"	c	namespace:facebook::memcache
WriterLoop	.\lib\network\AsyncMcClientImpl.cpp	/^  explicit WriterLoop(AsyncMcClientImpl& client)$/;"	f	class:facebook::memcache::AsyncMcClientImpl::WriterLoop
WriterLoop	.\lib\network\AsyncMcClientImpl.cpp	/^class AsyncMcClientImpl::WriterLoop : public folly::EventBase::LoopCallback {$/;"	c	class:facebook::memcache::AsyncMcClientImpl	file:
_SYS_QUEUE_H_	.\lib\fbi\queue.h	20;"	d
__ASSERT_FUNCTION	.\lib\fbi\debug.h	36;"	d
__BEGIN_DECLS	.\lib\fbi\decls.h	15;"	d
__BEGIN_DECLS	.\lib\fbi\decls.h	18;"	d
__BEGIN_DECLS	.\lib\fbi\decls.h	21;"	d
__END_DECLS	.\lib\fbi\decls.h	16;"	d
__END_DECLS	.\lib\fbi\decls.h	19;"	d
__END_DECLS	.\lib\fbi\decls.h	22;"	d
__STDC_FORMAT_MACROS	.\async.cpp	14;"	d	file:
__USE_GNU	.\lib\fbi\fb_cpu_util.c	19;"	d	file:
__del__	.\test\MCProcess.py	/^    def __del__(self):$/;"	m	class:BaseDirectory	file:
__del__	.\test\MCProcess.py	/^    def __del__(self):$/;"	m	class:MCProcess	file:
__init__	.\test\MCProcess.py	/^    def __init__(self, cmd, port, base_dir=None, junk_fill=False):$/;"	m	class:MCProcess
__init__	.\test\MCProcess.py	/^    def __init__(self, config, port=None, default_route=None, extra_args=None,$/;"	m	class:Mcrouter
__init__	.\test\MCProcess.py	/^    def __init__(self, port):$/;"	m	class:McrouterClient
__init__	.\test\MCProcess.py	/^    def __init__(self, port=None):$/;"	m	class:Memcached
__init__	.\test\MCProcess.py	/^    def __init__(self, prefix="mctest"):$/;"	m	class:BaseDirectory
__init__	.\test\mock_servers.py	/^    def __init__(self, expected_key, expected_value):$/;"	m	class:StoreServer
__init__	.\test\mock_servers.py	/^    def __init__(self, port=0):$/;"	m	class:MockServer
__init__	.\test\test_ascii_error.py	/^    def __init__(self, expected_key):$/;"	m	class:ErrorServer
__init__	.\test\test_max_shadow_requests.py	/^    def __init__(self, expected_key, timeout):$/;"	m	class:TimeoutServer
__init__	.\test\test_slow_box_tko.py	/^    def __init__(self, period, phase=0, tmo=0.2, hitcmd='hit'):$/;"	m	class:TkoServer
__need_IOV_MAX	.\async.cpp	22;"	d	file:
_asox_timer_s	.\lib\fbi\asox_timer.c	/^typedef struct _asox_timer_s {$/;"	s	file:
_asox_timer_t	.\lib\fbi\asox_timer.c	/^} _asox_timer_t;$/;"	t	typeref:struct:_asox_timer_s	file:
_assert_func	.\lib\fbi\debug.c	/^void _assert_func(const char *assertion,$/;"	f
_assert_hook	.\lib\fbi\debug.c	/^static volatile assert_hook_fn _assert_hook;$/;"	v	file:
_backing_msg_fill	.\lib\mc\umbrella_protocol.c	/^static void _backing_msg_fill(um_backing_msg_t* bmsg,$/;"	f	file:
_context_s	.\lib\fbi\error.c	/^typedef struct _context_s {$/;"	s	file:
_context_t	.\lib\fbi\error.c	/^} _context_t;$/;"	t	typeref:struct:_context_s	file:
_cpy_fbtrace_meta	.\lib\mc\umbrella_protocol.c	/^static inline int _cpy_fbtrace_meta(char* dst, const uint8_t* body,$/;"	f	file:
_dbg_at	.\lib\fbi\debug.h	123;"	d
_errs_t	.\lib\fbi\error.c	/^typedef TAILQ_HEAD(_errs_s, fbi_err_enclosure_s) _errs_t;$/;"	t	file:
_extra_size	.\lib\mc\msg.h	/^  size_t _extra_size;$/;"	m	struct:mc_msg_s
_facebook_ch_hash_h_	.\lib\fbi\hash.h	11;"	d
_fill_base_msg	.\lib\mc\umbrella_protocol.c	/^static int _fill_base_msg(entry_list_t *elist,$/;"	f	file:
_fill_msg_strs	.\lib\mc\umbrella_protocol.c	/^static int _fill_msg_strs(mc_msg_t* msg, entry_list_t* elist,$/;"	f	file:
_in_msg	.\lib\mc\msg.c	/^static inline int _in_msg(const mc_msg_t *msg, void *p, size_t n) {$/;"	f	file:
_last_total	.\lib\fbi\timer.h	/^  uint64_t _last_total;$/;"	m	struct:fb_timer_s
_mc_msg_num_outstanding	.\lib\mc\msg.c	/^static uint64_t _mc_msg_num_outstanding = 0;$/;"	v	file:
_mc_msg_track_num_outstanding	.\lib\mc\msg.c	/^static int _mc_msg_track_num_outstanding = DEFAULT_TRACK_NUM_OUTSTANDING;$/;"	v	file:
_mc_msg_use_atomic_refcounts	.\lib\mc\msg.c	/^static int _mc_msg_use_atomic_refcounts = 1;$/;"	v	file:
_msg_create	.\lib\mc\umbrella_protocol.c	/^static mc_msg_t *_msg_create(mc_msg_t *base, entry_list_t *elist,$/;"	f	file:
_msg_to_elist	.\lib\mc\umbrella_protocol.c	/^static void _msg_to_elist(entry_list_t* elist,$/;"	f	file:
_msgcpy	.\lib\mc\msg.c	/^static void _msgcpy(mc_msg_t *dst, const mc_msg_t *src) {$/;"	f	file:
_nstring_map_init	.\lib\fbi\nstring.h	/^static inline void _nstring_map_init(nstring_map_t* map,$/;"	f
_num_partial_messages	.\lib\mc\parser.c	/^static unsigned long _num_partial_messages = 0;$/;"	v	file:
_parse_info_s	.\lib\mc\umbrella_protocol.c	/^typedef struct _parse_info_s {$/;"	s	file:
_parse_info_t	.\lib\mc\umbrella_protocol.c	/^} _parse_info_t;$/;"	t	typeref:struct:_parse_info_s	file:
_parser_state_e	.\lib\mc\parser.h	/^typedef enum _parser_state_e {$/;"	g
_parser_state_t	.\lib\mc\parser.h	/^} _parser_state_t;$/;"	t	typeref:enum:_parser_state_e
_refcount	.\lib\mc\mc_fbtrace_info.h	/^  int _refcount;$/;"	m	struct:mc_fbtrace_info_s
_refcount	.\lib\mc\mc_fbtrace_info.h	/^  int _refcount;$/;"	m	struct:mc_fbtrace_s
_refcount	.\lib\mc\msg.h	/^  int _refcount;$/;"	m	struct:mc_msg_s
_refcount	.\mcrouter_client.h	/^  int _refcount;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_t
_refcount	.\proxy.h	/^  int _refcount;$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t
_set	.\test\MCProcess.py	/^    def _set(self, command, key, value, replicate=False, noreply=False):$/;"	m	class:MCProcess
_set_str	.\lib\mc\umbrella_protocol.c	/^static inline void _set_str(nstring_t* str, const uint8_t* body,$/;"	f	file:
_unused_packing	.\lib\fibers\Baton.h	/^      int32_t _unused_packing;$/;"	m	struct:facebook::memcache::Baton::__anon27::__anon28
abandonTrackedSources	.\ConfigApi.cpp	/^void ConfigApi::abandonTrackedSources() {$/;"	f	class:facebook::memcache::mcrouter::ConfigApi
abs_min	.\lib\fbi\timer.h	/^  uint64_t abs_min;$/;"	m	struct:fb_timer_s
absolute_import	.\test\MCProcess.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\McrouterTestCase.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\mcrouter_config.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\mock_servers.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_ascii_error.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_async_files.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_bad_params.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_const_shard_hash.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_empty_pool.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_largeobj.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_logical_routing_policies.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_max_shadow_requests.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_mcrouter.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_mcrouter_basic.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_mcrouter_sanity.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_migrated_failover.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_miss_on_error_arith_ops.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_multiple_ports.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_noreply.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_probe_timeout.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_rates.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_reliable_pool_policy.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_routing_prefixes.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_send_to_all_hosts.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_server_stats.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_service_info.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_shadow.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_shadow_with_file.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_shard_splits.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_slow_box_tko.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_umbrella_server.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_validate_config.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_warmup.py	/^from __future__ import absolute_import$/;"	i
absolute_import	.\test\test_wch3.py	/^from __future__ import absolute_import$/;"	i
acceptCallback_	.\lib\network\AsyncMcServer.cpp	/^  AcceptCallback acceptCallback_;$/;"	m	class:facebook::memcache::McServerThread	file:
acceptorCv_	.\lib\network\AsyncMcServer.cpp	/^  std::condition_variable acceptorCv_;$/;"	m	class:facebook::memcache::McServerThread	file:
acceptorLock_	.\lib\network\AsyncMcServer.cpp	/^  std::mutex acceptorLock_;$/;"	m	class:facebook::memcache::McServerThread	file:
accessPoint	.\ProxyDestination.h	/^  const AccessPoint accessPoint;$/;"	m	struct:facebook::memcache::mcrouter::ProxyDestination
accessPoint	.\TkoLog.h	/^  const AccessPoint& accessPoint;$/;"	m	struct:facebook::memcache::mcrouter::TkoLog
active_	.\ProxyDestinationMap.h	/^  std::unique_ptr<StateList> active_;$/;"	m	class:facebook::memcache::mcrouter::ProxyDestinationMap
add	.\lib\network\test\MockMc.cpp	/^bool MockMc::add(folly::StringPiece key, Item item) {$/;"	f	class:facebook::memcache::MockMc
add	.\test\MCProcess.py	/^    def add(self, key, value, replicate=False, noreply=False):$/;"	m	class:MCProcess
addBuiltInMacro	.\lib\config\ConfigPreprocessor.cpp	/^void ConfigPreprocessor::addBuiltInMacro(string name, vector<dynamic> params,$/;"	f	class:facebook::memcache::ConfigPreprocessor
addClientSocket	.\lib\network\AsyncMcServerWorker.cpp	/^void AsyncMcServerWorker::addClientSocket($/;"	f	class:facebook::memcache::AsyncMcServerWorker
addClientSocket	.\lib\network\AsyncMcServerWorker.cpp	/^void AsyncMcServerWorker::addClientSocket(int fd, void* userCtxt) {$/;"	f	class:facebook::memcache::AsyncMcServerWorker
addHandler	.\lib\fbi\cpp\LogFailure.cpp	/^bool addHandler(std::pair<std::string, HandlerFunc> handler) {$/;"	f	namespace:facebook::memcache::failure
addMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic addMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
addNonownedProxy	.\router.cpp	/^void mcrouter_t::addNonownedProxy(proxy_t* proxy) {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
addPoolToConfig	.\PoolFactory.cpp	/^int PoolFactory::addPoolToConfig(std::shared_ptr<ProxyGenericPool> pool) {$/;"	f	class:facebook::memcache::mcrouter::PoolFactory
addRouteSelector	.\ProxyConfig.cpp	/^void addRouteSelector(const folly::dynamic& aliases,$/;"	f	namespace:facebook::memcache::mcrouter::__anon52
addSecureClientSocket	.\lib\network\AsyncMcServerWorker.cpp	/^void AsyncMcServerWorker::addSecureClientSocket($/;"	f	class:facebook::memcache::AsyncMcServerWorker
addStartupOpts	.\router.cpp	/^void mcrouter_t::addStartupOpts(unordered_map<string, string> additionalOpts) {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
addStat	.\lib\StatsReply.h	/^  void addStat(folly::StringPiece name, V value) {$/;"	f	class:facebook::memcache::StatsReply
addTask	.\lib\fibers\FiberManager-inl.h	/^void FiberManager::addTask(F&& func) {$/;"	f	class:facebook::memcache::FiberManager
addTask	.\lib\fibers\FiberManager.h	/^inline void addTask(F&& func) {$/;"	f	namespace:facebook::memcache::fiber
addTaskFinally	.\lib\fibers\FiberManager-inl.h	/^void FiberManager::addTaskFinally(F&& func, G&& finally) {$/;"	f	class:facebook::memcache::FiberManager
addTaskFinally	.\lib\fibers\FiberManager.h	/^inline void addTaskFinally(F&& func, G&& finally) {$/;"	f	namespace:facebook::memcache::fiber
addTaskReadyFunc	.\lib\fibers\FiberManager-inl.h	/^void FiberManager::addTaskReadyFunc(F&& func, G&& readyFunc) {$/;"	f	class:facebook::memcache::FiberManager
addTaskRemote	.\lib\fibers\FiberManager-inl.h	/^void FiberManager::addTaskRemote(F&& func) {$/;"	f	class:facebook::memcache::FiberManager
addTasks	.\lib\fibers\AddTasks-inl.h	/^addTasks(InputIterator first, InputIterator last) {$/;"	f	namespace:facebook::memcache::fiber
add_down_server	.\test\McrouterTestCase.py	/^    def add_down_server(self, server, logical_port=None):$/;"	m	class:McrouterTestCase
add_mcrouter	.\test\McrouterTestCase.py	/^    def add_mcrouter(self, config, route=None, extra_args=[], replace_map=None,$/;"	m	class:McrouterTestCase
add_server	.\test\McrouterTestCase.py	/^    def add_server(self, server, logical_port=None):$/;"	m	class:McrouterTestCase
additionalLogger_	.\McrouterLogger.h	/^  std::unique_ptr<AdditionalLoggerIf> additionalLogger_;$/;"	m	class:facebook::memcache::mcrouter::McrouterLogger
additionalStartupOpts_	.\_router.h	/^  std::unordered_map<std::string, std::string> additionalStartupOpts_;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
additional_args	.\test\test_slow_box_tko.py	/^    additional_args = ['--global-tko-tracking']$/;"	v	class:TestSlowBoxTko
addrlen	.\lib\fbi\network.h	/^  uint16_t addrlen;$/;"	m	struct:__anon13
addroff	.\lib\fbi\network.h	/^  uint16_t addroff;$/;"	m	struct:__anon13
aggregate	.\stats.h	/^  int aggregate;$/;"	m	struct:facebook::memcache::mcrouter::stat_t
allRoutes_	.\routes\RouteHandleMap.h	/^  std::shared_ptr<RoutePolicyMap> allRoutes_;$/;"	m	class:facebook::memcache::mcrouter::RouteHandleMap
allSyncRoute_	.\routes\ReliablePoolRoute.h	/^  const AllSyncRoute<HashRoute<RouteHandleIf, HashFunc>> allSyncRoute_;$/;"	m	class:facebook::memcache::mcrouter::ReliablePoolRoute
all_stats	.\stats.h	/^  all_stats            =     0xffff,$/;"	e	enum:facebook::memcache::mcrouter::stat_group_t
all_timers	.\lib\fbi\timer.c	/^static fb_timer_list_t all_timers;$/;"	v	file:
alloc	.\lib\fbi\cpp\ObjectPool.h	/^  T* alloc(Args&&... args) {$/;"	f	class:facebook::memcache::ObjectPool
alloc	.\lib\fbi\cpp\ObjectPool.h	/^  T* alloc(Args&&... args) {$/;"	f	class:facebook::memcache::ThreadSafeObjectPool
allocSize	.\lib\fibers\GuardPageAllocator-inl.h	/^size_t allocSize(size_t size) {$/;"	f	namespace:facebook::memcache::__anon31
allocate	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  pointer allocate(size_type n, const_pointer hint = 0) {$/;"	f	struct:TestAllocator
allocate	.\lib\fbi\nstring.h	/^  void* (*allocate)(const size_t);$/;"	m	struct:nstring_map_s
allocate	.\lib\fibers\GuardPageAllocator-inl.h	/^unsigned char* GuardPageAllocator::allocate(size_t size) {$/;"	f	class:facebook::memcache::GuardPageAllocator
allocateInBuffer	.\lib\fibers\FiberManager-inl.h	/^  static constexpr bool allocateInBuffer =$/;"	m	struct:facebook::memcache::FiberManager::AddTaskFinallyHelper
allocator_	.\lib\fbi\cpp\ObjectPool.h	/^  Allocator allocator_;                 \/\/ Allocator used to allocate objects$/;"	m	class:facebook::memcache::ObjectPool
always_optional	.\lib\mc\umbrella_protocol.c	54;"	d	file:
always_optional	.\lib\mc\umbrella_protocol.c	56;"	d	file:
always_required	.\lib\mc\umbrella_protocol.c	52;"	d	file:
andMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic andMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
ap	.\ProxyClientCommon.h	/^  AccessPoint ap;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientCommon
ap_	.\AccessPoint.h	/^  mc_accesspoint_t ap_;$/;"	m	struct:facebook::memcache::mcrouter::AccessPoint
appSpecificErrorCode	.\lib\McReplyBase.h	/^  uint32_t appSpecificErrorCode() const {$/;"	f	class:facebook::memcache::McReplyBase
appendDouble	.\lib\network\UmbrellaProtocol.cpp	/^void UmbrellaSerializedReply::appendDouble(double val) {$/;"	f	class:facebook::memcache::UmbrellaSerializedReply
appendInt	.\lib\network\UmbrellaProtocol.cpp	/^void UmbrellaSerializedReply::appendInt($/;"	f	class:facebook::memcache::UmbrellaSerializedReply
appendString	.\lib\network\UmbrellaProtocol.cpp	/^void UmbrellaSerializedReply::appendString($/;"	f	class:facebook::memcache::UmbrellaSerializedReply
appendStringToFile	.\lib\fbi\cpp\util.cpp	/^bool appendStringToFile(folly::StringPiece contents, const std::string& path) {$/;"	f	namespace:facebook::memcache
append_non_zero	.\lib\mc\umbrella_protocol.c	526;"	d	file:
append_non_zero	.\lib\mc\umbrella_protocol.c	546;"	d	file:
arg	.\lib\fbi\asox_queue.c	/^  void *arg;$/;"	m	struct:asox_queue_s	file:
arg	.\lib\fbi\asox_semaphore.c	/^  void *arg;$/;"	m	struct:asox_sem_s	file:
arg	.\lib\fbi\asox_timer.c	/^  void* arg;$/;"	m	struct:_asox_timer_s	file:
arg	.\mcrouter_client.h	/^  void *arg;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_t
arith	.\lib\network\test\MockMc.cpp	/^std::pair<bool, int64_t> MockMc::arith(folly::StringPiece key, int64_t delta) {$/;"	f	class:facebook::memcache::MockMc
arith_req	.\lib\mc\umbrella_protocol.c	59;"	d	file:
asPositiveDouble	.\routes\RateLimiter.cpp	/^double asPositiveDouble(const dynamic& obj, const string& keyName) {$/;"	f	namespace:facebook::memcache::mcrouter::__anon57
asPositiveDoubleDefault	.\routes\RateLimiter.cpp	/^double asPositiveDoubleDefault(const dynamic& obj, const string& keyName,$/;"	f	namespace:facebook::memcache::mcrouter::__anon57
asString	.\lib\config\ConfigPreprocessor.cpp	/^string asString(const dynamic& obj, StringPiece objName) {$/;"	f	namespace:facebook::memcache::__anon4
asciiBuffer_	.\lib\network\McSerializedRequest.h	/^  std::unique_ptr<char[]> asciiBuffer_;$/;"	m	class:facebook::memcache::McSerializedRequest
asciiKey	.\lib\network\McServerRequestContext.h	/^  folly::Optional<folly::IOBuf>& asciiKey() {$/;"	f	class:facebook::memcache::McServerRequestContext
asciiReply_	.\lib\network\WriteBuffer.h	/^    AsciiSerializedReply asciiReply_;$/;"	m	union:facebook::memcache::WriteBuffer::__anon43
asciiResponse_	.\lib\network\WriteBuffer.h	/^  mc_ascii_response_buf_t asciiResponse_;$/;"	m	class:facebook::memcache::AsciiSerializedReply
asciiState_	.\lib\network\McServerRequestContext.h	/^  std::unique_ptr<AsciiState> asciiState_;$/;"	m	class:facebook::memcache::McServerRequestContext
asox_add_timer	.\lib\fbi\asox_timer.c	/^asox_timer_t asox_add_timer(struct event_base* event_base,$/;"	f
asox_on_timer_t	.\lib\fbi\asox_timer.h	/^typedef void (asox_on_timer_t)(const asox_timer_t timer, void* arg);$/;"	t
asox_queue_callbacks_s	.\lib\fbi\asox_queue.h	/^typedef struct asox_queue_callbacks_s {$/;"	s
asox_queue_callbacks_t	.\lib\fbi\asox_queue.h	/^} asox_queue_callbacks_t;$/;"	t	typeref:struct:asox_queue_callbacks_s
asox_queue_del	.\lib\fbi\asox_queue.c	/^void asox_queue_del(asox_queue_t q) {$/;"	f
asox_queue_disconnect	.\lib\fbi\asox_queue.c	/^void asox_queue_disconnect(asox_queue_t q) {$/;"	f
asox_queue_element_ready	.\lib\fbi\asox_queue.h	/^typedef void (asox_queue_element_ready)(asox_queue_t queue,$/;"	t
asox_queue_element_sweep	.\lib\fbi\asox_queue.h	/^typedef void (asox_queue_element_sweep)(asox_queue_t queue,$/;"	t
asox_queue_enqueue	.\lib\fbi\asox_queue.c	/^int asox_queue_enqueue(asox_queue_t queue,$/;"	f
asox_queue_enqueue_nocopy	.\lib\fbi\asox_queue.c	/^int asox_queue_enqueue_nocopy(asox_queue_t queue,$/;"	f
asox_queue_entry_flags_t	.\lib\fbi\asox_queue.h	/^} asox_queue_entry_flags_t;$/;"	t	typeref:enum:__anon5
asox_queue_entry_s	.\lib\fbi\asox_queue.h	/^typedef struct asox_queue_entry_s {$/;"	s
asox_queue_entry_t	.\lib\fbi\asox_queue.h	/^} asox_queue_entry_t;$/;"	t	typeref:struct:asox_queue_entry_s
asox_queue_flags_t	.\lib\fbi\asox_queue.h	/^} asox_queue_flags_t;$/;"	t	typeref:enum:__anon6
asox_queue_free	.\lib\fbi\asox_queue.c	/^static void asox_queue_free(asox_queue_t q) {$/;"	f	file:
asox_queue_init	.\lib\fbi\asox_queue.c	/^asox_queue_t asox_queue_init(struct event_base* base,$/;"	f
asox_queue_is_disconnected	.\lib\fbi\asox_queue.c	/^int asox_queue_is_disconnected(asox_queue_t q) {$/;"	f
asox_queue_multi_enqueue	.\lib\fbi\asox_queue.c	/^int asox_queue_multi_enqueue(asox_queue_t queue,$/;"	f
asox_queue_multi_enqueue_nocopy	.\lib\fbi\asox_queue.c	/^static int asox_queue_multi_enqueue_nocopy(asox_queue_t queue,$/;"	f	file:
asox_queue_remote_disconnect	.\lib\fbi\asox_queue.c	/^void asox_queue_remote_disconnect(asox_queue_t q) {$/;"	f
asox_queue_s	.\lib\fbi\asox_queue.c	/^struct asox_queue_s {$/;"	s	file:
asox_queue_sweep	.\lib\fbi\asox_queue.c	/^static bool asox_queue_sweep(asox_queue_t q,$/;"	f	file:
asox_queue_t	.\lib\fbi\asox_queue.h	/^typedef struct asox_queue_s* asox_queue_t;$/;"	t	typeref:struct:asox_queue_s
asox_remove_timer	.\lib\fbi\asox_timer.c	/^void asox_remove_timer(asox_timer_t handle) {$/;"	f
asox_sem_callbacks_s	.\lib\fbi\asox_semaphore.h	/^typedef struct asox_sem_callbacks_s {$/;"	s
asox_sem_callbacks_t	.\lib\fbi\asox_semaphore.h	/^} asox_sem_callbacks_t;$/;"	t	typeref:struct:asox_sem_callbacks_s
asox_sem_del	.\lib\fbi\asox_semaphore.c	/^void asox_sem_del(asox_sem_t sem_in) {$/;"	f
asox_sem_flags_t	.\lib\fbi\asox_semaphore.h	/^} asox_sem_flags_t;$/;"	t	typeref:enum:__anon7
asox_sem_handler	.\lib\fbi\asox_semaphore.c	/^void asox_sem_handler(int fd, short flags, void *arg) {$/;"	f
asox_sem_new	.\lib\fbi\asox_semaphore.c	/^asox_sem_t asox_sem_new(struct event_base* base,$/;"	f
asox_sem_new_from_fds	.\lib\fbi\asox_semaphore.c	/^asox_sem_t asox_sem_new_from_fds(int read_fd,$/;"	f
asox_sem_on_signal	.\lib\fbi\asox_semaphore.h	/^typedef bool (asox_sem_on_signal)(asox_sem_t sem,$/;"	t
asox_sem_read	.\lib\fbi\asox_semaphore.c	/^static inline uint64_t asox_sem_read(struct asox_sem_s *sem) {$/;"	f	file:
asox_sem_remove_event	.\lib\fbi\asox_semaphore.c	/^void asox_sem_remove_event(asox_sem_t sem_in) {$/;"	f
asox_sem_s	.\lib\fbi\asox_semaphore.c	/^struct asox_sem_s {$/;"	s	file:
asox_sem_signal	.\lib\fbi\asox_semaphore.c	/^int asox_sem_signal(asox_sem_t asox_sem, uint64_t num_signals) {$/;"	f
asox_sem_t	.\lib\fbi\asox_semaphore.h	/^typedef struct asox_sem_s* asox_sem_t;$/;"	t	typeref:struct:asox_sem_s
asox_timer_handler	.\lib\fbi\asox_timer.c	/^static void asox_timer_handler(int fd, short flags, void* arg) {$/;"	f	file:
asox_timer_t	.\lib\fbi\asox_timer.h	/^typedef void* asox_timer_t;$/;"	t
assert_hook_fn	.\lib\fbi\debug.h	/^typedef void (*assert_hook_fn)(const char *assert_msg);$/;"	t
asyncLog_	.\routes\AsynclogRoute.h	/^  AsynclogFunc asyncLog_;$/;"	m	class:facebook::memcache::mcrouter::AsynclogRoute
asyncMcClient_	.\DestinationClient.h	/^  std::unique_ptr<AsyncMcClient> asyncMcClient_;$/;"	m	class:facebook::memcache::mcrouter::DestinationClient
asyncRoute_	.\lib\routes\AllInitialRoute.h	/^  std::unique_ptr<AllAsyncRoute<RouteHandleIf>> asyncRoute_;$/;"	m	class:facebook::memcache::AllInitialRoute
async_write_file	.\async.cpp	/^int async_write_file(AsyncWriter* awriter,$/;"	f	namespace:facebook::memcache::mcrouter
asynclog_command	.\async.cpp	/^void asynclog_command(proxy_request_t *preq,$/;"	f	namespace:facebook::memcache::mcrouter
asynclog_event	.\async.cpp	/^static void asynclog_event(proxy_request_t *preq,$/;"	f	namespace:facebook::memcache::mcrouter
asynclog_event_command	.\async.h	/^  asynclog_event_command = 'C',$/;"	e	enum:facebook::memcache::mcrouter::asynclog_event_type_t
asynclog_event_type_t	.\async.h	/^enum asynclog_event_type_t {$/;"	g	namespace:facebook::memcache::mcrouter
asynclog_event_unknown	.\async.h	/^  asynclog_event_unknown = 0,$/;"	e	enum:facebook::memcache::mcrouter::asynclog_event_type_t
asynclog_open	.\async.cpp	/^static std::shared_ptr<folly::File> asynclog_open(proxy_t *proxy) {$/;"	f	namespace:facebook::memcache::mcrouter
at	.\mcrouter_config.h	/^  const mapped_type& at(folly::StringPiece key) const {$/;"	f	class:facebook::memcache::mcrouter::StringKeyedUnorderedMap
at	.\mcrouter_config.h	/^  mapped_type& at(folly::StringPiece key) {$/;"	f	class:facebook::memcache::mcrouter::StringKeyedUnorderedMap
at_once	.\lib\fbi\asox_queue.c	/^  unsigned at_once;$/;"	m	struct:asox_queue_s	file:
atexit	.\test\MCProcess.py	/^import atexit$/;"	i
atomicallyWriteFileToDisk	.\lib\fbi\cpp\util.cpp	/^bool atomicallyWriteFileToDisk(folly::StringPiece contents,$/;"	f	namespace:facebook::memcache
attachEventBase	.\lib\fibers\EventBaseLoopController-inl.h	/^inline void EventBaseLoopController::attachEventBase($/;"	f	class:facebook::memcache::mcrouter::EventBaseLoopController
attachEventBase	.\proxy.cpp	/^void proxy_t::attachEventBase(folly::EventBase* eventBase_) {$/;"	f	class:facebook::memcache::mcrouter::proxy_t
attachRequestClass	.\routes\ShadowRoute.h	/^  static void attachRequestClass(ProxyMcRequest& req) {$/;"	f	class:facebook::memcache::mcrouter::ShadowRoute
attachRequestClass	.\routes\ShadowRoute.h	/^  static void attachRequestClass(Request& req) {$/;"	f	class:facebook::memcache::mcrouter::ShadowRoute
attemptConnection	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::attemptConnection() {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
available	.\AtomicTokenBucket.h	/^  double available(double nowInSeconds = defaultClockNow()) const {$/;"	f	class:facebook::memcache::mcrouter::AtomicTokenBucket
available	.\AtomicTokenBucket.h	/^  double available(double rate,$/;"	f	class:facebook::memcache::mcrouter::DynamicAtomicTokenBucket
available	.\TokenBucket.h	/^  double available() const {$/;"	f	class:facebook::memcache::mcrouter::TokenBucket
avg	.\lib\fbi\timer.h	/^  uint64_t avg;$/;"	m	struct:fb_timer_s
avgLatency	.\ProxyDestination.h	/^  ExponentialSmoothData avgLatency;$/;"	m	struct:facebook::memcache::mcrouter::ProxyDestinationStats
avg_min	.\lib\fbi\timer.h	/^  uint64_t avg_min;$/;"	m	struct:fb_timer_s
avg_peak	.\lib\fbi\timer.h	/^  uint64_t avg_peak;$/;"	m	struct:fb_timer_s
await	.\lib\fibers\FiberManager-inl.h	/^FiberManager::await(F&& func) {$/;"	f	class:facebook::memcache::FiberManager
await	.\lib\fibers\FiberManager.h	/^inline await(F&& func) {$/;"	f	class:facebook::memcache::fiber::FirstArgOf::type
awaitFunc_	.\lib\fibers\FiberManager.h	/^  std::function<void(Fiber&)> awaitFunc_;$/;"	m	class:facebook::memcache::FiberManager
awaitNext	.\lib\fibers\AddTasks-inl.h	/^inline T TaskIterator<T>::awaitNext() {$/;"	f	class:facebook::memcache::fiber::TaskIterator
awaitNext	.\lib\fibers\AddTasks-inl.h	/^inline void TaskIterator<void>::awaitNext() {$/;"	f	class:facebook::memcache::fiber::TaskIterator
awaitNextResult	.\lib\fibers\AddTasks-inl.h	/^folly::wangle::Try<T> TaskIterator<T>::awaitNextResult() {$/;"	f	class:facebook::memcache::fiber::TaskIterator
awentry	.\async.cpp	/^  awriter_entry_t awentry;$/;"	m	struct:facebook::memcache::mcrouter::__anon1::write_file_entry_t	file:
awentry	.\proxy.h	/^  awriter_entry_t awentry;$/;"	m	struct:facebook::memcache::mcrouter::writelog_entry_t
awfulness	.\lib\McReplyBase-inl.h	/^inline int awfulness(mc_res_t result) {$/;"	f	namespace:facebook::memcache::__anon36
awriter	.\_router.h	/^  std::unique_ptr<AsyncWriter> awriter;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
awriter_callbacks_t	.\awriter.h	/^struct awriter_callbacks_t {$/;"	s	namespace:facebook::memcache::mcrouter
awriter_entry_t	.\awriter.h	/^struct awriter_entry_t {$/;"	s	namespace:facebook::memcache::mcrouter
awriter_queue	.\async.cpp	/^bool awriter_queue(AsyncWriter* w, awriter_entry_t *e) {$/;"	f	namespace:facebook::memcache::mcrouter
back	.\lib\network\UniqueIntrusiveList.h	/^  T& back() { return list_.back(); }$/;"	f	class:facebook::memcache::UniqueIntrusiveList
back	.\lib\network\UniqueIntrusiveList.h	/^  const T& back() const { return list_.back(); }$/;"	f	class:facebook::memcache::UniqueIntrusiveList
backing_message	.\lib\mc\umbrella.h	/^  char *backing_message; \/\/ buffer from which this is built.  entries & body$/;"	m	struct:entry_list_s
backing_message_allocated	.\lib\mc\umbrella.h	/^  int backing_message_allocated;$/;"	m	struct:entry_list_s
backoff	.\lib\fbi\debug.c	/^  float backoff;$/;"	m	struct:msg_info	file:
bad_key	.\lib\mc\parser.h	/^  int bad_key;$/;"	m	struct:parser_s
base	.\lib\fbi\asox_semaphore.c	/^  struct event_base* base;$/;"	m	struct:asox_sem_s	typeref:struct:asox_sem_s::event_base	file:
base	.\lib\fbi\test\asox_queue_test.cpp	/^  folly::EventBase base;$/;"	m	struct:thread_arg_t	file:
base	.\lib\fbi\test\asox_sem_test.cpp	/^  folly::EventBase base;$/;"	m	struct:__anon20::test_arg_t	file:
base_	.\lib\network\AsyncMcClient.h	/^  std::shared_ptr<AsyncMcClientImpl> base_;$/;"	m	class:facebook::memcache::AsyncMcClient
basicTimerChecks	.\lib\fbi\test\timer_tests.cpp	/^static void basicTimerChecks(fb_timer_t *timer,$/;"	f	file:
baton_	.\lib\fibers\FiberPromise-inl.h	/^value_(other.value_), baton_(other.baton_) {$/;"	f	namespace:facebook::memcache
baton_	.\lib\fibers\FiberPromise.h	/^  Baton* baton_;$/;"	m	class:facebook::memcache::FiberPromise
begin	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::begin() const {$/;"	f	class:facebook::memcache::Trie
begin	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::begin() {$/;"	f	class:facebook::memcache::Trie
begin	.\lib\network\UniqueIntrusiveList.h	/^  iterator begin() { return list_.begin(); }$/;"	f	class:facebook::memcache::UniqueIntrusiveList
bernstein_hash	.\lib\fbi\nstring.h	/^static inline uint32_t bernstein_hash(const char* str, size_t len) {$/;"	f
bigKeyTest	.\lib\network\test\AsyncMcClientTest.cpp	/^void bigKeyTest(mc_protocol_t protocol) {$/;"	f
bind_thread_to_cpu	.\lib\fbi\fb_cpu_util.c	/^void bind_thread_to_cpu(int cpuid) {$/;"	f
blob_s	.\lib\fbi\examples\thread-errs.c	/^typedef struct blob_s {$/;"	s	file:
blob_t	.\lib\fbi\examples\thread-errs.c	/^} blob_t;$/;"	t	typeref:struct:blob_s	file:
block_	.\lib\network\MultiOpParent.h	/^  McServerRequestContext block_;$/;"	m	class:facebook::memcache::MultiOpParent
blockedReplies_	.\lib\network\McServerSession.h	/^    std::pair<McServerRequestContext, McReply>> blockedReplies_;$/;"	m	class:facebook::memcache::McServerSession
body	.\lib\mc\umbrella.h	/^  void *body;              \/\/ pointer to body$/;"	m	struct:entry_list_s
body_allocated	.\lib\mc\umbrella.h	/^  uint32_t body_allocated; \/\/ only free the body if we allocated it$/;"	m	struct:entry_list_s
body_size	.\lib\mc\umbrella.h	/^  uint32_t body_size;      \/\/ total body size$/;"	m	struct:entry_list_s
body_size	.\lib\mc\umbrella_protocol.h	/^  size_t body_size;$/;"	m	struct:um_message_info_s
boolMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic boolMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
buckets	.\lib\fbi\nstring.h	/^  size_t buckets;$/;"	m	struct:nstring_map_s
buf	.\lib\mc\msg.c	/^  uint8_t buf[0];$/;"	m	struct:nzlib_format_s	file:
buf	.\proxy.h	/^  std::string buf;$/;"	m	struct:facebook::memcache::mcrouter::writelog_entry_t
buffer	.\lib\mc\ascii_response.h	/^  char buffer[SCRATCH_BUFFER_LEN];$/;"	m	struct:mc_ascii_response_buf_s
buffer_	.\lib\network\AsyncMcClientImpl.h	/^  folly::IOBufQueue buffer_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
buildConfig	.\ProxyConfigBuilder.cpp	/^ProxyConfigBuilder::buildConfig(proxy_t* proxy) const {$/;"	f	class:facebook::memcache::mcrouter::ProxyConfigBuilder
builtInCalls_	.\lib\config\ConfigPreprocessor.h	/^  > builtInCalls_;$/;"	m	class:facebook::memcache::ConfigPreprocessor
burstSize_	.\AtomicTokenBucket.h	/^  const double burstSize_;$/;"	m	class:facebook::memcache::mcrouter::AtomicTokenBucket
burstSize_	.\TokenBucket.h	/^  double burstSize_;$/;"	m	class:facebook::memcache::mcrouter::TokenBucket
byPoolName_	.\ProxyConfig.h	/^  std::unordered_map<std::string, McrouterRouteHandlePtr> byPoolName_;$/;"	m	class:facebook::memcache::mcrouter::ProxyConfig
byRegion_	.\routes\RouteHandleMap.h	/^  StringKeyedUnorderedMap<std::shared_ptr<RoutePolicyMap>> byRegion_;$/;"	m	class:facebook::memcache::mcrouter::RouteHandleMap
byRoute_	.\routes\RouteHandleMap.h	/^  StringKeyedUnorderedMap<std::shared_ptr<RoutePolicyMap>> byRoute_;$/;"	m	class:facebook::memcache::mcrouter::RouteHandleMap
c_	.\lib\fbi\cpp\Trie.h	/^  char c_;$/;"	m	class:facebook::memcache::Trie
callFuncs	.\lib\fibers\ForEach-inl.h	/^inline callFuncs(F&& f, G&& g, size_t id) {$/;"	f	class:facebook::memcache::fiber::__anon30::std::enable_if
callbackLock	.\CallbackPool-inl.h	/^  SFRLock callbackLock;$/;"	m	struct:facebook::memcache::mcrouter::CallbackPool::Data
callback_	.\RecordingContext.h	/^  OnRecordCallback callback_;$/;"	m	class:facebook::memcache::mcrouter::RecordingContext
callback_	.\lib\fibers\EventBaseLoopController.h	/^  std::unique_ptr<ControllerCallback> callback_;$/;"	m	class:facebook::memcache::mcrouter::EventBaseLoopController
callback_counter	.\test\cpp_unit_tests\awriter_test.cpp	/^void callback_counter(awriter_entry_t *e, int result) {$/;"	f
callbacks	.\CallbackPool-inl.h	/^  std::set<CallbackHandleImpl*> callbacks;$/;"	m	struct:facebook::memcache::mcrouter::CallbackPool::Data
callbacks	.\awriter.h	/^  const awriter_callbacks_t *callbacks;$/;"	m	struct:facebook::memcache::mcrouter::awriter_entry_t
callbacks	.\lib\fbi\asox_queue.c	/^  const asox_queue_callbacks_t *callbacks;$/;"	m	struct:asox_queue_s	file:
callbacks	.\lib\fbi\asox_semaphore.c	/^  asox_sem_callbacks_t const *callbacks;$/;"	m	struct:asox_sem_s	file:
callbacks	.\lib\fbi\test\asox_sem_test.cpp	/^asox_sem_callbacks_t callbacks = {my_on_signal};$/;"	m	namespace:__anon20	file:
callbacks	.\mcrouter_client.h	/^  mcrouter_client_callbacks_t callbacks;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_t
callbacks_	.\ConfigApi.h	/^  CallbackPool<> callbacks_;$/;"	m	class:facebook::memcache::mcrouter::ConfigType::ConfigApi
canPassThrough	.\routes\RateLimiter.h	/^  bool canPassThrough(Operation, OtherThanT(Operation,$/;"	f	class:facebook::memcache::mcrouter::RateLimiter
canPassThrough	.\routes\RateLimiter.h	/^  bool canPassThrough(Operation, typename DeleteLike<Operation>::Type = 0) {$/;"	f	class:facebook::memcache::mcrouter::RateLimiter
canPassThrough	.\routes\RateLimiter.h	/^  bool canPassThrough(Operation, typename GetLike<Operation>::Type = 0) {$/;"	f	class:facebook::memcache::mcrouter::RateLimiter
canPassThrough	.\routes\RateLimiter.h	/^  bool canPassThrough(Operation, typename UpdateLike<Operation>::Type = 0) {$/;"	f	class:facebook::memcache::mcrouter::RateLimiter
cancel	.\lib\fibers\EventBaseLoopController-inl.h	/^inline void EventBaseLoopController::cancel() {$/;"	f	class:facebook::memcache::mcrouter::EventBaseLoopController
cancelWriterCallback	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::cancelWriterCallback() {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
cas	.\lib\McReplyBase.h	/^  uint64_t cas() const {$/;"	f	class:facebook::memcache::McReplyBase
cas	.\lib\McRequestBase.h	/^  uint64_t cas() const {$/;"	f	class:facebook::memcache::McRequestBase
cas	.\lib\mc\msg.h	/^  uint64_t cas;$/;"	m	struct:mc_msg_s
cbegin	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::cbegin() const {$/;"	f	class:facebook::memcache::Trie
cend	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::cend() const {$/;"	f	class:facebook::memcache::Trie
ch3_	.\routes\ShardHashFunc.h	/^  Ch3HashFunc ch3_;$/;"	m	class:facebook::memcache::mcrouter::ConstShardHashFunc
ch_	.\routes\BigValueRoute.h	/^  const std::shared_ptr<RouteHandleIf> ch_;$/;"	m	class:facebook::memcache::BigValueRoute
checkAndExecuteFallbackOnError	.\FileObserver.cpp	/^static void checkAndExecuteFallbackOnError($/;"	f	namespace:facebook::memcache::mcrouter
checkClosed	.\lib\network\McServerSession.cpp	/^void McServerSession::checkClosed() {$/;"	f	class:facebook::memcache::McServerSession
checkCopies	.\lib\test\RequestReplyTest.cpp	/^void checkCopies(McRequest& req, mc_msg_t* msg) {$/;"	f
checkFileUpdate	.\ConfigApi.cpp	/^bool ConfigApi::checkFileUpdate() {$/;"	f	class:facebook::memcache::mcrouter::ConfigApi
checkKey	.\lib\test\RequestReplyTest.cpp	/^void checkKey(const std::string& key,$/;"	f
checkLogic	.\lib\fbi\cpp\util.h	/^void checkLogic(bool condition, folly::StringPiece format, Args&&... args) {$/;"	f	namespace:facebook::memcache
checkMd5Changed	.\ConfigApi.cpp	/^bool ConfigApi::FileInfo::checkMd5Changed() {$/;"	f	class:facebook::memcache::mcrouter::ConfigApi::FileInfo
checkRequestReply	.\test\cpp_unit_tests\libmcrouter_test.cpp	/^void checkRequestReply(int fd,$/;"	f	namespace:__anon65
check_for_message	.\test\test_bad_params.py	/^    def check_for_message(self, good, bad, timeout):$/;"	m	class:OutputCheckerTestCase
check_log_limit	.\lib\fbi\log_limit.c	/^int check_log_limit(const struct timeval *now) {$/;"	f
child_node	.\lib\mc\mc_fbtrace_info.h	/^  fbtrace_remote_node_t child_node;$/;"	m	struct:mc_fbtrace_info_s
children_	.\lib\routes\AllAsyncRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> children_;$/;"	m	class:facebook::memcache::AllAsyncRoute
children_	.\lib\routes\AllFastestRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> children_;$/;"	m	class:facebook::memcache::AllFastestRoute
children_	.\lib\routes\AllMajorityRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> children_;$/;"	m	class:facebook::memcache::AllMajorityRoute
children_	.\lib\routes\AllSyncRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> children_;$/;"	m	class:facebook::memcache::AllSyncRoute
chunkGetRequests	.\routes\BigValueRoute-inl.h	/^BigValueRoute<RouteHandleIf>::chunkGetRequests(const Request& req,$/;"	f	class:facebook::memcache::BigValueRoute
chunkUpdateRequests	.\routes\BigValueRoute-inl.h	/^BigValueRoute<RouteHandleIf>::chunkUpdateRequests(const Request& req,$/;"	f	class:facebook::memcache::BigValueRoute
citems_	.\lib\network\test\MockMc.h	/^  std::unordered_map<std::string, CacheItem> citems_;$/;"	m	class:facebook::memcache::MockMc
cleanup_stderr_redir	.\lib\fbi\test\log_tid_tests.cpp	/^static void cleanup_stderr_redir(int saved_stderr) {$/;"	f	file:
clear	.\lib\fbi\cpp\Trie-inl.h	/^void Trie<Value, MinChar, MaxChar>::clear() {$/;"	f	class:facebook::memcache::Trie
clear	.\lib\network\UmbrellaProtocol.h	/^  void clear() {}$/;"	f	class:facebook::memcache::UmbrellaSerializedReply
clear	.\lib\network\WriteBuffer.cpp	/^void AsciiSerializedReply::clear() {$/;"	f	class:facebook::memcache::AsciiSerializedReply
clear	.\lib\network\WriteBuffer.cpp	/^void WriteBuffer::clear() {$/;"	f	class:facebook::memcache::WriteBuffer
clientId	.\mcrouter_client.h	/^  uint64_t clientId;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_t
clientParseCallback_	.\lib\network\McParser.h	/^    ClientParseCallback* clientParseCallback_;$/;"	m	union:facebook::memcache::McParser::__anon40
clientStateToStr	.\stats.cpp	/^const char* clientStateToStr(proxy_client_state_t state) {$/;"	f	namespace:facebook::memcache::mcrouter::__anon62
client_	.\ProxyDestination.h	/^  std::unique_ptr<DestinationMcClient> client_;$/;"	m	struct:facebook::memcache::mcrouter::ProxyDestination
client_	.\lib\network\AsyncMcClientImpl.cpp	/^  AsyncMcClientImpl& client_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl::TimeoutCallback	file:
client_	.\lib\network\AsyncMcClientImpl.cpp	/^  AsyncMcClientImpl& client_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl::WriterLoop	file:
client_	.\lib\network\AsyncMcClientImpl.cpp	/^  AsyncMcClientImpl& client_;$/;"	m	class:facebook::memcache::detail::OnEventBaseDestructionCallback	file:
client_	.\lib\network\AsyncMcClientImpl.h	/^    std::shared_ptr<AsyncMcClientImpl> client_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl::ReqInfo
client_	.\lib\network\test\AsyncMcClientTest.cpp	/^  std::unique_ptr<AsyncMcClient> client_;$/;"	m	class:__anon42::TestClient	file:
client_	.\routes\DestinationRoute.h	/^  std::shared_ptr<const ProxyClientCommon> client_;$/;"	m	class:facebook::memcache::mcrouter::DestinationRoute
client_	.\server.cpp	/^  mcrouter_client_t* client_;$/;"	m	class:facebook::memcache::mcrouter::__anon60::ServerOnRequest	file:
client_	.\test\cpp_unit_tests\mcrouter_test_client.h	/^  facebook::memcache::mcrouter::mcrouter_client_t *client_;$/;"	m	class:facebook::memcache::test::MCRouterTestClient
client_list	.\_router.h	/^  mcrouter_client_list_t client_list;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
client_list_lock	.\_router.h	/^  std::mutex client_list_lock;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
clients	.\PoolFactory.cpp	/^PoolFactory::clients() const {$/;"	f	class:facebook::memcache::mcrouter::PoolFactory
clients	.\proxy.h	/^  std::vector<std::weak_ptr<ProxyClientCommon>> clients;$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
clientsMap	.\ProxyConfig.h	/^  clientsMap() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyConfig
clients_	.\PoolFactory.h	/^                     std::shared_ptr<const ProxyClientCommon>> clients_;$/;"	m	class:facebook::memcache::mcrouter::PoolFactory
clone	.\ProxyMcRequest.cpp	/^ProxyMcRequest ProxyMcRequest::clone() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyMcRequest
clone	.\lib\McMsgRef.h	/^  Ref clone() const {$/;"	f	class:facebook::memcache::Ref
clone	.\lib\McRequest.h	/^  McRequest clone() const {$/;"	f	class:facebook::memcache::McRequest
clone	.\lib\McRequestWithContext-inl.h	/^McRequestWithContext<Ctx> McRequestWithContext<Ctx>::clone() const {$/;"	f	class:facebook::memcache::McRequestWithContext
cloneInto	.\lib\IOBufUtil.h	/^inline bool cloneInto(folly::IOBuf& out, const folly::IOBuf& source,$/;"	f	namespace:facebook::memcache
cloneRef	.\lib\McMsgRef.h	/^  static Ref cloneRef(T* ref) {$/;"	f	class:facebook::memcache::Ref
close	.\lib\network\McServerSession.cpp	/^void McServerSession::close() {$/;"	f	class:facebook::memcache::McServerSession
closeNow	.\lib\network\AsyncMcClient-inl.h	/^inline void AsyncMcClient::closeNow() {$/;"	f	class:facebook::memcache::AsyncMcClient
closeNow	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::closeNow() {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
closeSession	.\lib\network\test\SessionTestHarness.h	/^  void closeSession() {$/;"	f	class:facebook::memcache::SessionTestHarness
cluster	.\PoolFactory.h	/^    std::string cluster;$/;"	m	struct:facebook::memcache::mcrouter::PoolFactory::Options
cluster_	.\RoutingPrefix.h	/^  folly::StringPiece cluster_;$/;"	m	class:facebook::memcache::mcrouter::RoutingPrefix
cmd_all_stats	.\stats.h	/^  cmd_all_stats        =        0x4,$/;"	e	enum:facebook::memcache::mcrouter::stat_group_t
cmd_error_stats	.\stats.h	/^  cmd_error_stats      =       0x20,$/;"	e	enum:facebook::memcache::mcrouter::stat_group_t
cmd_in_stats	.\stats.h	/^  cmd_in_stats         =        0x8,$/;"	e	enum:facebook::memcache::mcrouter::stat_group_t
cmd_out_stats	.\stats.h	/^  cmd_out_stats        =       0x10,$/;"	e	enum:facebook::memcache::mcrouter::stat_group_t
cnt	.\lib\fbi\counting_sem.h	/^  int32_t cnt;$/;"	m	struct:counting_sem_s
cnt	.\lib\fbi\waitable_count.h	/^  unsigned cnt;$/;"	m	struct:waitable_counter
cnt	.\test\cpp_unit_tests\awriter_test.cpp	/^  AtomicCounter cnt;$/;"	m	struct:counts	file:
cnt	.\test\cpp_unit_tests\awriter_test.cpp	/^  int cnt;$/;"	m	class:AtomicCounter	file:
coalesceAndGetRange	.\lib\IOBufUtil.cpp	/^folly::StringPiece coalesceAndGetRange(folly::IOBuf& buf) {$/;"	f	namespace:facebook::memcache
coalesceAndGetRange	.\lib\IOBufUtil.cpp	/^folly::StringPiece coalesceAndGetRange(std::unique_ptr<folly::IOBuf>& buf) {$/;"	f	namespace:facebook::memcache
code	.\lib\fbi\error.h	/^  int code; \/\/!< Error code.$/;"	m	struct:fbi_err_s
coldNcache	.\lib\routes\WarmUpRoute.h	/^  static Request coldNcache(const Request& origReq, size_t ncacheExptime) {$/;"	f	class:facebook::memcache::WarmUpRoute
coldUpdateFromWarm	.\lib\routes\WarmUpRoute.h	/^  static Request coldUpdateFromWarm(const Request& origReq,$/;"	f	class:facebook::memcache::WarmUpRoute
cold_	.\lib\routes\WarmUpRoute.h	/^  std::shared_ptr<RouteHandleIf> cold_;$/;"	m	class:facebook::memcache::WarmUpRoute
command_args	.\_router.h	/^  char* command_args;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
commands_	.\ServiceInfo.cpp	/^  commands_;$/;"	m	struct:facebook::memcache::mcrouter::ServiceInfo::ServiceInfoImpl	file:
commonInit	.\lib\routes\LatestRoute.h	/^  void commonInit(std::vector<std::shared_ptr<RouteHandleIf>> targets,$/;"	f	class:facebook::memcache::LatestRoute
compEQ	.\lib\fbi\skiplist.c	27;"	d	file:
compGE	.\lib\fbi\skiplist.c	28;"	d	file:
compLT	.\lib\fbi\skiplist.c	26;"	d	file:
compat_overflow_on_signal	.\lib\fbi\test\asox_sem_test.cpp	/^bool compat_overflow_on_signal(asox_sem_t sem,$/;"	f	namespace:__anon21
completeWrite	.\lib\network\McServerSession.cpp	/^void McServerSession::completeWrite() {$/;"	f	class:facebook::memcache::McServerSession
completed	.\awriter.h	/^  void (*completed)(awriter_entry_t*, int);$/;"	m	struct:facebook::memcache::mcrouter::awriter_callbacks_t
component	.\lib\fbi\debug.c	/^  const char *component;$/;"	m	struct:msg_info	file:
component_to_file	.\lib\fbi\debug.c	/^static const char *component_to_file(const char *component)$/;"	f	file:
concatAll	.\lib\IOBufUtil.h	/^folly::IOBuf concatAll(InputIterator begin, InputIterator end) {$/;"	f	namespace:facebook::memcache
concurrent_queueing	.\lib\fbi\test\asox_queue_test.cpp	/^std::vector<std::unique_ptr<Info>> concurrent_queueing(asox_queue_t queue,$/;"	f	namespace:__anon19
cond	.\test\cpp_unit_tests\awriter_test.cpp	/^  pthread_cond_t cond;$/;"	m	class:AtomicCounter	file:
config	.\test\test_ascii_error.py	/^    config = '.\/mcrouter\/test\/mcrouter_test_basic_1_1_1.json'$/;"	v	class:TestAsciiError
config	.\test\test_async_files.py	/^    config = '.\/mcrouter\/test\/mcrouter_test_basic_1_1_1.json'$/;"	v	class:TestAsyncFiles
config	.\test\test_const_shard_hash.py	/^    config = '.\/mcrouter\/test\/test_const_shard_hash.json'$/;"	v	class:TestConstShardHash
config	.\test\test_empty_pool.py	/^    config = '.\/mcrouter\/test\/test_empty_pool.json'$/;"	v	class:TestEmptyPool
config	.\test\test_largeobj.py	/^    config = '.\/mcrouter\/test\/test_largeobj.json'$/;"	v	class:TestLargeObj
config	.\test\test_logical_routing_policies.py	/^    config = '.\/mcrouter\/test\/test_logical_routing_policies.json'$/;"	v	class:TestLogicalRoutingPolicies
config	.\test\test_max_shadow_requests.py	/^    config = '.\/mcrouter\/test\/test_max_shadow_requests.json'$/;"	v	class:TestServerStatsOutstandingRequests
config	.\test\test_mcrouter.py	/^    config = '.\/mcrouter\/test\/test_dev_null.json'$/;"	v	class:TestDevNull
config	.\test\test_mcrouter.py	/^    config = '.\/mcrouter\/test\/test_duplicate_servers.json'$/;"	v	class:TestDuplicateServers
config	.\test\test_mcrouter.py	/^    config = '.\/mcrouter\/test\/test_duplicate_servers_difftimeouts.json'$/;"	v	class:TestDuplicateServersDiffTimeouts
config	.\test\test_mcrouter.py	/^    config = '.\/mcrouter\/test\/test_get_failover.json'$/;"	v	class:TestGetFailover
config	.\test\test_mcrouter.py	/^    config = '.\/mcrouter\/test\/test_get_failover.json'$/;"	v	class:TestLeaseGetFailover
config	.\test\test_mcrouter.py	/^    config = '.\/mcrouter\/test\/test_get_failover.json'$/;"	v	class:TestMetaGetFailover
config	.\test\test_mcrouter.py	/^    config = '.\/mcrouter\/test\/test_get_failover_with_failover_tag.json'$/;"	v	class:TestGetFailoverWithFailoverTag
config	.\test\test_mcrouter.py	/^    config = '.\/mcrouter\/test\/test_migrated_pools.json'$/;"	v	class:TestMigratedPools
config	.\test\test_mcrouter.py	/^    config = '.\/mcrouter\/test\/test_migrated_pools_failover.json'$/;"	v	class:TestMigratedPoolsFailover
config	.\test\test_mcrouter.py	/^    config = '.\/mcrouter\/test\/test_same_pool_failover.json'$/;"	v	class:TestSamePoolFailover
config	.\test\test_mcrouter.py	/^    config = '.\/mcrouter\/test\/test_server_list_from_another_pool.json'$/;"	v	class:TestServerListFromAnotherPool
config	.\test\test_mcrouter_basic.py	/^    config = '.\/mcrouter\/test\/mcrouter_test_basic_1_1_1.json'$/;"	v	class:TestMcrouterBasic
config	.\test\test_mcrouter_basic.py	/^    config = '.\/mcrouter\/test\/mcrouter_test_basic_1_1_1.json'$/;"	v	class:TestMcrouterInvalidRoute
config	.\test\test_mcrouter_basic.py	/^    config = '.\/mcrouter\/test\/mcrouter_test_basic_2_1_1.json'$/;"	v	class:TestMcrouterBasic2
config	.\test\test_mcrouter_basic.py	/^    config = '.\/mcrouter\/test\/test_basic_all_first.json'$/;"	v	class:TestBasicAllFirst
config	.\test\test_mcrouter_basic.py	/^    config = '.\/mcrouter\/test\/test_basic_all_majority.json'$/;"	v	class:TestBasicAllMajority
config	.\test\test_mcrouter_basic.py	/^    config = '.\/mcrouter\/test\/test_basic_all_sync.json'$/;"	v	class:TestBasicAllSync
config	.\test\test_mcrouter_basic.py	/^    config = '.\/mcrouter\/test\/test_basic_failover.json'$/;"	v	class:TestBasicFailover
config	.\test\test_mcrouter_basic.py	/^    config = '.\/mcrouter\/test\/test_basic_failover_override.json'$/;"	v	class:TestBasicFailoverOverride
config	.\test\test_mcrouter_basic.py	/^    config = '.\/mcrouter\/test\/test_basic_l1_l2.json'$/;"	v	class:TestMcrouterBasicL1L2
config	.\test\test_mcrouter_sanity.py	/^    config = '.\/mcrouter\/test\/test_ascii.json'$/;"	v	class:TestMcrouterSanity
config	.\test\test_mcrouter_sanity.py	/^    config = '.\/mcrouter\/test\/test_umbrella.json'$/;"	v	class:TestMcrouterSanityOverUmbrella
config	.\test\test_migrated_failover.py	/^    config = '.\/mcrouter\/test\/test_migrated_failover.json'$/;"	v	class:TestMigratedFailover
config	.\test\test_miss_on_error_arith_ops.py	/^    config = '.\/mcrouter\/test\/test_miss_on_error_arith_ops.json'$/;"	v	class:TestMissOnErrorArithOps
config	.\test\test_noreply.py	/^    config = '.\/mcrouter\/test\/test_noreply.json'$/;"	v	class:TestNoreply
config	.\test\test_probe_timeout.py	/^    config = '.\/mcrouter\/test\/test_probe_timeout.json'$/;"	v	class:TestProbeTimeout
config	.\test\test_rates.py	/^    config = '.\/mcrouter\/test\/test_rates.json'$/;"	v	class:TestRates
config	.\test\test_reliable_pool_policy.py	/^    config = '.\/mcrouter\/test\/test_reliable_pool_policy.json'$/;"	v	class:TestReliablePoolPolicy
config	.\test\test_routing_prefixes.py	/^    config = '.\/mcrouter\/test\/routing_prefix_test_ascii.json'$/;"	v	class:TestMcrouterRoutingPrefixAscii
config	.\test\test_routing_prefixes.py	/^    config = '.\/mcrouter\/test\/routing_prefix_test_umbrella.json'$/;"	v	class:TestMcrouterRoutingPrefixUmbrella
config	.\test\test_send_to_all_hosts.py	/^    config = '.\/mcrouter\/test\/test_send_to_all_hosts.json'$/;"	v	class:TestSendToAllHosts
config	.\test\test_server_stats.py	/^    config = '.\/mcrouter\/test\/test_server_stats_pending.json'$/;"	v	class:TestServerStatsOutstandingRequests
config	.\test\test_service_info.py	/^    config = '.\/mcrouter\/test\/test_service_info.json'$/;"	v	class:TestServiceInfo
config	.\test\test_shadow.py	/^    config = '.\/mcrouter\/test\/test_shadow.json'$/;"	v	class:TestShadow
config	.\test\test_shadow_with_file.py	/^    config = '.\/mcrouter\/test\/test_shadow_with_file.json'$/;"	v	class:TestShadowWithFile
config	.\test\test_shard_splits.py	/^    config = '.\/mcrouter\/test\/test_shard_splits.json'$/;"	v	class:TestShardSplits
config	.\test\test_slow_box_tko.py	/^    config = '.\/mcrouter\/test\/test_slow_box_tko.json'$/;"	v	class:TestSlowBoxTko
config	.\test\test_umbrella_server.py	/^    config = '.\/mcrouter\/test\/test_umbrella_server.json'$/;"	v	class:TestUmbrellaServer
config	.\test\test_warmup.py	/^    config = '.\/mcrouter\/test\/test_warmup.json'$/;"	v	class:TestWarmup
config	.\test\test_wch3.py	/^    config = '.\/mcrouter\/test\/test_wch3.json'$/;"	v	class:TestWCH3
configApi	.\_router.h	/^  std::unique_ptr<ConfigApi> configApi;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
configApi_	.\PoolFactory.h	/^  ConfigApi* configApi_;$/;"	m	class:facebook::memcache::mcrouter::PoolFactory
configApi_	.\routes\McImportResolver.h	/^  ConfigApi* configApi_;$/;"	m	class:facebook::memcache::mcrouter::McImportResolver
configData_	.\RuntimeVarsData.h	/^  std::unordered_map<std::string, folly::dynamic> configData_;$/;"	m	class:facebook::memcache::mcrouter::RuntimeVarsData
configLock_	.\proxy.h	/^  SFRLock configLock_;$/;"	m	struct:facebook::memcache::mcrouter::proxy_t
configMd5Digest_	.\ProxyConfig.h	/^  std::string configMd5Digest_;$/;"	m	class:facebook::memcache::mcrouter::ProxyConfig
configMd5Digest_	.\ProxyConfigBuilder.h	/^  std::string configMd5Digest_;$/;"	m	class:facebook::memcache::mcrouter::ProxyConfigBuilder
configString	.\test\cpp_unit_tests\libmcrouter_test.cpp	/^std::string configString;$/;"	v
configThreadRun	.\ConfigApi.cpp	/^void ConfigApi::configThreadRun() {$/;"	f	class:facebook::memcache::mcrouter::ConfigApi
configThread_	.\ConfigApi.h	/^  std::thread configThread_;$/;"	m	class:facebook::memcache::mcrouter::ConfigType::ConfigApi
configUpdateHandle_	.\_router.h	/^  ConfigApi::CallbackHandle configUpdateHandle_;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
config_	.\ProxyRequestContext.h	/^  std::shared_ptr<const ProxyConfigIf> config_;$/;"	m	class:facebook::memcache::mcrouter::ProxyRequestContext
config_	.\proxy.h	/^  std::shared_ptr<ProxyConfigIf> config_;$/;"	m	struct:facebook::memcache::mcrouter::old_config_req_t
config_	.\proxy.h	/^  std::shared_ptr<ProxyConfigIf> config_;$/;"	m	struct:facebook::memcache::mcrouter::proxy_t
config_failures	.\_router.h	/^  int config_failures;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
config_mc	.\test\test_umbrella_server.py	/^    config_mc = '.\/mcrouter\/test\/test_umbrella_server_mc.json'$/;"	v	class:TestUmbrellaServer
config_noservers	.\test\test_probe_timeout.py	/^    config_noservers = '.\/mcrouter\/test\/test_probe_timeout_reconfig.json'$/;"	v	class:TestProbeTimeout
config_reconfig_lock	.\_router.h	/^  std::mutex config_reconfig_lock;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
connect	.\test\MCProcess.py	/^    def connect(self):$/;"	m	class:MCProcess
connectTcpServer	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^int MemcacheLocal::connectTcpServer(const string& hostname,$/;"	f	class:facebook::memcache::test::MemcacheLocal
connectTimeout	.\routes\FailoverWithExptimeRouteIf.h	/^  OperationSettings connectTimeout;$/;"	m	struct:facebook::memcache::mcrouter::FailoverWithExptimeSettings
connectToLocalPort	.\test\cpp_unit_tests\libmcrouter_test.cpp	/^int connectToLocalPort(uint16_t port) {$/;"	f	namespace:__anon65
connectionErrorTest	.\lib\network\test\AsyncMcClientTest.cpp	/^void connectionErrorTest(bool useSsl = false) {$/;"	f
connectionOptions_	.\lib\network\AsyncMcClientImpl.h	/^  ConnectionOptions connectionOptions_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
consecutiveFailureCount	.\TkoTracker.h	/^  size_t consecutiveFailureCount() const {$/;"	f	class:facebook::memcache::mcrouter::TkoTracker
const_iterator	.\lib\fbi\cpp\Trie.h	/^  typedef iterator_base<const Trie, const value_type> const_iterator;$/;"	t	class:facebook::memcache::Trie
const_pointer	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  typedef typename std::allocator<T>::const_pointer const_pointer;$/;"	t	struct:TestAllocator	file:
construct_arg_string	.\main.cpp	/^char* construct_arg_string(int argc, char **argv) {$/;"	f
consts_	.\lib\config\ConfigPreprocessor.h	/^  std::unordered_map<std::string, std::unique_ptr<Const>> consts_;$/;"	m	class:facebook::memcache::ConfigPreprocessor
consume	.\AtomicTokenBucket.h	/^  bool consume(double toConsume, double nowInSeconds = defaultClockNow()) {$/;"	f	class:facebook::memcache::mcrouter::AtomicTokenBucket
consume	.\AtomicTokenBucket.h	/^  bool consume(double toConsume,$/;"	f	class:facebook::memcache::mcrouter::DynamicAtomicTokenBucket
consume	.\TokenBucket.h	/^  bool consume(double toConsume, double nowInSeconds) {$/;"	f	class:facebook::memcache::mcrouter::TokenBucket
consume	.\lib\fbi\test\sem_test.cpp	/^void consume(int id, int X) {$/;"	f
consume_nonblocking	.\lib\fbi\test\sem_test.cpp	/^void consume_nonblocking(int id, int X) {$/;"	f
containerSingleton	.\lib\fbi\cpp\LogFailure.cpp	/^folly::Singleton<StaticContainer> containerSingleton;$/;"	m	namespace:facebook::memcache::failure::__anon9	file:
containsMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic containsMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
contents	.\async.cpp	/^  std::string contents;$/;"	m	struct:facebook::memcache::mcrouter::__anon1::write_file_entry_t	file:
context	.\awriter.h	/^  void *context;$/;"	m	struct:facebook::memcache::mcrouter::awriter_entry_t
context	.\lib\McRequestWithContext-inl.h	/^McRequestWithContext<Ctx>::context() const {$/;"	f	class:facebook::memcache::McRequestWithContext
context	.\lib\mc\msg.h	/^  void *context; \/\/\/< get\/set key, stats arg, flushre regexp$/;"	m	struct:mc_msg_s
context	.\lib\mc\parser.h	/^  void *context;$/;"	m	struct:parser_s
context	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^  std::shared_ptr<SSLContext> context;$/;"	m	struct:facebook::memcache::ContextInfo	file:
context	.\proxy.h	/^  void *context;$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t
context	.\router.cpp	/^  void* context;$/;"	m	struct:facebook::memcache::mcrouter::__anon56::mcrouter_queue_entry_t	file:
context	.\router.h	/^  void *context;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_msg_t
contextPtr	.\lib\McRequestWithContext-inl.h	/^std::shared_ptr<Ctx> McRequestWithContext<Ctx>::contextPtr() const {$/;"	f	class:facebook::memcache::McRequestWithContext
context_	.\lib\fibers\AddTasks.h	/^  std::shared_ptr<Context> context_;$/;"	m	class:facebook::memcache::fiber::TaskIterator
context_	.\lib\fibers\BoostContextCompatibility.h	/^  ContextStruct context_;$/;"	m	struct:facebook::memcache::FContext
context_	.\lib\fibers\BoostContextCompatibility.h	/^  ContextStruct* context_;$/;"	m	struct:facebook::memcache::FContext
contexts	.\lib\fbi\cpp\LogFailure.cpp	/^  std::map<std::string, std::string> contexts;$/;"	m	struct:facebook::memcache::failure::__anon9::StaticContainer	file:
continueSendReply	.\proxy.cpp	/^void proxy_request_t::continueSendReply() {$/;"	f	class:facebook::memcache::mcrouter::proxy_request_t
controller_	.\lib\fibers\EventBaseLoopController-inl.h	/^  EventBaseLoopController& controller_;$/;"	m	class:facebook::memcache::mcrouter::EventBaseLoopController::ControllerCallback
copy	.\lib\StatsReply.cpp	/^void copy(nstring_t& to, folly::StringPiece from,$/;"	f	namespace:facebook::memcache::__anon44
copyInto	.\lib\IOBufUtil.cpp	/^void copyInto(char* raw, const folly::IOBuf& buf) {$/;"	f	namespace:facebook::memcache
corkedOutput_	.\lib\network\test\SessionTestHarness.cpp	/^  std::string corkedOutput_;$/;"	m	class:facebook::memcache::MockAsyncSocket	file:
couldRouteTo	.\lib\RouteHandleIf.h	/^  couldRouteTo(const Request& req,$/;"	f	class:facebook::memcache::RouteHandle
couldRouteTo	.\lib\routes\AllAsyncRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::AllAsyncRoute
couldRouteTo	.\lib\routes\AllFastestRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::AllFastestRoute
couldRouteTo	.\lib\routes\AllInitialRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::AllInitialRoute
couldRouteTo	.\lib\routes\AllMajorityRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::AllMajorityRoute
couldRouteTo	.\lib\routes\AllSyncRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::AllSyncRoute
couldRouteTo	.\lib\routes\ErrorRoute.h	/^  static std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	struct:facebook::memcache::ErrorRoute
couldRouteTo	.\lib\routes\FailoverRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::FailoverRoute
couldRouteTo	.\lib\routes\HashRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::HashRoute
couldRouteTo	.\lib\routes\HostIdRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::HostIdRoute
couldRouteTo	.\lib\routes\LatestRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::LatestRoute
couldRouteTo	.\lib\routes\MigrateRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::MigrateRoute
couldRouteTo	.\lib\routes\MissFailoverRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::MissFailoverRoute
couldRouteTo	.\lib\routes\NullRoute.h	/^  static std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	struct:facebook::memcache::NullRoute
couldRouteTo	.\lib\routes\WarmUpRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::WarmUpRoute
couldRouteTo	.\lib\test\RouteHandleTestUtil.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	struct:facebook::memcache::RecordingRoute
couldRouteTo	.\routes\AsynclogRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::mcrouter::AsynclogRoute
couldRouteTo	.\routes\BigValueRoute-inl.h	/^BigValueRoute<RouteHandleIf>::couldRouteTo(const Request& req,$/;"	f	class:facebook::memcache::BigValueRoute
couldRouteTo	.\routes\DestinationRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::mcrouter::DestinationRoute
couldRouteTo	.\routes\DevNullRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::mcrouter::DevNullRoute
couldRouteTo	.\routes\FailoverWithExptimeRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::mcrouter::FailoverWithExptimeRoute
couldRouteTo	.\routes\PrefixPolicyRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::mcrouter::PrefixPolicyRoute
couldRouteTo	.\routes\ProxyRoute.h	/^  std::vector<McrouterRouteHandlePtr> couldRouteTo($/;"	f	class:facebook::memcache::mcrouter::ProxyRoute
couldRouteTo	.\routes\RateLimitRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::mcrouter::RateLimitRoute
couldRouteTo	.\routes\ReliablePoolRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::mcrouter::ReliablePoolRoute
couldRouteTo	.\routes\RootRoute.h	/^  std::vector<McrouterRouteHandlePtr> couldRouteTo($/;"	f	class:facebook::memcache::mcrouter::RootRoute
couldRouteTo	.\routes\ShadowRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::mcrouter::ShadowRoute
couldRouteTo	.\routes\ShardSplitRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> couldRouteTo($/;"	f	class:facebook::memcache::mcrouter::ShardSplitRoute
count	.\lib\fbi\examples\thread-errs.c	/^  int count;$/;"	m	struct:blob_s	file:
count	.\lib\fbi\log_limit.c	/^static int head = 0, tail = 0, count = 0;$/;"	v	file:
count	.\lib\fbi\nstring.h	/^  size_t count;$/;"	m	struct:nstring_map_s
count	.\lib\fbi\nstring.h	/^  size_t count;$/;"	m	struct:nstring_map_sorted_iter_s
count	.\lib\fbi\test\asox_queue_test.cpp	/^  int count;$/;"	m	struct:__anon19::Info	file:
count_	.\lib\fbi\cpp\StartupLock.h	/^  size_t count_;$/;"	m	class:facebook::memcache::StartupLock
count_elem_ready	.\lib\fbi\test\asox_queue_test.cpp	/^void count_elem_ready(asox_queue_t q, asox_queue_entry_t *entry, void *arg) {$/;"	f	namespace:__anon17
count_stats	.\stats.h	/^  count_stats          =      0x200,$/;"	e	enum:facebook::memcache::mcrouter::stat_group_t
countedfd_new	.\async.cpp	/^static std::shared_ptr<folly::File> countedfd_new(int fd) {$/;"	f	namespace:facebook::memcache::mcrouter
counter	.\routes\test\ReliablePoolRouteTest.cpp	/^static int counter = 0;$/;"	v	file:
counter	.\test\cpp_unit_tests\awriter_test.cpp	/^  counts *counter;$/;"	m	struct:testing_context_t	file:
counter_add	.\lib\fbi\counter.h	/^static inline void counter_add(counter_t *counter, int64_t delta) {$/;"	f
counter_add_nonlocked	.\lib\fbi\counter.h	/^static inline void counter_add_nonlocked(counter_t *counter, int64_t delta) {$/;"	f
counter_compute_slot	.\lib\fbi\counter.c	/^int counter_compute_slot() {$/;"	f
counter_deflate_nonlocked	.\lib\fbi\counter.h	/^static inline void counter_deflate_nonlocked(counter_t *counter) {$/;"	f
counter_get	.\lib\fbi\counter.c	/^int64_t counter_get(const counter_t *counter) {$/;"	f
counter_get_total_inflations	.\lib\fbi\counter.c	/^int counter_get_total_inflations() {$/;"	f
counter_inflated_s	.\lib\fbi\counter.h	/^typedef struct counter_inflated_s {$/;"	s
counter_inflated_t	.\lib\fbi\counter.h	/^} counter_inflated_t;$/;"	t	typeref:struct:counter_inflated_s
counter_s	.\lib\fbi\counter.h	/^typedef struct counter_s {$/;"	s
counter_slot_cache	.\lib\fbi\counter.c	/^__thread int counter_slot_cache;$/;"	v
counter_t	.\lib\fbi\counter.h	/^} counter_t;$/;"	t	typeref:struct:counter_s
counter_test_callbacks	.\lib\fbi\test\asox_queue_test.cpp	/^asox_queue_callbacks_t counter_test_callbacks = {$/;"	m	namespace:__anon18	file:
counter_try_inflate	.\lib\fbi\counter.c	/^void counter_try_inflate(counter_t *counter) {$/;"	f
counters	.\lib\fbi\test\counter_test.cpp	/^  counter_t *counters;$/;"	m	struct:test_params_s	file:
counting_sem_init	.\lib\fbi\counting_sem.c	/^void counting_sem_init(counting_sem_t* sem, int32_t val) {$/;"	f
counting_sem_lazy_helper	.\lib\fbi\counting_sem.c	/^static int32_t counting_sem_lazy_helper(counting_sem_t* sem, int32_t n,$/;"	f	file:
counting_sem_lazy_nonblocking	.\lib\fbi\counting_sem.c	/^int32_t counting_sem_lazy_nonblocking(counting_sem_t* sem, int32_t n) {$/;"	f
counting_sem_lazy_wait	.\lib\fbi\counting_sem.c	/^int32_t counting_sem_lazy_wait(counting_sem_t* sem, int32_t n) {$/;"	f
counting_sem_post	.\lib\fbi\counting_sem.c	/^void counting_sem_post(counting_sem_t* sem, int32_t n) {$/;"	f
counting_sem_s	.\lib\fbi\counting_sem.h	/^typedef struct counting_sem_s {$/;"	s
counting_sem_t	.\lib\fbi\counting_sem.h	/^} counting_sem_t;$/;"	t	typeref:struct:counting_sem_s
counting_sem_value	.\lib\fbi\counting_sem.c	/^int32_t counting_sem_value(counting_sem_t* sem) {$/;"	f
counts	.\lib\fbi\counter.h	/^    int64_t counts[COUNTER_INFLATED_SIZE];$/;"	m	struct:counter_inflated_s
counts	.\lib\fbi\test\asox_queue_test.cpp	/^struct counts {$/;"	s	namespace:__anon18	file:
counts	.\test\cpp_unit_tests\awriter_test.cpp	/^  counts() { success = failure = 0; }$/;"	f	struct:counts
counts	.\test\cpp_unit_tests\awriter_test.cpp	/^struct counts {$/;"	s	file:
cow_realloc	.\lib\mc\umbrella.c	/^static inline void *cow_realloc(void *old_ptr, ssize_t old_size, int allocated,$/;"	f	file:
cpu_frequency_MHz	.\lib\fbi\timer.c	/^static double cpu_frequency_MHz;$/;"	v	file:
crc32_hash	.\lib\fbi\hash.c	/^uint32_t crc32_hash(const char* const key, const size_t len) {$/;"	f
crc32tab	.\lib\fbi\hash.c	/^static const unsigned int crc32tab[256] = {$/;"	v	file:
create	.\AccessPoint.cpp	/^bool AccessPoint::create(folly::StringPiece host_port_protocol,$/;"	f	class:facebook::memcache::mcrouter::AccessPoint
create	.\ProxyDestination.cpp	/^std::shared_ptr<ProxyDestination> ProxyDestination::create($/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
create	.\lib\config\RouteHandleFactory-inl.h	/^RouteHandleFactory<RouteHandleIf>::create(const folly::dynamic& json) {$/;"	f	class:facebook::memcache::RouteHandleFactory
create	.\lib\config\RouteHandleProvider-inl.h	/^RouteHandleProvider<RouteHandleIf>::create($/;"	f	class:facebook::memcache::RouteHandleProvider
create	.\lib\network\AsyncMcClientImpl.cpp	/^std::shared_ptr<AsyncMcClientImpl> AsyncMcClientImpl::create($/;"	f	class:facebook::memcache::AsyncMcClientImpl
create	.\lib\network\McServerSession.cpp	/^McServerSession& McServerSession::create($/;"	f	class:facebook::memcache::McServerSession
create	.\routes\McRouteHandleProvider.cpp	/^std::vector<McrouterRouteHandlePtr> McRouteHandleProvider::create($/;"	f	class:facebook::memcache::mcrouter::McRouteHandleProvider
createChunkKey	.\routes\BigValueRoute-inl.h	/^folly::IOBuf BigValueRoute<RouteHandleIf>::createChunkKey($/;"	f	class:facebook::memcache::BigValueRoute
createConfigApi	.\mcrouter_config.cpp	/^std::unique_ptr<ConfigApi> createConfigApi(const McrouterOptions& opts) {$/;"	f	namespace:facebook::memcache::mcrouter
createEmptyRequest	.\lib\McRequest.h	/^createEmptyRequest(Operation, const McRequest& req) {$/;"	f	namespace:facebook::memcache
createEmptyRequest	.\lib\McRequestWithContext.h	/^createEmptyRequest(Operation, const McRequestWithContext<Ctx>& req) {$/;"	f	namespace:facebook::memcache
createExtraRouteHandleProvider	.\mcrouter_config.cpp	/^std::unique_ptr<ExtraRouteHandleProviderIf> createExtraRouteHandleProvider() {$/;"	f	namespace:facebook::memcache::mcrouter
createHash	.\lib\config\RouteHandleProvider-inl.h	/^RouteHandleProvider<RouteHandleIf>::createHash($/;"	f	class:facebook::memcache::RouteHandleProvider
createHash	.\routes\McRouteHandleProvider.cpp	/^McrouterRouteHandlePtr McRouteHandleProvider::createHash($/;"	f	class:facebook::memcache::mcrouter::McRouteHandleProvider
createList	.\lib\config\RouteHandleFactory-inl.h	/^RouteHandleFactory<RouteHandleIf>::createList(const folly::dynamic& json) {$/;"	f	class:facebook::memcache::RouteHandleFactory
createListenSocket	.\lib\network\test\TestUtil.h	/^inline int createListenSocket() {$/;"	f	namespace:facebook::memcache
createMcMsgRef	.\lib\McMsgRef.h	/^inline MutableMcMsgRef createMcMsgRef(const McMsgRef& ref,$/;"	f	namespace:facebook::memcache
createMcMsgRef	.\lib\McMsgRef.h	/^inline MutableMcMsgRef createMcMsgRef(const folly::StringPiece& key) {$/;"	f	namespace:facebook::memcache
createMcMsgRef	.\lib\McMsgRef.h	/^inline MutableMcMsgRef createMcMsgRef(const folly::StringPiece& key,$/;"	f	namespace:facebook::memcache
createMcMsgRef	.\lib\McMsgRef.h	/^inline MutableMcMsgRef createMcMsgRef(size_t extra_size = 0) {$/;"	f	namespace:facebook::memcache
createMcrouterLogger	.\mcrouter_config.cpp	/^std::unique_ptr<McrouterLogger> createMcrouterLogger(mcrouter_t* router) {$/;"	f	namespace:facebook::memcache::mcrouter
createMessage	.\lib\fbi\cpp\LogFailure.cpp	/^std::string createMessage(folly::StringPiece service,$/;"	f	namespace:facebook::memcache::failure::__anon9
createRouterLogger	.\mcrouter_config.cpp	/^std::shared_ptr<RouterLogger> createRouterLogger() {$/;"	f	namespace:facebook::memcache::mcrouter
createTCPKeepAliveOptions	.\lib\network\AsyncMcClientImpl.cpp	/^apache::thrift::async::TAsyncSocket::OptionMap createTCPKeepAliveOptions($/;"	f	namespace:facebook::memcache::__anon37
create_listen_socket	.\test\MCProcess.py	/^def create_listen_socket():$/;"	f
ctx	.\LoggingProxyRequestContext.h	/^  const ProxyRequestContext& ctx() const {$/;"	f	class:facebook::memcache::mcrouter::LoggingProxyRequestContext
ctx	.\lib\network\test\SessionTestHarness.h	/^    McServerRequestContext ctx;$/;"	m	struct:facebook::memcache::SessionTestHarness::Transaction
ctx_	.\LoggingProxyRequestContext.h	/^  ProxyRequestContext ctx_;$/;"	m	class:facebook::memcache::mcrouter::LoggingProxyRequestContext
ctx_	.\lib\McRequestWithContext.h	/^  std::shared_ptr<Ctx> ctx_;$/;"	m	class:facebook::memcache::McRequestWithContext
ctx_	.\lib\network\WriteBuffer.h	/^  folly::Optional<McServerRequestContext> ctx_;$/;"	m	class:facebook::memcache::WriteBuffer
currentFiberManager_	.\lib\fibers\FiberManager.cpp	/^__thread FiberManager* FiberManager::currentFiberManager_ = nullptr;$/;"	m	class:facebook::memcache::FiberManager	file:
currentFiberManager_	.\lib\fibers\FiberManager.h	/^  static __thread FiberManager* currentFiberManager_;$/;"	m	class:facebook::memcache::FiberManager
currentMultiop_	.\lib\network\McServerSession.h	/^  std::shared_ptr<MultiOpParent> currentMultiop_;$/;"	m	class:facebook::memcache::McServerSession
cv	.\ProxyThread.h	/^  std::condition_variable cv;$/;"	m	class:facebook::memcache::mcrouter::ProxyThread
cvMutex_	.\PeriodicTaskScheduler.h	/^  std::mutex cvMutex_;$/;"	m	class:facebook::memcache::mcrouter::PeriodicTaskScheduler
cvMutex_	.\lib\fbi\cpp\StartupLock.h	/^  std::mutex cvMutex_;$/;"	m	class:facebook::memcache::StartupLock
cv_	.\PeriodicTaskScheduler.h	/^  std::condition_variable cv_;$/;"	m	class:facebook::memcache::mcrouter::PeriodicTaskScheduler
cv_	.\lib\fbi\cpp\StartupLock.h	/^  std::condition_variable cv_;$/;"	m	class:facebook::memcache::StartupLock
cwlock_init	.\lib\fbi\cwlock.c	/^void cwlock_init(cwlock_t *l) {$/;"	f
cwlock_lock	.\lib\fbi\cwlock.c	/^bool cwlock_lock(cwlock_t *l) {$/;"	f
cwlock_t	.\lib\fbi\cwlock.h	/^} cwlock_t;$/;"	t	typeref:struct:__anon11
cwlock_unlock	.\lib\fbi\cwlock.c	/^void cwlock_unlock(cwlock_t *l) {$/;"	f
cycle	.\lib\fbi\log_limit.c	/^static int cycle = 0;$/;"	v	file:
cycle_timer	.\lib\fbi\fb_cpu_util.h	/^static inline uint64_t cycle_timer(void) {$/;"	f
cycle_timer_func	.\lib\fbi\timer.c	/^fb_cycle_timer_func_t* cycle_timer_func = &cycle_timer;$/;"	v
d64fmt	.\lib\fbi\debug.h	28;"	d
daemonize	.\main.cpp	/^void daemonize() {$/;"	f
daemonize_process	.\lib\fbi\unix.h	/^static inline void daemonize_process() {$/;"	f
data	.\lib\fbi\asox_queue.h	/^  void *data;$/;"	m	struct:asox_queue_entry_s
data	.\lib\fbi\counter.h	/^    int64_t data; \/** n*2 if deflated, ptr+1 if inflated *\/$/;"	m	struct:counter_s
data	.\lib\mc\umbrella.h	/^  } data;$/;"	m	struct:um_elist_entry_s	typeref:union:um_elist_entry_s::__anon34
data	.\stats.h	/^  } data;$/;"	m	struct:facebook::memcache::mcrouter::stat_t	typeref:union:facebook::memcache::mcrouter::stat_t::__anon63
data	.\test\test_mcrouter_sanity.py	/^    def data(self, n):$/;"	m	class:TestMcrouterSanity
dataDelete_	.\lib\test\RouteHandleTestUtil.h	/^  DeleteRouteTestData dataDelete_;$/;"	m	struct:facebook::memcache::RecordingRoute
dataGet_	.\lib\test\RouteHandleTestUtil.h	/^  GetRouteTestData dataGet_;$/;"	m	struct:facebook::memcache::RecordingRoute
dataLock_	.\Observable.h	/^  SFRLock dataLock_;$/;"	m	class:facebook::memcache::mcrouter::Observable
dataLock_	.\lib\fbi\cpp\AtomicSharedPtr.h	/^  SFRLock dataLock_;$/;"	m	class:facebook::memcache::AtomicWrapper
dataTimeout	.\routes\FailoverWithExptimeRouteIf.h	/^  OperationSettings dataTimeout;$/;"	m	struct:facebook::memcache::mcrouter::FailoverWithExptimeSettings
dataUpdate_	.\lib\test\RouteHandleTestUtil.h	/^  UpdateRouteTestData dataUpdate_;$/;"	m	struct:facebook::memcache::RecordingRoute
data_	.\CallbackPool-inl.h	/^  std::shared_ptr<Data> data_;$/;"	m	struct:facebook::memcache::mcrouter::CallbackPool::CallbackHandleImpl
data_	.\CallbackPool.h	/^  std::shared_ptr<Data> data_;$/;"	m	class:facebook::memcache::mcrouter::CallbackPool
data_	.\Observable.h	/^  Data data_;$/;"	m	class:facebook::memcache::mcrouter::Observable
data_	.\lib\fbi\cpp\AtomicSharedPtr.h	/^  T data_;$/;"	m	class:facebook::memcache::AtomicWrapper
data_	.\lib\fibers\Fiber.h	/^  intptr_t data_;               \/**< Used to keep some data with the Fiber *\/$/;"	m	class:facebook::memcache::Fiber
data_	.\proxy.h	/^  AtomicSharedPtr<Data> data_;$/;"	m	struct:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t
dbg_at	.\lib\fbi\debug.h	124;"	d
dbg_critical	.\lib\fbi\debug.h	131;"	d
dbg_date_format	.\lib\fbi\debug.c	/^static fbi_date_format_t dbg_date_format = fbi_date_default;$/;"	v	file:
dbg_debug	.\lib\fbi\debug.h	136;"	d
dbg_error	.\lib\fbi\debug.h	128;"	d
dbg_error	.\lib\fbi\debug.h	132;"	d
dbg_exit	.\lib\fbi\debug.c	/^void dbg_exit() {$/;"	f
dbg_fentry	.\lib\fbi\debug.h	126;"	d
dbg_fexit	.\lib\fbi\debug.h	127;"	d
dbg_high	.\lib\fbi\debug.h	140;"	d
dbg_info	.\lib\fbi\debug.h	135;"	d
dbg_init	.\lib\fbi\debug.c	/^static FILE *dbg_init() {$/;"	f	file:
dbg_init_0	.\lib\fbi\debug.c	/^static FILE* dbg_init_0() {$/;"	f	file:
dbg_level	.\lib\fbi\debug.c	/^static uint dbg_level = FBI_LOG_DEFAULT;$/;"	v	file:
dbg_lock	.\lib\fbi\test\log_tid_tests.cpp	/^static sem_t dbg_lock;$/;"	v	file:
dbg_log	.\lib\fbi\debug.h	103;"	d
dbg_log_file	.\lib\fbi\debug.c	/^FILE* dbg_log_file = NULL; \/\/ Not static for testing (heisenberg_tao_shims.cpp)$/;"	v
dbg_log_fname	.\lib\fbi\debug.c	/^static nstring_t* dbg_log_fname = NULL;$/;"	v	file:
dbg_low	.\lib\fbi\debug.h	138;"	d
dbg_medium	.\lib\fbi\debug.h	139;"	d
dbg_notify	.\lib\fbi\debug.h	134;"	d
dbg_perror	.\lib\fbi\debug.h	129;"	d
dbg_spew	.\lib\fbi\debug.h	137;"	d
dbg_warning	.\lib\fbi\debug.h	133;"	d
dbgs	.\lib\fbi\test\log_tid_tests.cpp	/^static void* dbgs(void* arg) {$/;"	f	file:
dbl	.\stats.h	/^    double dbl;$/;"	m	union:facebook::memcache::mcrouter::stat_t::__anon63
deallocate	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  void deallocate(pointer p, size_type n) {$/;"	f	struct:TestAllocator
deallocate	.\lib\fbi\nstring.h	/^  void (*deallocate)(void*);$/;"	m	struct:nstring_map_s
deallocate	.\lib\fibers\GuardPageAllocator-inl.h	/^void GuardPageAllocator::deallocate(unsigned char* up, size_t size) {$/;"	f	class:facebook::memcache::GuardPageAllocator
debugLockGuard	.\lib\fbi\test\log_tid_tests.cpp	/^static DebugLockGuard debugLockGuard;$/;"	v	file:
decompressed_sz	.\lib\mc\msg.c	/^  uint32_t decompressed_sz;$/;"	m	struct:nzlib_format_s	file:
decr	.\test\MCProcess.py	/^    def decr(self, key, value=1, noreply=False):$/;"	m	class:MCProcess
decref	.\lib\McMsgRef.h	/^  static void decref(const mc_msg_t* msg) {$/;"	f	struct:facebook::memcache::McMsgRefPolicy
decref	.\lib\McRequestBase.h	/^    static void decref(mc_fbtrace_info_t* info) {$/;"	f	struct:facebook::memcache::McRequestBase::McFbtraceRefPolicy
decref	.\lib\test\RequestReplyTest.cpp	/^  static mc_msg_t* decref(mc_msg_t* msg) {$/;"	f	struct:TestRefPolicy
decrefs	.\lib\test\RequestReplyTest.cpp	/^static unordered_map<mc_msg_t*, int> increfs, decrefs;$/;"	v	file:
decrementSoftTkoCount	.\TkoTracker.cpp	/^void TkoTracker::decrementSoftTkoCount() {$/;"	f	class:facebook::memcache::mcrouter::TkoTracker
defaultClockNow	.\AtomicTokenBucket.h	/^  static double defaultClockNow() {$/;"	f	class:facebook::memcache::mcrouter::AtomicTokenBucket
defaultClockNow	.\AtomicTokenBucket.h	/^  static double defaultClockNow() {$/;"	f	class:facebook::memcache::mcrouter::DynamicAtomicTokenBucket
defaultClockNow	.\TokenBucket.h	/^  static double defaultClockNow() {$/;"	f	class:facebook::memcache::mcrouter::TokenBucket
defaultPolicy_	.\routes\PrefixPolicyRoute.h	/^  std::shared_ptr<RouteHandleIf> defaultPolicy_;$/;"	m	class:facebook::memcache::mcrouter::PrefixPolicyRoute
defaultRoute_	.\routes\RouteHandleMap.h	/^  const RoutingPrefix& defaultRoute_;$/;"	m	class:facebook::memcache::mcrouter::RouteHandleMap
defaultTestCommandLineArgs	.\mcrouter_config.cpp	/^std::vector<std::string> defaultTestCommandLineArgs() {$/;"	f	namespace:facebook::memcache::mcrouter
defaultTestOptions	.\mcrouter_config.cpp	/^McrouterOptions defaultTestOptions() {$/;"	f	namespace:facebook::memcache::mcrouter
default_value	.\options.h	/^  std::string default_value;$/;"	m	struct:facebook::memcache::McrouterOptionData
defaultdict	.\test\test_wch3.py	/^from collections import defaultdict$/;"	i
del	.\lib\network\test\MockMc.cpp	/^bool MockMc::del(folly::StringPiece key) {$/;"	f	class:facebook::memcache::MockMc
del	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^int MCRouterTestClient::del(const dynamic &keys, bool local,$/;"	f	class:MCRouterTestClient
delay	.\lib\fbi\examples\thread-errs.c	/^  timeval_t delay;$/;"	m	struct:blob_s	file:
delay_reply	.\proxy.h	/^  int delay_reply;$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t
delete	.\test\MCProcess.py	/^    def delete(self, key, noreply=False):$/;"	m	class:MCProcess
delete_req	.\lib\mc\umbrella_protocol.c	60;"	d	file:
delete_time	.\proxy.h	/^  int delete_time;$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
deletesTb_	.\routes\RateLimiter.h	/^  folly::Optional<TokenBucket> deletesTb_;$/;"	m	class:facebook::memcache::mcrouter::RateLimiter
delta	.\lib\McReplyBase.h	/^  uint64_t delta() const {$/;"	f	class:facebook::memcache::McReplyBase
delta	.\lib\McRequestBase.h	/^  uint64_t delta() const {$/;"	f	class:facebook::memcache::McRequestBase
delta	.\lib\mc\msg.h	/^  uint64_t delta; \/\/\/< arithmetic$/;"	m	struct:mc_msg_s
dependentHelper	.\lib\McRequestBase.cpp	/^void McRequestBase::dependentHelper(mc_op_t op, folly::StringPiece key,$/;"	f	class:facebook::memcache::McRequestBase
dependentMcMsgRef	.\lib\McMsgRef.h	/^inline MutableMcMsgRef dependentMcMsgRef(const McMsgRef& ref) {$/;"	f	namespace:facebook::memcache
dependentMsg	.\lib\McReplyBase.cpp	/^void McReplyBase::dependentMsg(mc_op_t op, mc_msg_t* out) const {$/;"	f	class:facebook::memcache::McReplyBase
dependentMsg	.\lib\McRequestBase.cpp	/^McMsgRef McRequestBase::dependentMsg(mc_op_t op) const {$/;"	f	class:facebook::memcache::McRequestBase
dependentMsgStripRoutingPrefix	.\lib\McRequestBase.cpp	/^McMsgRef McRequestBase::dependentMsgStripRoutingPrefix(mc_op_t op) const {$/;"	f	class:facebook::memcache::McRequestBase
dereference	.\lib\fbi\cpp\Trie-inl.h	/^  V& dereference() const {$/;"	f	class:facebook::memcache::Trie::iterator_base
dest_	.\ProxyMcReply.h	/^  std::shared_ptr<const ProxyClientCommon> dest_;$/;"	m	class:facebook::memcache::mcrouter::ProxyMcReply
destinationHandles_	.\routes\McRouteHandleProvider.h	/^                     McrouterRouteHandlePtr> destinationHandles_;$/;"	m	class:facebook::memcache::mcrouter::McRouteHandleProvider
destinationKey	.\ProxyDestination.h	/^  const std::string destinationKey;\/\/\/< always the same for a given (host, port)$/;"	m	struct:facebook::memcache::mcrouter::ProxyDestination
destinationMap	.\proxy.h	/^  std::unique_ptr<ProxyDestinationMap> destinationMap;$/;"	m	struct:facebook::memcache::mcrouter::proxy_t
destinationMap_	.\routes\McRouteHandleProvider.h	/^  ProxyDestinationMap& destinationMap_;$/;"	m	class:facebook::memcache::mcrouter::McRouteHandleProvider
destination_	.\routes\DestinationRoute.h	/^  std::shared_ptr<ProxyDestination> destination_;$/;"	m	class:facebook::memcache::mcrouter::DestinationRoute
destination_key	.\ProxyClientCommon.h	/^  std::string destination_key;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientCommon
destinationsLock_	.\ProxyDestinationMap.h	/^  std::mutex destinationsLock_;$/;"	m	class:facebook::memcache::mcrouter::ProxyDestinationMap
destinations_	.\ProxyDestinationMap.h	/^    destinations_;$/;"	m	class:facebook::memcache::mcrouter::ProxyDestinationMap
destinations_	.\routes\ReliablePoolRoute.h	/^  const std::vector<std::shared_ptr<RouteHandleIf>> destinations_;$/;"	m	class:facebook::memcache::mcrouter::ReliablePoolRoute
detail	.\lib\OperationTraits.h	/^namespace detail {$/;"	n	namespace:facebook::memcache
detail	.\lib\fbi\cpp\traits.h	/^namespace detail {$/;"	n	namespace:facebook::memcache
detail	.\lib\network\AsyncMcClientImpl.cpp	/^namespace detail {$/;"	n	namespace:facebook::memcache	file:
detail	.\lib\network\AsyncMcClientImpl.h	/^namespace detail {$/;"	n	namespace:facebook::memcache
detailed_stats	.\stats.h	/^  detailed_stats       =        0x2,$/;"	e	enum:facebook::memcache::mcrouter::stat_group_t
determineIfSampleKeyForViolet	.\lib\fbi\cpp\util.cpp	/^bool determineIfSampleKeyForViolet(uint32_t routingKeyHash,$/;"	f	namespace:facebook::memcache
devnull_asynclog	.\ProxyClientCommon.h	/^  bool devnull_asynclog;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientCommon
devnull_asynclog	.\proxy.h	/^  bool devnull_asynclog;$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
die	.\scripts\common.sh	/^die() { printf "%s: %s\\n" "$0" "$@"; exit 1; }$/;"	f
disable	.\routes\FailoverWithExptimeRouteIf.cpp	/^void FailoverWithExptimeSettings::OperationSettings::disable() {$/;"	f	class:facebook::memcache::mcrouter::FailoverWithExptimeSettings::OperationSettings
disconnect	.\test\MCProcess.py	/^    def disconnect(self):$/;"	m	class:MCProcess
disconnect_deferred	.\lib\fbi\asox_queue.c	/^  bool disconnect_deferred;$/;"	m	struct:asox_queue_s	file:
disconnected	.\mcrouter_client.h	/^  int disconnected;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_t
dispatchMcMsg	.\routes\ProxyRoute.h	/^  ProxyMcReply dispatchMcMsg($/;"	f	class:facebook::memcache::mcrouter::ProxyRoute
dispatchMcMsgHelper	.\routes\ProxyRoute.h	/^  ProxyMcReply dispatchMcMsgHelper($/;"	f	class:facebook::memcache::mcrouter::ProxyRoute
dispatchRequest	.\proxy.cpp	/^void proxy_t::dispatchRequest(proxy_request_t* preq) {$/;"	f	class:facebook::memcache::mcrouter::proxy_t
divMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic divMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
division	.\test\MCProcess.py	/^from __future__ import division$/;"	i
division	.\test\McrouterTestCase.py	/^from __future__ import division$/;"	i
division	.\test\mcrouter_config.py	/^from __future__ import division$/;"	i
division	.\test\mock_servers.py	/^from __future__ import division$/;"	i
division	.\test\test_ascii_error.py	/^from __future__ import division$/;"	i
division	.\test\test_async_files.py	/^from __future__ import division$/;"	i
division	.\test\test_bad_params.py	/^from __future__ import division$/;"	i
division	.\test\test_const_shard_hash.py	/^from __future__ import division$/;"	i
division	.\test\test_empty_pool.py	/^from __future__ import division$/;"	i
division	.\test\test_largeobj.py	/^from __future__ import division$/;"	i
division	.\test\test_logical_routing_policies.py	/^from __future__ import division$/;"	i
division	.\test\test_max_shadow_requests.py	/^from __future__ import division$/;"	i
division	.\test\test_mcrouter.py	/^from __future__ import division$/;"	i
division	.\test\test_mcrouter_basic.py	/^from __future__ import division$/;"	i
division	.\test\test_mcrouter_sanity.py	/^from __future__ import division$/;"	i
division	.\test\test_migrated_failover.py	/^from __future__ import division$/;"	i
division	.\test\test_miss_on_error_arith_ops.py	/^from __future__ import division$/;"	i
division	.\test\test_multiple_ports.py	/^from __future__ import division$/;"	i
division	.\test\test_noreply.py	/^from __future__ import division$/;"	i
division	.\test\test_probe_timeout.py	/^from __future__ import division$/;"	i
division	.\test\test_rates.py	/^from __future__ import division$/;"	i
division	.\test\test_reliable_pool_policy.py	/^from __future__ import division$/;"	i
division	.\test\test_routing_prefixes.py	/^from __future__ import division$/;"	i
division	.\test\test_send_to_all_hosts.py	/^from __future__ import division$/;"	i
division	.\test\test_server_stats.py	/^from __future__ import division$/;"	i
division	.\test\test_service_info.py	/^from __future__ import division$/;"	i
division	.\test\test_shadow.py	/^from __future__ import division$/;"	i
division	.\test\test_shadow_with_file.py	/^from __future__ import division$/;"	i
division	.\test\test_shard_splits.py	/^from __future__ import division$/;"	i
division	.\test\test_slow_box_tko.py	/^from __future__ import division$/;"	i
division	.\test\test_umbrella_server.py	/^from __future__ import division$/;"	i
division	.\test\test_validate_config.py	/^from __future__ import division$/;"	i
division	.\test\test_warmup.py	/^from __future__ import division$/;"	i
division	.\test\test_wch3.py	/^from __future__ import division$/;"	i
dlognormal_variate	.\lib\fbi\test\hash_test.cpp	/^double dlognormal_variate(double mu, double sigma) {$/;"	f	namespace:__anon22
dnormal_variate	.\lib\fbi\test\hash_test.cpp	/^double dnormal_variate(double mu, double sigma) {$/;"	f	namespace:__anon22
doReverseTimeTest	.\test\cpp_unit_tests\TokenBucketTest.cpp	/^void doReverseTimeTest() {$/;"	f	namespace:__anon67
doRoute	.\routes\RootRoute.h	/^  typename ReplyType<Operation, Request>::type doRoute($/;"	f	class:facebook::memcache::mcrouter::RootRoute
doTokenBucketTest	.\test\cpp_unit_tests\TokenBucketTest.cpp	/^void doTokenBucketTest(double maxQps, double consumeSize) {$/;"	f	namespace:__anon67
do_messages	.\lib\fbi\test\log_coalesce_test.cpp	/^void *do_messages(void *p)$/;"	f	namespace:__anon23
do_msg	.\lib\fbi\test\log_coalesce_test.cpp	/^void do_msg() {$/;"	f	namespace:__anon23
docstring	.\options.h	/^  std::string docstring;$/;"	m	struct:facebook::memcache::McrouterOptionData
done	.\lib\fbi\test\counter_test.cpp	/^  std::atomic<bool> done;$/;"	m	struct:test_params_s	file:
double_precision	.\options.h	/^    double_precision,$/;"	m	class:facebook::memcache::McrouterOptionData::Type
drand	.\lib\fbi\test\hash_test.cpp	/^double drand() {$/;"	f	namespace:__anon22
drand_in_range	.\lib\fbi\test\hash_test.cpp	/^double drand_in_range(double low, double high) {$/;"	f	namespace:__anon22
drop_privileges_to	.\lib\fbi\unix.h	/^static inline int drop_privileges_to(const char *username) {$/;"	f
dump	.\test\MCProcess.py	/^    def dump(self):$/;"	m	class:MCProcess
dumpTree	.\ServiceInfo.cpp	/^inline void dumpTree(std::string& tree,$/;"	f	namespace:facebook::memcache::mcrouter::__anon61
eiov	.\lib\mc\umbrella.h	/^  extern_iov_t eiov;       \/\/ we allow only one external iov array for now$/;"	m	struct:entry_list_s
element_type	.\lib\fbi\cpp\AtomicSharedPtr.h	/^  typedef T element_type;$/;"	t	class:facebook::memcache::AtomicWrapper
elist	.\lib\mc\umbrella.h	/^  entry_list_t elist;$/;"	m	struct:um_backing_msg_s
emitIov	.\lib\mc\test\UmbrellaTest.cpp	/^int emitIov(void* ctxt, const void* buf, size_t len) {$/;"	f
emit_iov_cb	.\lib\mc\umbrella_protocol.h	/^typedef int (emit_iov_cb)(void* context, const void *buf, size_t len);$/;"	t
emplace	.\Observable-inl.h	/^void Observable<Data>::emplace(Args&&... args) {$/;"	f	class:facebook::memcache::mcrouter::Observable
emplace	.\lib\fbi\cpp\Trie-inl.h	/^void Trie<Value, MinChar, MaxChar>::emplace(folly::StringPiece key, Value val) {$/;"	f	class:facebook::memcache::Trie
emplace	.\mcrouter_config.h	/^  std::pair<iterator, bool> emplace(folly::StringPiece key, Args&&... args) {$/;"	f	class:facebook::memcache::mcrouter::StringKeyedUnorderedMap
empty	.\lib\fbi\cpp\AtomicLinkedList.h	/^  bool empty() const {$/;"	f	class:facebook::memcache::AtomicLinkedList
empty	.\lib\network\UniqueIntrusiveList.h	/^  bool empty() const { return list_.empty(); }$/;"	f	class:facebook::memcache::UniqueIntrusiveList
empty	.\lib\network\WriteBuffer.h	/^  bool empty() {$/;"	f	class:facebook::memcache::WriteBufferQueue
emptyContext_	.\lib\config\ConfigPreprocessor.cpp	/^const ConfigPreprocessor::Context ConfigPreprocessor::emptyContext_;$/;"	m	class:facebook::memcache::ConfigPreprocessor	file:
emptyContext_	.\lib\config\ConfigPreprocessor.h	/^  static const Context emptyContext_;$/;"	m	class:facebook::memcache::ConfigPreprocessor
emptyMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic emptyMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
emptyV_	.\routes\RouteHandleMap.h	/^  const std::vector<McrouterRouteHandlePtr> emptyV_;$/;"	m	class:facebook::memcache::mcrouter::RouteHandleMap
emptyV_	.\routes\RoutePolicyMap.h	/^  const std::vector<McrouterRouteHandlePtr> emptyV_;$/;"	m	class:facebook::memcache::mcrouter::RoutePolicyMap
end	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::end() const {$/;"	f	class:facebook::memcache::Trie
end	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::end() {$/;"	f	class:facebook::memcache::Trie
end	.\lib\network\UniqueIntrusiveList.h	/^  iterator end() { return list_.end(); }$/;"	f	class:facebook::memcache::UniqueIntrusiveList
end_	.\lib\network\MultiOpParent.h	/^  folly::Optional<McServerRequestContext> end_;$/;"	m	class:facebook::memcache::MultiOpParent
end_index	.\proxy.h	/^    size_t end_index;$/;"	m	struct:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t::Data
end_key_fraction	.\proxy.h	/^    double end_key_fraction;$/;"	m	struct:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t::Data
enqueueReply_	.\proxy.h	/^  void (*enqueueReply_)(proxy_request_t* preq);$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t
ensureClassVariables	.\test\McrouterTestCase.py	/^    def ensureClassVariables(self):$/;"	m	class:McrouterTestCase
ensureLoopScheduled	.\lib\fibers\FiberManager-inl.h	/^inline void FiberManager::ensureLoopScheduled() {$/;"	f	class:facebook::memcache::FiberManager
ensureMsgExists	.\lib\McRequestBase.cpp	/^void McRequestBase::ensureMsgExists(mc_op_t op) const {$/;"	f	class:facebook::memcache::McRequestBase
ensureWriteBufs	.\lib\network\McServerSession.cpp	/^bool McServerSession::ensureWriteBufs() {$/;"	f	class:facebook::memcache::McServerSession
ensure_connected	.\test\MCProcess.py	/^    def ensure_connected(self):$/;"	m	class:MCProcess
ensure_connected	.\test\mock_servers.py	/^    def ensure_connected(self):$/;"	m	class:MockServer
ensure_dir_exists_and_writeable	.\McrouterLogger.cpp	/^bool ensure_dir_exists_and_writeable(const std::string& path) {$/;"	f	namespace:facebook::memcache::mcrouter::__anon46
entries	.\lib\fbi\test\asox_queue_test.cpp	/^  asox_queue_entry_t *entries;$/;"	m	struct:__anon19::Info	file:
entries	.\lib\mc\umbrella.h	/^  um_elist_entry_t *entries;           \/\/ entries array$/;"	m	struct:entry_list_s
entries	.\lib\mc\umbrella.h	/^  um_elist_entry_t entries[0]; \/\/ The entries follow$/;"	m	struct:entry_list_msg_s
entries_	.\lib\network\UmbrellaProtocol.h	/^  um_elist_entry_t entries_[kInlineEntries];$/;"	m	class:facebook::memcache::UmbrellaSerializedReply
entries_allocated	.\lib\mc\umbrella.h	/^  uint32_t entries_allocated; \/\/ only free the entries array if we allocated it$/;"	m	struct:entry_list_s
entries_array	.\lib\mc\umbrella.h	/^  um_elist_entry_t entries_array[BMSG_ENTRIES_ARRAY_SIZE];$/;"	m	struct:um_backing_msg_s
entries_array_size	.\lib\mc\umbrella.c	/^static inline size_t entries_array_size(int num_entries) {$/;"	f	file:
entries_size	.\lib\mc\umbrella.h	/^  uint32_t entries_size;      \/\/ total entries array size$/;"	m	struct:entry_list_s
entry	.\lib\fbi\nstring.h	/^  nstring_map_entry_t entry;$/;"	m	struct:nstring_map_sorted_iter_s
entry	.\lib\fbi\nstring.h	/^  nstring_map_entry_t* entry;$/;"	m	struct:nstring_map_iter_s
entry	.\lib\fbi\timer.h	/^  TAILQ_ENTRY(fb_timer_s) entry;$/;"	m	struct:fb_timer_s
entry	.\mcrouter_client.h	/^  TAILQ_ENTRY(mcrouter_client_t) entry;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_t
entry_	.\lib\fibers\Fiber.h	/^  TAILQ_ENTRY(Fiber) entry_;    \/**< entry for different FiberManager queues *\/$/;"	m	class:facebook::memcache::Fiber
entry_	.\proxy.h	/^  TAILQ_ENTRY(proxy_request_t) entry_;$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t
entry_idx	.\lib\mc\umbrella.h	/^  int entry_idx;            \/\/ Which entry are we pointing to?$/;"	m	struct:extern_iov_s
entry_idx	.\lib\mc\umbrella.h	/^  int entry_idx;      \/\/ Which entry are we pointing to?$/;"	m	struct:extern_string_s
entry_list_append_CSTRING	.\lib\mc\umbrella.c	/^int entry_list_append_CSTRING(entry_list_t *elist,$/;"	f
entry_list_append_DOUBLE	.\lib\mc\umbrella.c	/^int entry_list_append_DOUBLE(entry_list_t *elist,$/;"	f
entry_list_append_int_like	.\lib\mc\umbrella.c	/^static inline int entry_list_append_int_like(entry_list_t *elist, entry_type_t type,$/;"	f	file:
entry_list_append_string_like	.\lib\mc\umbrella.c	/^static inline int entry_list_append_string_like(entry_list_t *elist,$/;"	f	file:
entry_list_cleanup	.\lib\mc\umbrella.c	/^void entry_list_cleanup(entry_list_t *elist) {$/;"	f
entry_list_consume_preparer	.\lib\mc\umbrella.c	/^ssize_t entry_list_consume_preparer(entry_list_t *elist,$/;"	f
entry_list_emit_iovs	.\lib\mc\umbrella.c	/^int entry_list_emit_iovs(entry_list_t* elist, emit_iov_cb* emit_iov,$/;"	f
entry_list_hdr_s	.\lib\mc\umbrella.h	/^typedef struct entry_list_hdr_s {$/;"	s
entry_list_hdr_t	.\lib\mc\umbrella.h	/^} entry_list_hdr_t;$/;"	t	typeref:struct:entry_list_hdr_s
entry_list_init	.\lib\mc\umbrella.c	/^int entry_list_init(entry_list_t *elist) {$/;"	f
entry_list_lazy_append_BSTRING	.\lib\mc\umbrella.c	/^int entry_list_lazy_append_BSTRING(entry_list_t *elist,$/;"	f
entry_list_lazy_append_CSTRING	.\lib\mc\umbrella.c	/^int entry_list_lazy_append_CSTRING(entry_list_t *elist,$/;"	f
entry_list_lazy_append_IOVEC	.\lib\mc\umbrella.c	/^int entry_list_lazy_append_IOVEC(entry_list_t* elist,$/;"	f
entry_list_lazy_append_string_like	.\lib\mc\umbrella.c	/^static inline int entry_list_lazy_append_string_like(entry_list_t *elist,$/;"	f	file:
entry_list_msg_body_size	.\lib\mc\umbrella.c	/^static inline size_t entry_list_msg_body_size(entry_list_msg_t *msg) {$/;"	f	file:
entry_list_msg_preparer_s	.\lib\mc\umbrella.h	/^typedef struct entry_list_msg_preparer_s {$/;"	s
entry_list_msg_preparer_t	.\lib\mc\umbrella.h	/^} entry_list_msg_preparer_t;$/;"	t	typeref:struct:entry_list_msg_preparer_s
entry_list_msg_s	.\lib\mc\umbrella.h	/^typedef struct entry_list_msg_s {$/;"	s
entry_list_msg_size	.\lib\mc\umbrella.c	/^static inline size_t entry_list_msg_size(entry_list_t *el) {$/;"	f	file:
entry_list_msg_t	.\lib\mc\umbrella.h	/^} __attribute__((__packed__))  entry_list_msg_t;$/;"	t	typeref:struct:entry_list_msg_s
entry_list_new_entry	.\lib\mc\umbrella.c	/^static inline int entry_list_new_entry(entry_list_t *elist) {$/;"	f	file:
entry_list_preparer_finished	.\lib\mc\umbrella.c	/^int entry_list_preparer_finished($/;"	f
entry_list_preparer_init	.\lib\mc\umbrella.c	/^void entry_list_preparer_init(entry_list_msg_preparer_t *prep) {$/;"	f
entry_list_preparer_read	.\lib\mc\umbrella.c	/^ssize_t entry_list_preparer_read(entry_list_msg_preparer_t *prep,$/;"	f
entry_list_preparer_reset_after_failure	.\lib\mc\umbrella.c	/^void entry_list_preparer_reset_after_failure($/;"	f
entry_list_read_from_buf	.\lib\mc\umbrella.c	/^ssize_t entry_list_read_from_buf(entry_list_t *elist, char *buf, size_t len,$/;"	f
entry_list_s	.\lib\mc\umbrella.h	/^typedef struct entry_list_s {$/;"	s
entry_list_t	.\lib\mc\umbrella.h	/^} entry_list_t;$/;"	t	typeref:struct:entry_list_s
entry_list_to_iovecs	.\lib\mc\umbrella.c	/^int entry_list_to_iovecs(entry_list_t *elist, struct iovec *vecs, int max) {$/;"	f
entry_list_write_to_buf	.\lib\mc\umbrella.c	/^ssize_t entry_list_write_to_buf(entry_list_t *elist, char *buf, ssize_t len) {$/;"	f
entry_type_e	.\lib\mc\umbrella.h	/^typedef enum entry_type_e {$/;"	g
entry_type_t	.\lib\mc\umbrella.h	/^} entry_type_t;$/;"	t	typeref:enum:entry_type_e
equal	.\lib\fbi\cpp\Trie-inl.h	/^  bool equal(const iterator_base& other) const {$/;"	f	class:facebook::memcache::Trie::iterator_base
equalsMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic equalsMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
erase	.\mcrouter_config.h	/^  size_type erase(folly::StringPiece key) {$/;"	f	class:facebook::memcache::mcrouter::StringKeyedUnorderedMap
err	.\lib\fbi\error.c	/^  fbi_err_t err;$/;"	m	struct:fbi_err_enclosure_s	file:
err_code	.\lib\mc\msg.h	/^  uint32_t err_code; \/\/\/< application specific error code$/;"	m	struct:mc_msg_s
err_thread	.\lib\fbi\examples\thread-errs.c	/^static void* err_thread(void* arg) {$/;"	f	file:
errno	.\test\MCProcess.py	/^import errno$/;"	i
errno	.\test\mock_servers.py	/^import errno$/;"	i
error	.\lib\mc\parser.h	/^  parser_error_t error;$/;"	m	struct:parser_s
error	.\lib\network\MultiOpParent.h	/^  bool error() const {$/;"	f	class:facebook::memcache::MultiOpParent
errorHelper	.\lib\network\McParser.cpp	/^void McParser::errorHelper(McReply reply) {$/;"	f	class:facebook::memcache::McParser
errorMsg	.\options.h	/^  std::string errorMsg;$/;"	m	struct:facebook::memcache::McrouterOptionError
error_context_key	.\lib\fbi\error.c	/^static pthread_key_t error_context_key;$/;"	v	file:
error_context_key_del	.\lib\fbi\error.c	/^static void error_context_key_del(void* arg) {$/;"	f	file:
error_context_key_new	.\lib\fbi\error.c	/^static void error_context_key_new() {$/;"	f	file:
error_context_key_once	.\lib\fbi\error.c	/^static pthread_once_t error_context_key_once = PTHREAD_ONCE_INIT;$/;"	v	file:
error_flush_cb	.\main.cpp	/^static void error_flush_cb(const fbi_err_t *err) {$/;"	f	file:
errs	.\lib\fbi\error.c	/^  _errs_t errs;$/;"	m	struct:_context_s	file:
estrings	.\lib\mc\umbrella.h	/^  extern_string_t estrings[MAX_EXTERN_STRINGS]; \/\/ external strings$/;"	m	struct:entry_list_s
evb_	.\ProxyThread.h	/^  folly::EventBase evb_;$/;"	m	class:facebook::memcache::mcrouter::ProxyThread
evb_	.\lib\network\AsyncMcServer.cpp	/^  folly::EventBase evb_;$/;"	m	class:facebook::memcache::McServerThread	file:
event	.\lib\fbi\asox_timer.c	/^  struct event event;$/;"	m	struct:_asox_timer_s	typeref:struct:_asox_timer_s::event	file:
eventBase	.\ProxyThread.h	/^  folly::EventBase& eventBase() { return evb_; }$/;"	f	class:facebook::memcache::mcrouter::ProxyThread
eventBase	.\lib\network\AsyncMcServer.cpp	/^  folly::EventBase& eventBase() {$/;"	f	class:facebook::memcache::McServerThread
eventBaseDestructionCallback_	.\lib\network\AsyncMcClientImpl.h	/^    eventBaseDestructionCallback_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
eventBase_	.\awriter.h	/^  folly::EventBase eventBase_;$/;"	m	class:facebook::memcache::mcrouter::AsyncWriter
eventBase_	.\lib\network\AsyncMcClientImpl.h	/^  folly::EventBase& eventBase_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
eventBase_	.\lib\network\AsyncMcServerWorker.h	/^  folly::EventBase& eventBase_;$/;"	m	class:facebook::memcache::AsyncMcServerWorker
eventBase_	.\lib\network\test\AsyncMcClientTest.cpp	/^  EventBase eventBase_;$/;"	m	class:__anon42::TestClient	file:
eventBase_	.\lib\network\test\SessionTestHarness.h	/^  folly::EventBase eventBase_;$/;"	m	class:facebook::memcache::SessionTestHarness
eventName	.\TkoLog.cpp	/^std::string TkoLog::eventName() const {$/;"	f	class:facebook::memcache::mcrouter::TkoLog
event_logger	.\lib\fbi\debug.c	/^event_logger(int severity, const char* msg) {$/;"	f	file:
event_priority_type_t	.\priorities.h	/^enum event_priority_type_t {$/;"	g	namespace:facebook::memcache::mcrouter
event_t	.\lib\fbi\asox_semaphore.c	/^typedef struct event event_t;$/;"	t	typeref:struct:event	file:
exceptionCallback_	.\lib\fibers\FiberManager.h	/^  ExceptionCallback exceptionCallback_; \/**< task exception callback *\/$/;"	m	class:facebook::memcache::FiberManager
expandMacros	.\lib\config\ConfigPreprocessor.cpp	/^dynamic ConfigPreprocessor::expandMacros(const dynamic& json,$/;"	f	class:facebook::memcache::ConfigPreprocessor
expandStringMacro	.\lib\config\ConfigPreprocessor.cpp	/^dynamic ConfigPreprocessor::expandStringMacro(StringPiece str,$/;"	f	class:facebook::memcache::ConfigPreprocessor
expectMainContext	.\lib\fibers\test\FibersTest.cpp	/^void expectMainContext(bool& ran, int* mainLocation, int* fiberLocation) {$/;"	f	namespace:__anon32
expectNoReply	.\test\MCProcess.py	/^    def expectNoReply(self):$/;"	m	class:MCProcess
expect_match	.\test\cpp_unit_tests\route_test.cpp	/^void expect_match(const string& p, const string& r) {$/;"	f
expect_no_match	.\test\cpp_unit_tests\route_test.cpp	/^void expect_no_match(const string& p, const string& r) {$/;"	f
expected	.\lib\mc\umbrella.h	/^  uint32_t expected;$/;"	m	struct:entry_list_msg_preparer_s
exponential_moving_avg	.\lib\fbi\timer.h	/^exponential_moving_avg(uint64_t avg, uint64_t x, int shift) {$/;"	f
exptime	.\lib\McReplyBase.h	/^  uint32_t exptime() const {$/;"	f	class:facebook::memcache::McReplyBase
exptime	.\lib\McRequestBase.cpp	/^uint32_t McRequestBase::exptime() const {$/;"	f	class:facebook::memcache::McRequestBase
exptime	.\lib\mc\msg.h	/^  uint32_t exptime;$/;"	m	struct:mc_msg_s
extern_iov_s	.\lib\mc\umbrella.h	/^typedef struct extern_iov_s {$/;"	s
extern_iov_t	.\lib\mc\umbrella.h	/^} extern_iov_t;$/;"	t	typeref:struct:extern_iov_s
extern_string_s	.\lib\mc\umbrella.h	/^typedef struct extern_string_s {$/;"	s
extern_string_t	.\lib\mc\umbrella.h	/^} extern_string_t;$/;"	t	typeref:struct:extern_string_s
extraProvider_	.\routes\McRouteHandleProvider.h	/^  std::unique_ptr<ExtraRouteHandleProviderIf> extraProvider_;$/;"	m	class:facebook::memcache::mcrouter::McRouteHandleProvider
extra_args	.\test\test_ascii_error.py	/^    extra_args = []$/;"	v	class:TestAsciiError
extra_args	.\test\test_async_files.py	/^    extra_args = ['--stats-logging-interval', '100', '--use-asynclog-version2']$/;"	v	class:TestAsyncFiles
extra_args	.\test\test_const_shard_hash.py	/^    extra_args = []$/;"	v	class:TestConstShardHash
extra_args	.\test\test_empty_pool.py	/^    extra_args = []$/;"	v	class:TestEmptyPool
extra_args	.\test\test_largeobj.py	/^    extra_args = []$/;"	v	class:TestLargeObj
extra_args	.\test\test_logical_routing_policies.py	/^    extra_args = []$/;"	v	class:TestLogicalRoutingPolicies
extra_args	.\test\test_max_shadow_requests.py	/^    extra_args = ['-t', '1000000', '--target-max-shadow-requests', '2']$/;"	v	class:TestServerStatsOutstandingRequests
extra_args	.\test\test_mcrouter.py	/^    extra_args = []$/;"	v	class:TestDevNull
extra_args	.\test\test_mcrouter.py	/^    extra_args = []$/;"	v	class:TestDuplicateServers
extra_args	.\test\test_mcrouter.py	/^    extra_args = []$/;"	v	class:TestDuplicateServersDiffTimeouts
extra_args	.\test\test_mcrouter.py	/^    extra_args = []$/;"	v	class:TestGetFailover
extra_args	.\test\test_mcrouter.py	/^    extra_args = []$/;"	v	class:TestLeaseGetFailover
extra_args	.\test\test_mcrouter.py	/^    extra_args = []$/;"	v	class:TestMetaGetFailover
extra_args	.\test\test_mcrouter.py	/^    extra_args = []$/;"	v	class:TestMigratedPools
extra_args	.\test\test_mcrouter.py	/^    extra_args = []$/;"	v	class:TestMigratedPoolsFailover
extra_args	.\test\test_mcrouter.py	/^    extra_args = []$/;"	v	class:TestSamePoolFailover
extra_args	.\test\test_mcrouter.py	/^    extra_args = []$/;"	v	class:TestServerListFromAnotherPool
extra_args	.\test\test_mcrouter_basic.py	/^    extra_args = ['--send-invalid-route-to-default']$/;"	v	class:TestMcrouterInvalidRoute
extra_args	.\test\test_mcrouter_basic.py	/^    extra_args = []$/;"	v	class:TestBasicAllFirst
extra_args	.\test\test_mcrouter_basic.py	/^    extra_args = []$/;"	v	class:TestBasicAllMajority
extra_args	.\test\test_mcrouter_basic.py	/^    extra_args = []$/;"	v	class:TestBasicAllSync
extra_args	.\test\test_mcrouter_basic.py	/^    extra_args = []$/;"	v	class:TestBasicFailover
extra_args	.\test\test_mcrouter_basic.py	/^    extra_args = []$/;"	v	class:TestBasicFailoverOverride
extra_args	.\test\test_mcrouter_basic.py	/^    extra_args = []$/;"	v	class:TestMcrouterBasic
extra_args	.\test\test_mcrouter_basic.py	/^    extra_args = []$/;"	v	class:TestMcrouterBasic2
extra_args	.\test\test_mcrouter_basic.py	/^    extra_args = []$/;"	v	class:TestMcrouterBasicL1L2
extra_args	.\test\test_migrated_failover.py	/^    extra_args = [$/;"	v	class:TestMigratedFailover
extra_args	.\test\test_miss_on_error_arith_ops.py	/^    extra_args = []$/;"	v	class:TestMissOnErrorArithOps
extra_args	.\test\test_probe_timeout.py	/^    extra_args = ['-t', '2000', '--timeouts-until-tko', '2', '-r', '100']$/;"	v	class:TestRequestTimeout
extra_args	.\test\test_probe_timeout.py	/^    extra_args = ['-t', '2000',$/;"	v	class:TestProbeTimeout
extra_args	.\test\test_rates.py	/^    extra_args = ['--destination-rate-limiting']$/;"	v	class:TestRates
extra_args	.\test\test_reliable_pool_policy.py	/^    extra_args = []$/;"	v	class:TestReliablePoolPolicy
extra_args	.\test\test_routing_prefixes.py	/^    extra_args = []$/;"	v	class:TestMcrouterRoutingPrefixAscii
extra_args	.\test\test_send_to_all_hosts.py	/^    extra_args = []$/;"	v	class:TestSendToAllHosts
extra_args	.\test\test_server_stats.py	/^    extra_args = ['-t', '1000000']$/;"	v	class:TestServerStatsOutstandingRequests
extra_args	.\test\test_service_info.py	/^    extra_args = []$/;"	v	class:TestServiceInfo
extra_args	.\test\test_shadow.py	/^    extra_args = []$/;"	v	class:TestShadow
extra_args	.\test\test_shadow_with_file.py	/^    extra_args = []$/;"	v	class:TestShadowWithFile
extra_args	.\test\test_shard_splits.py	/^    extra_args = []$/;"	v	class:TestShardSplits
extra_args	.\test\test_slow_box_tko.py	/^    extra_args = ['-t', '2500',$/;"	v	class:TestSlowBoxTko
extra_args	.\test\test_umbrella_server.py	/^    extra_args = []$/;"	v	class:TestUmbrellaServer
extra_args	.\test\test_validate_config.py	/^    extra_args = []$/;"	v	class:TestValidateConfig
extra_args	.\test\test_warmup.py	/^    extra_args = []$/;"	v	class:TestWarmup
extra_args	.\test\test_wch3.py	/^    extra_args = []$/;"	v	class:TestWCH3
extract	.\lib\network\UniqueIntrusiveList.h	/^  std::unique_ptr<T, TDeleter> extract(iterator it) {$/;"	f	class:facebook::memcache::UniqueIntrusiveList
f_	.\lib\config\ConfigPreprocessor.cpp	/^  Func f_;$/;"	m	class:facebook::memcache::ConfigPreprocessor::Macro	file:
facebook	.\AccessPoint.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\AccessPoint.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\AtomicTokenBucket.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\CallbackPool-inl.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\CallbackPool.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\ConfigApi.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\ConfigApi.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\DestinationClient.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\DestinationClient.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\ExponentialSmoothData.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\ExponentialSmoothData.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\FileDataProvider.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\FileDataProvider.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\FileObserver.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\FileObserver.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\LoggingProxyRequestContext.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\McrouterLogFailure.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\McrouterLogger.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\McrouterLogger.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\Observable-inl.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\Observable.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\PeriodicTaskScheduler.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\PeriodicTaskScheduler.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\PoolFactory.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\PoolFactory.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\PoolFactoryIf.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\ProxyClientCommon.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\ProxyClientCommon.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\ProxyConfig.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\ProxyConfig.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\ProxyConfigBuilder.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\ProxyConfigBuilder.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\ProxyConfigIf.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\ProxyDestination.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\ProxyDestination.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\ProxyDestinationMap.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\ProxyDestinationMap.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\ProxyMcReply.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\ProxyMcReply.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\ProxyMcRequest.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\ProxyMcRequest.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\ProxyRequestContext.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\ProxyRequestContext.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\ProxyRequestLogger-inl.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\ProxyRequestLogger.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\ProxyThread.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\ProxyThread.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\RecordingContext.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\RecordingContext.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\RoutingPrefix.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\RoutingPrefix.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\RuntimeVarsData.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\RuntimeVarsData.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\ServiceInfo.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\ServiceInfo.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\TkoCounters.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\TkoLog.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\TkoLog.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\TkoTracker.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\TkoTracker.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\TokenBucket.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\_router.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\async.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\async.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\awriter.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\flavor.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\flavor.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\lib\Ch3HashFunc.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\Crc32HashFunc.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\IOBufUtil.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\IOBufUtil.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\McMsgRef.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\McOperation.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\McOperationTraits.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\McReply.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\McReplyBase-inl.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\McReplyBase.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\McReplyBase.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\McRequest.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\McRequestBase.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\McRequestBase.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\McRequestWithContext-inl.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\McRequestWithContext.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\Operation.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\OperationTraits.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\Reply.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\RouteHandleIf.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\StatsReply.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\StatsReply.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\WeightedCh3HashFunc.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\WeightedCh3HashFunc.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\config\ConfigPreprocessor.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\config\ConfigPreprocessor.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\config\ImportResolverIf.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\config\RouteHandleBuilder.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\config\RouteHandleFactory-inl.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\config\RouteHandleFactory.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\config\RouteHandleProvider-inl.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\config\RouteHandleProvider.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\config\RouteHandleProviderIf.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fbi\cpp\AtomicLinkedList.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fbi\cpp\AtomicSharedPtr.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fbi\cpp\LogFailure.cpp	/^namespace facebook { namespace memcache { namespace failure {$/;"	n	file:
facebook	.\lib\fbi\cpp\LogFailure.h	/^namespace facebook { namespace memcache { namespace failure {$/;"	n
facebook	.\lib\fbi\cpp\ObjectPool.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fbi\cpp\ShutdownLock.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fbi\cpp\StartupLock.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fbi\cpp\Trie-inl.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fbi\cpp\Trie.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fbi\cpp\TypeList.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fbi\cpp\globals.cpp	/^namespace facebook { namespace memcache { namespace globals {$/;"	n	file:
facebook	.\lib\fbi\cpp\globals.h	/^namespace facebook { namespace memcache { namespace globals {$/;"	n
facebook	.\lib\fbi\cpp\traits.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fbi\cpp\util.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\fbi\cpp\util.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\AddTasks-inl.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n
facebook	.\lib\fibers\AddTasks.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n
facebook	.\lib\fibers\Baton-inl.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\Baton.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\fibers\Baton.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\BoostContextCompatibility.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\EventBaseLoopController-inl.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\lib\fibers\EventBaseLoopController.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\Fiber-inl.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\Fiber.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\fibers\Fiber.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\FiberManager-inl.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\FiberManager.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\fibers\FiberManager.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\FiberPromise-inl.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\FiberPromise.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\ForEach-inl.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n
facebook	.\lib\fibers\ForEach.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n
facebook	.\lib\fibers\GenericBaton.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\GuardPageAllocator-inl.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\GuardPageAllocator.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\LoopController.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\SimpleLoopController.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\TimeoutController.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\fibers\TimeoutController.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\fibers\WhenN-inl.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n
facebook	.\lib\fibers\WhenN.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n
facebook	.\lib\network\AsyncMcClient-inl.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\AsyncMcClient.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\AsyncMcClientImpl-inl.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\AsyncMcClientImpl.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\network\AsyncMcClientImpl.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\AsyncMcServer.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\network\AsyncMcServer.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\AsyncMcServerWorker.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\network\AsyncMcServerWorker.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\AsyncMcServerWorkerOptions.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\ConnectionOptions.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\McParser.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\network\McParser.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\McSerializedRequest.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\network\McSerializedRequest.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\McServerRequestContext-inl.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\McServerRequestContext.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\network\McServerRequestContext.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\McServerSession.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\network\McServerSession.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\MultiOpParent.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\network\MultiOpParent.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\network\ThreadLocalSSLContextProvider.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\UmbrellaProtocol.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\network\UmbrellaProtocol.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\UniqueIntrusiveList.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\WriteBuffer.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\network\WriteBuffer.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\test\MockMc.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\network\test\MockMc.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\test\SessionTestHarness.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\lib\network\test\SessionTestHarness.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\network\test\TestUtil.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\routes\AllAsyncRoute.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\routes\AllFastestRoute.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\routes\AllInitialRoute.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\routes\AllMajorityRoute.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\routes\AllSyncRoute.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\routes\ErrorRoute.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\routes\FailoverRoute.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\routes\HashRoute.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\routes\HostIdRoute.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\routes\LatestRoute.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\routes\MigrateRoute.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\routes\MissFailoverRoute.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\routes\NullRoute.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\routes\WarmUpRoute.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\test\RouteHandleTestUtil.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\test\TestRequest.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\lib\test\TestRouteHandle.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\mcrouter_client.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\mcrouter_config.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\mcrouter_config.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\options.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\options.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\pclient-inl.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\pclient.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\pclient.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\priorities.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\priorities.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\proxy.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\proxy.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\route.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\route.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\router.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\router.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\routes\AllAsyncRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\routes\AllFastestRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\routes\AllInitialRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\routes\AllMajorityRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\routes\AllSyncRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\routes\AsynclogRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\AsynclogRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\BigValueRoute-inl.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\routes\BigValueRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\BigValueRoute.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\routes\BigValueRouteIf.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\routes\DefaultShadowPolicy.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\DestinationRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\DestinationRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\DevNullRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\DevNullRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\ErrorRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\routes\ExtraRouteHandleProviderIf.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\FailoverRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\routes\FailoverWithExptimeRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\FailoverWithExptimeRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\FailoverWithExptimeRouteIf.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\FailoverWithExptimeRouteIf.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\HashRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\routes\HostIdRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\routes\LatestRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\routes\McExtraRouteHandleProvider.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\McExtraRouteHandleProvider.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\McImportResolver.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\McImportResolver.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\McOpList.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\routes\McRouteHandleBuilder.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\McRouteHandleProvider.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\McRouteHandleProvider.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\McrouterRouteHandle.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\MigrateRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\MissFailoverRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\routes\NullRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	file:
facebook	.\routes\PrefixPolicyRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\PrefixPolicyRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\PrefixRouteSelector.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\PrefixRouteSelector.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\routes\ProxyRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\RateLimitRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\RateLimitRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\RateLimiter.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\RateLimiter.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\ReliablePoolRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\ReliablePoolRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\RootRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\RouteHandleMap.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\RouteHandleMap.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\RoutePolicyMap.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\RoutePolicyMap.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\RouteSelectorMap.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\ShadowRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\ShadowRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\ShadowRouteIf.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\ShardHashFunc.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\ShardHashFunc.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\ShardSplitRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\ShardSplitRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\ShardSplitter.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\routes\ShardSplitter.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\TimeProviderFunc.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\routes\WarmUpRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\server.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\server.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\standalone_options.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\standalone_options.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n
facebook	.\stats.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	file:
facebook	.\stats.h	/^namespace facebook { namespace memcache {$/;"	n
facebook	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^namespace facebook { namespace memcache { namespace test {$/;"	n	file:
facebook	.\test\cpp_unit_tests\MemcacheLocal.h	/^namespace facebook { namespace memcache { namespace test {$/;"	n
facebook	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^namespace facebook { namespace memcache { namespace test {$/;"	n	file:
facebook	.\test\cpp_unit_tests\mcrouter_test_client.h	/^namespace facebook { namespace memcache {$/;"	n
failMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic failMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
failover	.\proxy.h	/^  std::vector<ProxyGenericPool*> failover[FAILOVER_MAX];$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
failoverCount_	.\routes\ReliablePoolRoute.h	/^  size_t failoverCount_;$/;"	m	class:facebook::memcache::mcrouter::ReliablePoolRoute
failoverExptime_	.\routes\FailoverWithExptimeRoute.h	/^  uint32_t failoverExptime_;$/;"	m	class:facebook::memcache::mcrouter::FailoverWithExptimeRoute
failoverRoute_	.\routes\ReliablePoolRoute.h	/^  const FailoverRoute<HashRoute<RouteHandleIf, HashFunc>> failoverRoute_;$/;"	m	class:facebook::memcache::mcrouter::ReliablePoolRoute
failover_	.\routes\FailoverWithExptimeRoute.h	/^  FailoverRoute<RouteHandleIf> failover_;$/;"	m	class:facebook::memcache::mcrouter::FailoverWithExptimeRoute
failover_common	.\test\test_mcrouter.py	/^    def failover_common(self, key):$/;"	m	class:TestGetFailover
failover_disabled	.\proxy.h	/^  int failover_disabled; \/\/\/< true if no failover allowed$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t
failover_exptime	.\proxy.h	/^  int failover_exptime;$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
failure	.\lib\fbi\cpp\LogFailure.cpp	/^namespace facebook { namespace memcache { namespace failure {$/;"	n	namespace:facebook::memcache	file:
failure	.\lib\fbi\cpp\LogFailure.h	/^namespace facebook { namespace memcache { namespace failure {$/;"	n	namespace:facebook::memcache
failure	.\test\cpp_unit_tests\awriter_test.cpp	/^  int failure;$/;"	m	struct:counts	file:
family	.\lib\fbi\network.h	/^  sa_family_t family;$/;"	m	struct:__anon13
family_info	.\lib\fbi\network.c	/^static fbi_family_info_t family_info[] = {$/;"	v	file:
fb_cycle_timer_func_t	.\lib\fbi\timer.h	/^typedef uint64_t fb_cycle_timer_func_t(void);$/;"	t
fb_record_time	.\lib\fbi\timer.h	/^static inline uint64_t fb_record_time(uint64_t start, uint64_t finish,$/;"	f
fb_timer_alloc	.\lib\fbi\timer.c	/^fb_timer_t* fb_timer_alloc(nstring_t name, int window_size,$/;"	f
fb_timer_cycle_timer	.\lib\fbi\timer.h	/^static inline uint64_t fb_timer_cycle_timer() {$/;"	f
fb_timer_finish	.\lib\fbi\timer.h	/^static inline uint64_t fb_timer_finish(fb_timer_t* timer) {$/;"	f
fb_timer_free	.\lib\fbi\timer.c	/^void fb_timer_free(fb_timer_t* timer) {$/;"	f
fb_timer_get_abs_min	.\lib\fbi\timer.c	/^double fb_timer_get_abs_min(fb_timer_t *timer){$/;"	f
fb_timer_get_all_timers	.\lib\fbi\timer.c	/^fb_timer_list_t fb_timer_get_all_timers() {$/;"	f
fb_timer_get_avg	.\lib\fbi\timer.c	/^double fb_timer_get_avg(fb_timer_t* timer) {$/;"	f
fb_timer_get_avg_min	.\lib\fbi\timer.c	/^double fb_timer_get_avg_min(fb_timer_t* timer){$/;"	f
fb_timer_get_avg_peak	.\lib\fbi\timer.c	/^double fb_timer_get_avg_peak(fb_timer_t* timer) {$/;"	f
fb_timer_get_num_timers	.\lib\fbi\timer.c	/^int fb_timer_get_num_timers() {$/;"	f
fb_timer_get_recent_min	.\lib\fbi\timer.c	/^double fb_timer_get_recent_min(fb_timer_t *timer){$/;"	f
fb_timer_get_recent_peak	.\lib\fbi\timer.c	/^double fb_timer_get_recent_peak(fb_timer_t* timer) {$/;"	f
fb_timer_get_total_time	.\lib\fbi\timer.c	/^double fb_timer_get_total_time(fb_timer_t* timer) {$/;"	f
fb_timer_init	.\lib\fbi\timer.c	/^static void fb_timer_init() {$/;"	f	file:
fb_timer_list_t	.\lib\fbi\timer.h	/^typedef TAILQ_HEAD(fb_timer_list, fb_timer_s) fb_timer_list_t;$/;"	t
fb_timer_output_type_t	.\lib\fbi\timer.h	/^} fb_timer_output_type_t;$/;"	t	typeref:enum:__anon25
fb_timer_record_finish	.\lib\fbi\timer.h	/^static inline void fb_timer_record_finish(fb_timer_t* timer, uint64_t start,$/;"	f
fb_timer_register	.\lib\fbi\timer.c	/^void fb_timer_register(fb_timer_t* timer) {$/;"	f
fb_timer_s	.\lib\fbi\timer.h	/^typedef struct fb_timer_s {$/;"	s
fb_timer_set_cycle_timer_func	.\lib\fbi\timer.c	/^void fb_timer_set_cycle_timer_func(fb_cycle_timer_func_t func,$/;"	f
fb_timer_start	.\lib\fbi\timer.h	/^static inline uint64_t fb_timer_start(fb_timer_t* timer) {$/;"	f
fb_timer_status_t	.\lib\fbi\timer.h	/^} fb_timer_status_t;$/;"	t	typeref:enum:__anon24
fb_timer_t	.\lib\fbi\timer.h	/^} fb_timer_t;$/;"	t	typeref:struct:fb_timer_s
fb_timer_t	.\proxy.h	/^typedef class fb_timer_s fb_timer_t;$/;"	t	typeref:class:fb_timer_s
fb_timer_to_nstring	.\lib\fbi\timer.c	/^void fb_timer_to_nstring(fb_timer_t* timer, nstring_t* vals) {$/;"	f
fb_timer_to_nstring_helper	.\lib\fbi\timer.c	/^static inline void fb_timer_to_nstring_helper(nstring_t* nstr, double value) {$/;"	f	file:
fbi_add_err	.\lib\fbi\error.c	/^void fbi_add_err(const char* source,$/;"	f
fbi_app_error	.\lib\fbi\error.h	/^  fbi_app_error = 2,$/;"	e	enum:fbi_errtype_e
fbi_clear_err	.\lib\fbi\error.c	/^void fbi_clear_err(fbi_err_t* err) {$/;"	f
fbi_data_format_e	.\lib\fbi\debug.h	/^typedef enum fbi_data_format_e {$/;"	g
fbi_date_default	.\lib\fbi\debug.h	/^  fbi_date_default  = 0,  \/* default is unix time stamps *\/$/;"	e	enum:fbi_data_format_e
fbi_date_format_t	.\lib\fbi\debug.h	/^} fbi_date_format_t;$/;"	t	typeref:enum:fbi_data_format_e
fbi_date_local	.\lib\fbi\debug.h	/^  fbi_date_local,         \/* human readable format in local time *\/$/;"	e	enum:fbi_data_format_e
fbi_date_max	.\lib\fbi\debug.h	/^  fbi_date_max$/;"	e	enum:fbi_data_format_e
fbi_date_unix	.\lib\fbi\debug.h	/^  fbi_date_unix     = 0,  \/* unix time *\/$/;"	e	enum:fbi_data_format_e
fbi_date_utc	.\lib\fbi\debug.h	/^  fbi_date_utc,           \/* human readable format in UTC *\/$/;"	e	enum:fbi_data_format_e
fbi_dbg_log	.\lib\fbi\debug.c	/^void fbi_dbg_log(const char *principal, const char* component,$/;"	f
fbi_err_alloc	.\lib\fbi\error.c	19;"	d	file:
fbi_err_del	.\lib\fbi\error.c	/^static inline void fbi_err_del(fbi_err_enclosure_t* err) {$/;"	f	file:
fbi_err_enclosure_s	.\lib\fbi\error.c	/^typedef struct fbi_err_enclosure_s {$/;"	s	file:
fbi_err_enclosure_t	.\lib\fbi\error.c	/^} fbi_err_enclosure_t;$/;"	t	typeref:struct:fbi_err_enclosure_s	file:
fbi_err_flush_cb	.\lib\fbi\error.h	/^typedef void (*fbi_err_flush_cb)(const fbi_err_t *err);$/;"	t
fbi_err_free	.\lib\fbi\error.c	20;"	d	file:
fbi_err_new	.\lib\fbi\error.c	/^static inline fbi_err_enclosure_t* fbi_err_new(const char* source,$/;"	f	file:
fbi_err_s	.\lib\fbi\error.h	/^typedef struct fbi_err_s {$/;"	s
fbi_err_t	.\lib\fbi\error.h	/^} fbi_err_t;$/;"	t	typeref:struct:fbi_err_s
fbi_errtype_e	.\lib\fbi\error.h	/^typedef enum fbi_errtype_e {$/;"	g
fbi_errtype_t	.\lib\fbi\error.h	/^} fbi_errtype_t;$/;"	t	typeref:enum:fbi_errtype_e
fbi_errtype_to_string	.\lib\fbi\error.h	/^static inline const char* fbi_errtype_to_string(const fbi_errtype_t type) {$/;"	f
fbi_expected	.\lib\fbi\util.h	16;"	d
fbi_family_info_t	.\lib\fbi\network.h	/^} fbi_family_info_t;$/;"	t	typeref:struct:__anon13
fbi_flush_errors	.\lib\fbi\error.c	/^static void fbi_flush_errors() {$/;"	f	file:
fbi_futex_wait	.\lib\fbi\util.h	19;"	d
fbi_futex_wake	.\lib\fbi\util.h	23;"	d
fbi_get_debug	.\lib\fbi\debug.c	/^uint fbi_get_debug() {return dbg_level;}$/;"	f
fbi_get_debug_logfile	.\lib\fbi\debug.c	/^const nstring_t* fbi_get_debug_logfile() {return dbg_log_fname;}$/;"	f
fbi_get_err	.\lib\fbi\error.c	/^fbi_err_t* fbi_get_err() {$/;"	f
fbi_get_err_enclosure	.\lib\fbi\error.c	/^static inline fbi_err_enclosure_t* fbi_get_err_enclosure(fbi_err_t* err) {$/;"	f	file:
fbi_get_last_err	.\lib\fbi\error.c	/^fbi_err_t* fbi_get_last_err() {$/;"	f
fbi_get_nerrs	.\lib\fbi\error.c	/^size_t fbi_get_nerrs() {$/;"	f
fbi_htonll	.\lib\fbi\util.h	/^static inline uint64_t fbi_htonll(uint64_t u64) {$/;"	f
fbi_htonll	.\lib\fbi\util.h	102;"	d
fbi_no_error	.\lib\fbi\error.h	/^  fbi_no_error = 0,$/;"	e	enum:fbi_errtype_e
fbi_nstring_alloc	.\lib\fbi\nstring.c	13;"	d	file:
fbi_nstring_cmp	.\lib\fbi\nstring.c	/^int fbi_nstring_cmp(const nstring_t* a, const nstring_t* b) {$/;"	f
fbi_nstring_copy	.\lib\fbi\nstring.c	/^void fbi_nstring_copy(nstring_t* dest,$/;"	f
fbi_nstring_cpy	.\lib\fbi\nstring.c	/^void fbi_nstring_cpy(nstring_t* dest, const nstring_t* src) {$/;"	f
fbi_nstring_dup	.\lib\fbi\nstring.c	/^nstring_t* fbi_nstring_dup(const nstring_t* a) {$/;"	f
fbi_nstring_free	.\lib\fbi\nstring.c	14;"	d	file:
fbi_nstring_hash	.\lib\fbi\nstring.c	/^uint32_t fbi_nstring_hash(const nstring_t* key) {$/;"	f
fbi_nstring_map_clear	.\lib\fbi\nstring.c	/^void fbi_nstring_map_clear(nstring_map_t* map) {$/;"	f
fbi_nstring_map_del	.\lib\fbi\nstring.c	/^void fbi_nstring_map_del(nstring_map_t* map) {$/;"	f
fbi_nstring_map_get	.\lib\fbi\nstring.c	/^const void* fbi_nstring_map_get(const nstring_map_t* map,$/;"	f
fbi_nstring_map_init	.\lib\fbi\nstring.c	/^void fbi_nstring_map_init(nstring_map_t* map,$/;"	f
fbi_nstring_map_iter_has_next	.\lib\fbi\nstring.c	/^int fbi_nstring_map_iter_has_next(const nstring_map_iter_t* iter) {$/;"	f
fbi_nstring_map_iter_init	.\lib\fbi\nstring.c	/^void fbi_nstring_map_iter_init(const nstring_map_t* map,$/;"	f
fbi_nstring_map_iter_is_valid	.\lib\fbi\nstring.c	/^int fbi_nstring_map_iter_is_valid(const nstring_map_iter_t* iter) {$/;"	f
fbi_nstring_map_iter_next	.\lib\fbi\nstring.c	/^nstring_map_entry_t* fbi_nstring_map_iter_next(nstring_map_iter_t *iter) {$/;"	f
fbi_nstring_map_new	.\lib\fbi\nstring.c	/^nstring_map_t* fbi_nstring_map_new(const size_t buckets,$/;"	f
fbi_nstring_map_prev	.\lib\fbi\nstring.c	/^nstring_map_entry_t** fbi_nstring_map_prev(nstring_map_t* map,$/;"	f
fbi_nstring_map_remove	.\lib\fbi\nstring.c	/^void fbi_nstring_map_remove(nstring_map_t* map,$/;"	f
fbi_nstring_map_set	.\lib\fbi\nstring.c	/^int fbi_nstring_map_set(nstring_map_t* map,$/;"	f
fbi_nstring_map_size	.\lib\fbi\nstring.c	/^size_t fbi_nstring_map_size(const nstring_map_t* map) {$/;"	f
fbi_nstring_map_sizeof	.\lib\fbi\nstring.c	/^size_t fbi_nstring_map_sizeof(const size_t buckets) {$/;"	f
fbi_nstring_ncmp	.\lib\fbi\nstring.c	/^int fbi_nstring_ncmp(const nstring_t* a,$/;"	f
fbi_nstring_safe	.\lib\fbi\nstring.c	/^const char* fbi_nstring_safe(const nstring_t* nstring) {$/;"	f
fbi_nstring_sizeof	.\lib\fbi\nstring.c	/^size_t fbi_nstring_sizeof(const size_t len) {$/;"	f
fbi_remote_error	.\lib\fbi\error.h	/^  fbi_remote_error = 3,$/;"	e	enum:fbi_errtype_e
fbi_set_assert_hook	.\lib\fbi\debug.c	/^void fbi_set_assert_hook(assert_hook_fn assert_hook) {$/;"	f
fbi_set_debug	.\lib\fbi\debug.c	/^void fbi_set_debug(const uint level) {dbg_level = level;}$/;"	f
fbi_set_debug_date_format	.\lib\fbi\debug.c	/^void fbi_set_debug_date_format(fbi_date_format_t fmt) {$/;"	f
fbi_set_debug_logfile	.\lib\fbi\debug.c	/^void fbi_set_debug_logfile(const nstring_t* value) {$/;"	f
fbi_set_err_flush_cb	.\lib\fbi\error.c	/^void fbi_set_err_flush_cb(fbi_err_flush_cb cb) {$/;"	f
fbi_swap_uint64_t	.\lib\fbi\util.h	/^static inline uint64_t fbi_swap_uint64_t(uint64_t u64) {$/;"	f
fbi_sys_error	.\lib\fbi\error.h	/^  fbi_sys_error = 1,$/;"	e	enum:fbi_errtype_e
fbi_test_htonll	.\lib\fbi\util.c	/^uint64_t fbi_test_htonll(uint64_t u64) {$/;"	f
fbi_test_next_pow2	.\lib\fbi\util.c	/^uint32_t fbi_test_next_pow2(uint32_t u32) {$/;"	f
fbi_test_swap_uint64_t	.\lib\fbi\util.c	/^uint64_t fbi_test_swap_uint64_t(uint64_t u64) {$/;"	f
fbi_unexpected	.\lib\fbi\util.h	17;"	d
fbi_unknown_error	.\lib\fbi\error.h	/^  fbi_unknown_error = 4,$/;"	e	enum:fbi_errtype_e
fbtrace	.\lib\mc\mc_fbtrace_info.h	/^  mc_fbtrace_t* fbtrace;$/;"	m	struct:mc_fbtrace_info_s
fbtraceInfo	.\lib\McRequestBase.h	/^  const mc_fbtrace_info_s* fbtraceInfo() const {$/;"	f	class:facebook::memcache::McRequestBase
fbtrace_idx	.\lib\mc\umbrella_protocol.c	/^  int fbtrace_idx;$/;"	m	struct:_parse_info_s	file:
fbtrace_info	.\lib\mc\msg.h	/^  struct mc_fbtrace_info_s* fbtrace_info;$/;"	m	struct:mc_msg_s	typeref:struct:mc_msg_s::mc_fbtrace_info_s
fcontext_	.\lib\fibers\Fiber.h	/^  FContext fcontext_;           \/**< current task execution context *\/$/;"	m	class:facebook::memcache::Fiber
fd_	.\lib\network\AsyncMcServer.cpp	/^  int fd_;$/;"	m	class:facebook::memcache::ShutdownPipe	file:
fetch	.\ProxyDestinationMap.cpp	/^ProxyDestinationMap::fetch(const ProxyClientCommon& client) {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestinationMap
fetchPool	.\PoolFactory.cpp	/^PoolFactory::fetchPool(folly::StringPiece poolName) {$/;"	f	class:facebook::memcache::mcrouter::PoolFactory
fetchPool	.\test\cpp_unit_tests\mc_route_handle_provider_test.cpp	/^  std::shared_ptr<ProxyGenericPool> fetchPool(folly::StringPiece poolName) {$/;"	f	class:MockPoolFactory
fetch_queue	.\lib\fbi\asox_queue.c	/^static asox_queue_entry_t *fetch_queue(asox_queue_t q,$/;"	f	file:
fiber	.\lib\fibers\AddTasks-inl.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n	namespace:facebook::memcache
fiber	.\lib\fibers\AddTasks.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n	namespace:facebook::memcache
fiber	.\lib\fibers\FiberManager.h	/^namespace fiber {$/;"	n	namespace:facebook::memcache
fiber	.\lib\fibers\ForEach-inl.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n	namespace:facebook::memcache
fiber	.\lib\fibers\ForEach.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n	namespace:facebook::memcache
fiber	.\lib\fibers\WhenN-inl.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n	namespace:facebook::memcache
fiber	.\lib\fibers\WhenN.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n	namespace:facebook::memcache
fiberFunc	.\lib\fibers\Fiber.cpp	/^void Fiber::fiberFunc() {$/;"	f	class:facebook::memcache::Fiber
fiberFuncHelper	.\lib\fibers\Fiber.cpp	/^void Fiber::fiberFuncHelper(intptr_t fiber) {$/;"	f	class:facebook::memcache::Fiber
fiberManager	.\lib\fibers\test\FibersTestApp.cpp	/^  FiberManager fiberManager;$/;"	m	struct:Application	file:
fiberManager	.\proxy.h	/^  FiberManager fiberManager;$/;"	m	struct:facebook::memcache::mcrouter::proxy_t
fiberManager_	.\awriter.h	/^  FiberManager fiberManager_;$/;"	m	class:facebook::memcache::mcrouter::AsyncWriter
fiberManager_	.\lib\fibers\Fiber.h	/^  FiberManager& fiberManager_;  \/**< Associated FiberManager *\/$/;"	m	class:facebook::memcache::Fiber
fibersAllocated	.\lib\fibers\FiberManager.cpp	/^size_t FiberManager::fibersAllocated() const {$/;"	f	class:facebook::memcache::FiberManager
fibersPoolSize	.\lib\fibers\FiberManager.cpp	/^size_t FiberManager::fibersPoolSize() const {$/;"	f	class:facebook::memcache::FiberManager
fibersPool_	.\lib\fibers\FiberManager.h	/^  FiberTailQHead fibersPool_;   \/**< pool of unitialized Fiber objects *\/$/;"	m	class:facebook::memcache::FiberManager
file	.\proxy.h	/^  std::shared_ptr<folly::File> file;$/;"	m	struct:facebook::memcache::mcrouter::writelog_entry_t
fileInfoMutex_	.\ConfigApi.h	/^  std::mutex fileInfoMutex_;$/;"	m	class:facebook::memcache::mcrouter::ConfigType::ConfigApi
fileInfos_	.\ConfigApi.h	/^  std::unordered_map<std::string, FileInfo> fileInfos_;$/;"	m	class:facebook::memcache::mcrouter::ConfigType::ConfigApi
filePath_	.\FileDataProvider.h	/^  const std::string filePath_;$/;"	m	class:facebook::memcache::mcrouter::FileDataProvider
file_entry_writer	.\async.cpp	/^int file_entry_writer(awriter_entry_t* e) {$/;"	f	namespace:facebook::memcache::mcrouter::__anon1
file_write_completed	.\async.cpp	/^static void file_write_completed(awriter_entry_t *awe, int result) {$/;"	f	namespace:facebook::memcache::mcrouter
fillMagic	.\lib\fibers\Fiber.cpp	/^static void fillMagic(const FContext& context) {$/;"	f	namespace:facebook::memcache::__anon29
finallyFunc_	.\lib\fibers\Fiber.h	/^  std::function<void()> finallyFunc_;$/;"	m	class:facebook::memcache::Fiber
finally_	.\lib\fibers\FiberManager-inl.h	/^    G finally_;$/;"	m	class:facebook::memcache::FiberManager::AddTaskFinallyHelper::Finally
find	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::find(folly::StringPiece key) const {$/;"	f	class:facebook::memcache::Trie
find	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::find(folly::StringPiece key) {$/;"	f	class:facebook::memcache::Trie
find	.\mcrouter_config.h	/^  const_iterator find(folly::StringPiece key) const {$/;"	f	class:facebook::memcache::mcrouter::StringKeyedUnorderedMap
find	.\mcrouter_config.h	/^  iterator find(folly::StringPiece key) {$/;"	f	class:facebook::memcache::mcrouter::StringKeyedUnorderedMap
findImpl	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::findImpl(folly::StringPiece key) const {$/;"	f	class:facebook::memcache::Trie
findPrefix	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::findPrefix(folly::StringPiece key) const {$/;"	f	class:facebook::memcache::Trie
findPrefix	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::findPrefix(folly::StringPiece key) {$/;"	f	class:facebook::memcache::Trie
findPrefixImpl	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::findPrefixImpl(folly::StringPiece key) const {$/;"	f	class:facebook::memcache::Trie
findUnescaped	.\lib\config\ConfigPreprocessor.cpp	/^size_t findUnescaped(folly::StringPiece str, char c, size_t start = 0) {$/;"	f	namespace:facebook::memcache::__anon4
findUnexpired	.\lib\network\test\MockMc.cpp	/^MockMc::findUnexpired(folly::StringPiece key) {$/;"	f	class:facebook::memcache::MockMc
finish_	.\ConfigApi.h	/^  std::atomic<bool> finish_;$/;"	m	class:facebook::memcache::mcrouter::ConfigType::ConfigApi
finished	.\lib\mc\umbrella.h	/^  int finished;$/;"	m	struct:entry_list_msg_preparer_s
firstChild_	.\lib\routes\AllInitialRoute.h	/^  std::shared_ptr<RouteHandleIf> firstChild_;$/;"	m	class:facebook::memcache::AllInitialRoute
flags	.\lib\McReplyBase.h	/^  uint64_t flags() const {$/;"	f	class:facebook::memcache::McReplyBase
flags	.\lib\McRequestBase.cpp	/^uint64_t McRequestBase::flags() const {$/;"	f	class:facebook::memcache::McRequestBase
flags	.\lib\fbi\asox_queue.h	/^  asox_queue_entry_flags_t flags;$/;"	m	struct:asox_queue_entry_s
flags	.\lib\fbi\asox_semaphore.c	/^  asox_sem_flags_t flags;$/;"	m	struct:asox_sem_s	file:
flags	.\lib\mc\msg.h	/^  uint64_t flags; \/\/ is_transient for metaget$/;"	m	struct:mc_msg_s
flags_	.\lib\test\RouteHandleTestUtil.h	/^  int64_t flags_;$/;"	m	struct:facebook::memcache::GetRouteTestData
flags_	.\lib\test\RouteHandleTestUtil.h	/^  uint64_t flags_;$/;"	m	struct:facebook::memcache::UpdateRouteTestData
flavorNameFromFile	.\flavor.cpp	/^folly::StringPiece flavorNameFromFile(folly::StringPiece file) {$/;"	f	namespace:facebook::memcache::mcrouter::__anon3
flip64	.\lib\mc\umbrella.h	27;"	d
flushQueue	.\lib\network\test\AsyncMcClientTest.cpp	/^  void flushQueue() {$/;"	f	class:__anon42::ServerOnRequest
flushSavedInputs	.\lib\network\test\SessionTestHarness.cpp	/^void SessionTestHarness::flushSavedInputs() {$/;"	f	class:facebook::memcache::SessionTestHarness
flushWrites	.\lib\network\test\SessionTestHarness.h	/^  std::vector<std::string> flushWrites() {$/;"	f	class:facebook::memcache::SessionTestHarness
flush_cb	.\lib\fbi\error.c	/^static fbi_err_flush_cb flush_cb = NULL;$/;"	v	file:
flush_read_fd	.\lib\fbi\asox_semaphore.c	/^static inline void flush_read_fd(int fd) {$/;"	f	file:
fm_	.\lib\fibers\FiberManager-inl.h	/^    FiberManager& fm_;$/;"	m	class:facebook::memcache::FiberManager::AddTaskFinallyHelper::Finally
fm_	.\lib\fibers\SimpleLoopController.h	/^  FiberManager* fm_;$/;"	m	class:facebook::memcache::SimpleLoopController
fm_	.\lib\test\RouteHandleTestUtil.h	/^  FiberManager fm_;$/;"	m	class:facebook::memcache::TestFiberManager
folly	.\ConfigApi.h	/^namespace folly {$/;"	n
folly	.\PoolFactory.h	/^namespace folly {$/;"	n
folly	.\PoolFactoryIf.h	/^namespace folly {$/;"	n
folly	.\ProxyConfig.h	/^namespace folly {$/;"	n
folly	.\flavor.h	/^namespace folly {$/;"	n
folly	.\lib\Ch3HashFunc.h	/^namespace folly {$/;"	n
folly	.\lib\Crc32HashFunc.h	/^namespace folly {$/;"	n
folly	.\lib\IOBufUtil.h	/^namespace folly {$/;"	n
folly	.\lib\WeightedCh3HashFunc.h	/^namespace folly {$/;"	n
folly	.\lib\config\RouteHandleFactory.h	/^namespace folly {$/;"	n
folly	.\lib\config\RouteHandleProviderIf.h	/^namespace folly {$/;"	n
folly	.\lib\fibers\EventBaseLoopController.h	/^namespace folly {$/;"	n
folly	.\lib\network\AsyncMcServer.h	/^namespace folly {$/;"	n
folly	.\lib\network\AsyncMcServerWorker.h	/^namespace folly {$/;"	n
folly	.\lib\network\ConnectionOptions.h	/^namespace folly {$/;"	n
folly	.\lib\network\ThreadLocalSSLContextProvider.h	/^namespace folly {$/;"	n
folly	.\lib\network\UmbrellaProtocol.h	/^namespace folly {$/;"	n
folly	.\lib\network\test\MockMc.h	/^namespace folly {$/;"	n
folly	.\options.cpp	/^namespace folly {$/;"	n	file:
folly	.\proxy.h	/^namespace folly {$/;"	n
folly	.\router.h	/^namespace folly {$/;"	n
folly	.\routes\BigValueRoute.h	/^namespace folly {$/;"	n
folly	.\routes\McRouteHandleProvider.h	/^namespace folly {$/;"	n
folly	.\routes\PrefixRouteSelector.h	/^namespace folly {$/;"	n
folly	.\routes\RateLimiter.h	/^namespace folly {$/;"	n
folly	.\routes\ShardHashFunc.h	/^namespace folly {$/;"	n
folly	.\routes\ShardSplitter.h	/^namespace folly {$/;"	n
forEach	.\lib\fibers\ForEach-inl.h	/^inline void forEach(InputIterator first, InputIterator last, F&& f) {$/;"	f	namespace:facebook::memcache::fiber
forEach	.\options-template.h	/^  void forEach(std::function<void(const std::string&,$/;"	f	class:OPTIONS_NAME
for_each_localaddr	.\lib\fbi\network.c	/^bool for_each_localaddr(bool (*cb)(const struct sockaddr *addr, void *ctx),$/;"	f
foreachPossibleClient	.\proxy.cpp	/^void proxy_t::foreachPossibleClient($/;"	f	class:facebook::memcache::mcrouter::proxy_t
foreachPossibleClientHelper	.\proxy.cpp	/^void foreachPossibleClientHelper(const McrouterRouteHandleIf& rh,$/;"	f	namespace:facebook::memcache::mcrouter::__anon50
foreachRoutePolicy	.\routes\RouteHandleMap.cpp	/^void RouteHandleMap::foreachRoutePolicy(folly::StringPiece prefix,$/;"	f	class:facebook::memcache::mcrouter::RouteHandleMap
foreach_shared_synchronized	.\pclient-inl.h	/^void ProxyClientOwner::foreach_shared_synchronized(const F& func) {$/;"	f	class:facebook::memcache::mcrouter::ProxyClientOwner
forkWorkAround	.\PeriodicTaskScheduler.cpp	/^void PeriodicTaskScheduler::forkWorkAround() {$/;"	f	class:facebook::memcache::mcrouter::PeriodicTaskScheduler
format_date	.\lib\fbi\debug.c	/^static void format_date(char *str, const uint str_sz,$/;"	f	file:
format_level	.\lib\fbi\debug.c	/^static void format_level(char *str, const uint str_sz, const char* type)$/;"	f	file:
forward	.\lib\fbi\skiplist.h	/^  struct skiplist_node_s* forward[1];$/;"	m	struct:skiplist_node_s	typeref:struct:skiplist_node_s::skiplist_node_s
free	.\lib\fbi\cpp\ObjectPool.h	/^  void free(T* obj) {$/;"	f	class:facebook::memcache::ObjectPool
free	.\lib\fbi\cpp\ObjectPool.h	/^  void free(T* obj) {$/;"	f	class:facebook::memcache::ThreadSafeObjectPool
freeAllMcrouters	.\router.cpp	/^  void freeAllMcrouters() {$/;"	f	class:facebook::memcache::mcrouter::__anon56::McrouterManager
freeList_	.\lib\fbi\cpp\ObjectPool.h	/^    freeList_;                          \/\/ List of free objects$/;"	m	class:facebook::memcache::ObjectPool
freeQueue	.\lib\network\WriteBuffer.h	/^  WriteBuffer::Queue& freeQueue() {$/;"	f	class:facebook::memcache::WriteBufferQueue
free_all_libmcrouters	.\router.cpp	/^void free_all_libmcrouters() {$/;"	f	namespace:facebook::memcache::mcrouter
fromString	.\options.cpp	/^void fromString(const std::string& str, const boost::any& value) {$/;"	f	namespace:facebook::memcache::__anon48
from_	.\lib\routes\MigrateRoute.h	/^  std::shared_ptr<RouteHandleIf> from_;$/;"	m	class:facebook::memcache::MigrateRoute
from_pool	.\proxy.h	/^  ProxyPool* from_pool;$/;"	m	class:facebook::memcache::mcrouter::ProxyMigratedPool
front	.\lib\network\UniqueIntrusiveList.h	/^  T& front() { return list_.front(); }$/;"	f	class:facebook::memcache::UniqueIntrusiveList
front	.\lib\network\UniqueIntrusiveList.h	/^  const T& front() const { return list_.front(); }$/;"	f	class:facebook::memcache::UniqueIntrusiveList
fulfil	.\lib\fibers\FiberPromise-inl.h	/^void FiberPromise<T>::fulfil(F&& func) {$/;"	f	class:facebook::memcache::FiberPromise
fulfilHelper	.\lib\fibers\FiberPromise-inl.h	/^inline FiberPromise<T>::fulfilHelper(F&& func) {$/;"	f	class:facebook::memcache::std::enable_if::FiberPromise
fulfilTry	.\lib\fibers\FiberPromise-inl.h	/^void FiberPromise<T>::fulfilTry(folly::wangle::Try<T>&& t) {$/;"	f	class:facebook::memcache::FiberPromise
fulfillTransactions	.\lib\network\test\SessionTestHarness.h	/^  void fulfillTransactions() {$/;"	f	class:facebook::memcache::SessionTestHarness
fullKey	.\lib\McRequestBase.h	/^  folly::StringPiece fullKey() const {$/;"	f	class:facebook::memcache::McRequestBase
func	.\PeriodicTaskScheduler.h	/^    std::function<void(PeriodicTaskScheduler&)> func;$/;"	m	struct:facebook::memcache::mcrouter::PeriodicTaskScheduler::TaskThread
func	.\lib\fibers\FiberManager.h	/^    std::function<void()> func;$/;"	m	struct:facebook::memcache::FiberManager::RemoteTask
func_	.\CallbackPool-inl.h	/^  const OnUpdateFunc func_;$/;"	m	struct:facebook::memcache::mcrouter::CallbackPool::CallbackHandleImpl
func_	.\lib\fibers\Fiber.h	/^  std::function<void()> func_;  \/**< task function *\/$/;"	m	class:facebook::memcache::Fiber
func_	.\lib\fibers\FiberManager-inl.h	/^    F func_;$/;"	m	class:facebook::memcache::FiberManager::AddTaskFinallyHelper::Func
function	.\lib\fbi\debug.c	/^  const char *function;$/;"	m	struct:msg_info	file:
furc_get_bit	.\lib\fbi\hash.c	/^static uint32_t furc_get_bit(const char* const key, const size_t len,$/;"	f	file:
furc_hash	.\lib\fbi\hash.c	/^uint32_t furc_hash(const char* const key, const size_t len, const uint32_t m) {$/;"	f
furc_maximum_pool_size	.\lib\fbi\hash.c	/^inline uint32_t furc_maximum_pool_size(void) {$/;"	f
futex	.\lib\fibers\Baton.h	/^      folly::detail::Futex<> futex;$/;"	m	struct:facebook::memcache::Baton::__anon27::__anon28
futex_	.\lib\fibers\Baton.h	/^    } futex_;$/;"	m	union:facebook::memcache::Baton::__anon27	typeref:struct:facebook::memcache::Baton::__anon27::__anon28
gCv	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	/^std::condition_variable gCv;$/;"	m	namespace:__anon66	file:
gMutex	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	/^std::mutex gMutex;$/;"	m	namespace:__anon66	file:
gReplies	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	/^std::atomic<size_t> gReplies;$/;"	m	namespace:__anon66	file:
gServer	.\lib\network\AsyncMcServer.cpp	/^facebook::memcache::AsyncMcServer* gServer;$/;"	m	namespace:facebook::memcache::__anon38	file:
genProxyClientKey	.\PoolFactory.cpp	/^string PoolFactory::genProxyClientKey(const AccessPoint& ap) {$/;"	f	class:facebook::memcache::mcrouter::PoolFactory
genProxyDestinationKey	.\ProxyClientCommon.cpp	/^std::string ProxyClientCommon::genProxyDestinationKey() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyClientCommon
generateCert	.\lib\network\test\generate_keys.sh	/^function generateCert() {$/;"	f
generateMcrouterConfigString	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^std::string MemcacheLocal::generateMcrouterConfigString() {$/;"	f	class:facebook::memcache::test::MemcacheLocal
generateMsg	.\routes\AsynclogRoute.h	/^  McMsgRef generateMsg(std::shared_ptr<const ProxyClientCommon> dest,$/;"	f	class:facebook::memcache::mcrouter::AsynclogRoute
generateMsg	.\routes\DestinationRoute.h	/^  McMsgRef generateMsg(const Request& req, McOperation<M>) const {$/;"	f	class:facebook::memcache::mcrouter::DestinationRoute
generateRandomPort	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^int MemcacheLocal::generateRandomPort(const int start_port,$/;"	f	class:facebook::memcache::test::MemcacheLocal
get	.\ConfigApi.cpp	/^bool ConfigApi::get(ConfigType type, const std::string& path,$/;"	f	class:facebook::memcache::mcrouter::ConfigApi
get	.\Observable-inl.h	/^Data Observable<Data>::get() {$/;"	f	class:facebook::memcache::mcrouter::Observable
get	.\lib\McMsgRef.h	/^  T* get() const { return ref_; }$/;"	f	class:facebook::memcache::Ref
get	.\lib\fbi\cpp\AtomicSharedPtr.h	/^  T get() {$/;"	f	class:facebook::memcache::AtomicWrapper
get	.\lib\network\test\MockMc.cpp	/^MockMc::Item* MockMc::get(folly::StringPiece key) {$/;"	f	class:facebook::memcache::MockMc
get	.\test\MCProcess.py	/^    def get(self, keys, return_all_info=False):$/;"	m	class:MCProcess
get	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^int MCRouterTestClient::get(const dynamic &keys,$/;"	f	class:MCRouterTestClient
getAddrHash	.\lib\fbi\cpp\globals.cpp	/^bool getAddrHash(const sockaddr *addr, void *ctx) {$/;"	f	namespace:facebook::memcache::globals::__anon8
getAsyncMcClient	.\DestinationClient.cpp	/^AsyncMcClient& DestinationClient::getAsyncMcClient() {$/;"	f	class:facebook::memcache::mcrouter::DestinationClient
getBySingleRoute	.\routes\RouteHandleMap.cpp	/^RouteHandleMap::getBySingleRoute(folly::StringPiece route,$/;"	f	class:facebook::memcache::mcrouter::RouteHandleMap
getCallParams	.\lib\config\ConfigPreprocessor.cpp	/^ConfigPreprocessor::getCallParams(StringPiece str,$/;"	f	class:facebook::memcache::ConfigPreprocessor
getClient	.\lib\network\test\AsyncMcClientTest.cpp	/^  AsyncMcClient& getClient() {$/;"	f	class:__anon42::TestClient
getCluster	.\RoutingPrefix.h	/^  folly::StringPiece getCluster() const { return cluster_; }$/;"	f	class:facebook::memcache::mcrouter::RoutingPrefix
getConfig	.\proxy.cpp	/^std::shared_ptr<ProxyConfigIf> proxy_t::getConfig() const {$/;"	f	class:facebook::memcache::mcrouter::proxy_t
getConfigFile	.\ConfigApi.cpp	/^bool ConfigApi::getConfigFile(std::string& contents) {$/;"	f	class:facebook::memcache::mcrouter::ConfigApi
getConfigMd5Digest	.\ProxyConfig.h	/^  std::string getConfigMd5Digest() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyConfig
getConfigSourcesInfo	.\ConfigApi.cpp	/^folly::dynamic ConfigApi::getConfigSourcesInfo() {$/;"	f	class:facebook::memcache::mcrouter::ConfigApi
getConfigWithoutMacros	.\lib\config\ConfigPreprocessor.cpp	/^dynamic ConfigPreprocessor::getConfigWithoutMacros($/;"	f	class:facebook::memcache::ConfigPreprocessor
getContext	.\lib\config\ConfigPreprocessor.cpp	/^  Context getContext(const dynamic& macroObj) const {$/;"	f	class:facebook::memcache::ConfigPreprocessor::Macro
getContext	.\lib\config\ConfigPreprocessor.cpp	/^  Context getContext(vector<dynamic> paramValues) const {$/;"	f	class:facebook::memcache::ConfigPreprocessor::Macro
getData	.\proxy.cpp	/^proxy_pool_shadowing_policy_t::getData() {$/;"	f	class:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t
getDestination	.\ProxyMcReply.cpp	/^std::shared_ptr<const ProxyClientCommon> ProxyMcReply::getDestination() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyMcReply
getDestinationHandlesForPool	.\routes\McRouteHandleProvider.cpp	/^McRouteHandleProvider::getDestinationHandlesForPool($/;"	f	class:facebook::memcache::mcrouter::McRouteHandleProvider
getEdge	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::getEdge(char c) const {$/;"	f	class:facebook::memcache::Trie
getEventBase	.\lib\fibers\EventBaseLoopController.h	/^  folly::EventBase* getEventBase() {$/;"	f	class:facebook::memcache::mcrouter::EventBaseLoopController
getFiber	.\lib\fibers\FiberManager.cpp	/^Fiber* FiberManager::getFiber() {$/;"	f	class:facebook::memcache::FiberManager
getFiberManager	.\lib\fibers\FiberManager-inl.h	/^inline FiberManager& FiberManager::getFiberManager() {$/;"	f	class:facebook::memcache::FiberManager
getFiberManager	.\lib\test\RouteHandleTestUtil.h	/^  FiberManager& getFiberManager() {$/;"	f	class:facebook::memcache::TestFiberManager
getFiberManagerOptions	.\proxy.cpp	/^FiberManager::Options getFiberManagerOptions(const McrouterOptions& opts) {$/;"	f	namespace:facebook::memcache::mcrouter::__anon51
getFiberManagerUnsafe	.\lib\fibers\FiberManager-inl.h	/^inline FiberManager* FiberManager::getFiberManagerUnsafe() {$/;"	f	class:facebook::memcache::FiberManager
getFromPool	.\lib\network\AsyncMcClientImpl.h	/^    static UniquePtr getFromPool(Args&&... args) {$/;"	f	class:facebook::memcache::AsyncMcClientImpl::ReqInfo
getHash	.\lib\fbi\cpp\globals.cpp	/^uint32_t getHash() {$/;"	f	namespace:facebook::memcache::globals::__anon8
getHost	.\AccessPoint.h	/^  std::string getHost() const {$/;"	f	struct:facebook::memcache::mcrouter::AccessPoint
getInflightRequestCount	.\DestinationClient.cpp	/^size_t DestinationClient::getInflightRequestCount() const {$/;"	f	class:facebook::memcache::mcrouter::DestinationClient
getInflightRequestCount	.\ProxyDestination.cpp	/^size_t ProxyDestination::getInflightRequestCount() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
getInflightRequestCount	.\lib\network\AsyncMcClient-inl.h	/^inline size_t AsyncMcClient::getInflightRequestCount() const {$/;"	f	class:facebook::memcache::AsyncMcClient
getInflightRequestCount	.\lib\network\AsyncMcClientImpl.cpp	/^size_t AsyncMcClientImpl::getInflightRequestCount() const {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
getIovs	.\lib\network\McSerializedRequest.h	/^  struct iovec* getIovs() { return iovs_; }$/;"	f	class:facebook::memcache::McSerializedRequest
getIovsCount	.\lib\network\McSerializedRequest.h	/^  size_t getIovsCount() { return iovsCount_; }$/;"	f	class:facebook::memcache::McSerializedRequest
getListenPort	.\lib\network\test\AsyncMcClientTest.cpp	/^  uint16_t getListenPort() const {$/;"	f	class:__anon42::TestServer
getListenPort	.\lib\network\test\TestUtil.h	/^inline uint16_t getListenPort(int socketFd) {$/;"	f	namespace:facebook::memcache
getMcReply	.\lib\StatsReply.cpp	/^McReply StatsReply::getMcReply() {$/;"	f	class:facebook::memcache::StatsReply
getMemcacheKeyHashValue	.\lib\fbi\cpp\util.cpp	/^uint32_t getMemcacheKeyHashValue(folly::StringPiece key) {$/;"	f	namespace:facebook::memcache
getName	.\proxy.h	/^  std::string getName() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyGenericPool
getOpSettings	.\routes\test\FailoverWithExptimeRouteTest.cpp	/^FailoverWithExptimeSettings::OperationSettings* getOpSettings($/;"	f
getOpenFDCount	.\stats.cpp	/^static bool getOpenFDCount(size_t& openFD) {$/;"	f	namespace:facebook::memcache::mcrouter
getOptionData	.\options-template.h	/^  static std::vector<McrouterOptionData> getOptionData() {$/;"	f	class:OPTIONS_NAME
getOutstandingCount	.\lib\network\test\AsyncMcClientTest.cpp	/^  size_t getOutstandingCount() const {$/;"	f	class:__anon42::TestClient
getOutstandingRequestStats	.\ProxyDestinationMap.cpp	/^ProxyDestinationMap::getOutstandingRequestStats() {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestinationMap
getPendingRequestCount	.\DestinationClient.cpp	/^size_t DestinationClient::getPendingRequestCount() const {$/;"	f	class:facebook::memcache::mcrouter::DestinationClient
getPendingRequestCount	.\ProxyDestination.cpp	/^size_t ProxyDestination::getPendingRequestCount() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
getPendingRequestCount	.\lib\network\AsyncMcClient-inl.h	/^inline size_t AsyncMcClient::getPendingRequestCount() const {$/;"	f	class:facebook::memcache::AsyncMcClient
getPendingRequestCount	.\lib\network\AsyncMcClientImpl.cpp	/^size_t AsyncMcClientImpl::getPendingRequestCount() const {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
getPool	.\lib\network\AsyncMcClientImpl.h	/^    static ObjectPool<ReqInfo>& getPool() {$/;"	f	class:facebook::memcache::AsyncMcClientImpl::ReqInfo
getPoolHandle	.\routes\McRouteHandleProvider.cpp	/^McrouterRouteHandlePtr McRouteHandleProvider::getPoolHandle($/;"	f	class:facebook::memcache::mcrouter::McRouteHandleProvider
getPort	.\AccessPoint.h	/^  std::string getPort() const {$/;"	f	struct:facebook::memcache::mcrouter::AccessPoint
getPort	.\test\cpp_unit_tests\MemcacheLocal.h	/^  int getPort() const { return port_; }$/;"	f	class:facebook::memcache::test::MemcacheLocal
getProtocol	.\AccessPoint.h	/^  mc_protocol_t getProtocol() const {$/;"	f	struct:facebook::memcache::mcrouter::AccessPoint
getProxy	.\router.cpp	/^proxy_t* mcrouter_t::getProxy(size_t index) const {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
getRange	.\lib\IOBufUtil.cpp	/^folly::StringPiece getRange(const folly::IOBuf& buf) {$/;"	f	namespace:facebook::memcache
getRange	.\lib\IOBufUtil.cpp	/^folly::StringPiece getRange(const std::unique_ptr<folly::IOBuf>& buf) {$/;"	f	namespace:facebook::memcache
getReadBuffer	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::getReadBuffer(void** bufReturn, size_t* lenReturn) {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
getReadBuffer	.\lib\network\McParser.cpp	/^std::pair<void*, size_t> McParser::getReadBuffer() {$/;"	f	class:facebook::memcache::McParser
getReadBuffer	.\lib\network\McServerSession.cpp	/^void McServerSession::getReadBuffer(void** bufReturn, size_t* lenReturn) {$/;"	f	class:facebook::memcache::McServerSession
getReadCallback	.\lib\network\test\SessionTestHarness.h	/^  apache::thrift::async::TAsyncTransport::ReadCallback* getReadCallback() {$/;"	f	class:facebook::memcache::SessionTestHarness
getRegion	.\RoutingPrefix.h	/^  folly::StringPiece getRegion() const { return region_; }$/;"	f	class:facebook::memcache::mcrouter::RoutingPrefix
getRequestClass	.\ProxyMcRequest.h	/^  RequestClass getRequestClass() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyMcRequest
getRequestClassString	.\ProxyMcRequest.cpp	/^folly::StringPiece ProxyMcRequest::getRequestClassString() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyMcRequest
getResult	.\lib\config\ConfigPreprocessor.cpp	/^  const dynamic& getResult() const {$/;"	f	class:facebook::memcache::ConfigPreprocessor::Const
getResult	.\lib\config\ConfigPreprocessor.cpp	/^  dynamic getResult(const Context& context) const {$/;"	f	class:facebook::memcache::ConfigPreprocessor::Macro
getRoute	.\test\cpp_unit_tests\mc_route_handle_provider_test.cpp	/^getRoute(const folly::dynamic& d) {$/;"	f	file:
getRouteHandleForProxyPool	.\ProxyConfig.cpp	/^ProxyConfig::getRouteHandleForProxyPool(const std::string& poolName) const {$/;"	f	class:facebook::memcache::mcrouter::ProxyConfig
getSSLContext	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^std::shared_ptr<SSLContext> getSSLContext(folly::StringPiece pemCertPath,$/;"	f	namespace:facebook::memcache
getSeenRequests	.\test\test_max_shadow_requests.py	/^    def getSeenRequests(self):$/;"	m	class:TimeoutServer
getShardId	.\routes\ShardHashFunc.cpp	/^bool getShardId(folly::StringPiece key, folly::StringPiece& shardId) {$/;"	f	namespace:facebook::memcache::mcrouter
getShardSplitCnt	.\routes\ShardSplitter.cpp	/^size_t ShardSplitter::getShardSplitCnt(folly::StringPiece routingKey,$/;"	f	class:facebook::memcache::mcrouter::ShardSplitter
getSharedByKey	.\pclient.cpp	/^ProxyClientOwner::getSharedByKey(const std::string& key) {$/;"	f	class:facebook::memcache::mcrouter::ProxyClientOwner
getSocketAddress	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^void * MemcacheLocal::getSocketAddress(struct sockaddr *sa) const {$/;"	f	class:facebook::memcache::test::MemcacheLocal
getStartupOpts	.\router.cpp	/^unordered_map<string, string> mcrouter_t::getStartupOpts() const {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
getStats	.\lib\network\test\AsyncMcClientTest.cpp	/^  CommonStats& getStats() {$/;"	f	class:__anon42::TestServer
getSuspectServers	.\router.cpp	/^unordered_map<string, std::pair<bool, size_t>> mcrouter_t::getSuspectServers() {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
getTargetsForKey	.\routes\RouteHandleMap.cpp	/^const std::vector<McrouterRouteHandlePtr>& RouteHandleMap::getTargetsForKey($/;"	f	class:facebook::memcache::mcrouter::RouteHandleMap
getTargetsForKey	.\routes\RoutePolicyMap.cpp	/^RoutePolicyMap::getTargetsForKey(folly::StringPiece key) const {$/;"	f	class:facebook::memcache::mcrouter::RoutePolicyMap
getTargetsForKeyFast	.\routes\RouteHandleMap.cpp	/^RouteHandleMap::getTargetsForKeyFast(folly::StringPiece prefix,$/;"	f	class:facebook::memcache::mcrouter::RouteHandleMap
getTargetsForKeySlow	.\routes\RouteHandleMap.cpp	/^RouteHandleMap::getTargetsForKeySlow(folly::StringPiece prefix,$/;"	f	class:facebook::memcache::mcrouter::RouteHandleMap
getTaskID	.\lib\fibers\AddTasks-inl.h	/^inline size_t TaskIterator<T>::getTaskID() const {$/;"	f	class:facebook::memcache::fiber::TaskIterator
getTestTimer	.\lib\fbi\test\timer_tests.cpp	/^static fb_timer_t* getTestTimer(int windowSize) {$/;"	f	file:
getThreadName	.\lib\fbi\cpp\util.cpp	/^std::string getThreadName() {$/;"	f	namespace:facebook::memcache
getTransport	.\AccessPoint.h	/^  mc_transport_t getTransport() const {$/;"	f	struct:facebook::memcache::mcrouter::AccessPoint
getType	.\proxy.h	/^  virtual proxy_pool_type_t getType() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyMigratedPool
getType	.\proxy.h	/^  virtual proxy_pool_type_t getType() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyRegionalPool
getType	.\proxy.h	/^  virtual proxy_pool_type_t getType() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyRegularPool
getUserBuffer	.\lib\fibers\Fiber-inl.h	/^inline void* Fiber::getUserBuffer() {$/;"	f	class:facebook::memcache::Fiber
getVariableByName	.\RuntimeVarsData.cpp	/^RuntimeVarsData::getVariableByName(const std::string& name) const {$/;"	f	class:facebook::memcache::mcrouter::RuntimeVarsData
get_async_spool_dir	.\test\MCProcess.py	/^    def get_async_spool_dir(self):$/;"	m	class:Mcrouter
get_context	.\lib\fbi\error.c	/^static inline _context_t* get_context() {$/;"	f	file:
get_cpu_frequency	.\lib\fbi\fb_cpu_util.c	/^double get_cpu_frequency(void) {$/;"	f
get_event_priority	.\priorities.cpp	/^int get_event_priority(const McrouterOptions& opts,$/;"	f	namespace:facebook::memcache::mcrouter
get_family_info	.\lib\fbi\network.c	/^fbi_family_info_t *get_family_info(sa_family_t family) {$/;"	f
get_inflated	.\lib\fbi\counter.c	/^static inline int64_t get_inflated(const counter_inflated_t *inflated) {$/;"	f	file:
get_mcrouter	.\test\test_empty_pool.py	/^    def get_mcrouter(self, extra_args=[]):$/;"	m	class:TestEmptyPool
get_mcrouter	.\test\test_mcrouter.py	/^    def get_mcrouter(self):$/;"	m	class:TestDevNull
get_mcrouter	.\test\test_mcrouter.py	/^    def get_mcrouter(self):$/;"	m	class:TestDuplicateServers
get_mcrouter	.\test\test_mcrouter.py	/^    def get_mcrouter(self):$/;"	m	class:TestDuplicateServersDiffTimeouts
get_mcrouter	.\test\test_mcrouter.py	/^    def get_mcrouter(self):$/;"	m	class:TestGetFailover
get_mcrouter	.\test\test_mcrouter.py	/^    def get_mcrouter(self):$/;"	m	class:TestLeaseGetFailover
get_mcrouter	.\test\test_mcrouter.py	/^    def get_mcrouter(self):$/;"	m	class:TestMetaGetFailover
get_mcrouter	.\test\test_mcrouter.py	/^    def get_mcrouter(self):$/;"	m	class:TestMigratedPools
get_mcrouter	.\test\test_mcrouter.py	/^    def get_mcrouter(self):$/;"	m	class:TestMigratedPoolsFailover
get_mcrouter	.\test\test_mcrouter.py	/^    def get_mcrouter(self):$/;"	m	class:TestSamePoolFailover
get_mcrouter	.\test\test_mcrouter.py	/^    def get_mcrouter(self):$/;"	m	class:TestServerListFromAnotherPool
get_mcrouter	.\test\test_mcrouter_basic.py	/^    def get_mcrouter(self):$/;"	m	class:TestBasicAllFirst
get_mcrouter	.\test\test_mcrouter_basic.py	/^    def get_mcrouter(self):$/;"	m	class:TestBasicAllMajority
get_mcrouter	.\test\test_mcrouter_basic.py	/^    def get_mcrouter(self):$/;"	m	class:TestBasicAllSync
get_mcrouter	.\test\test_mcrouter_basic.py	/^    def get_mcrouter(self):$/;"	m	class:TestBasicFailover
get_mcrouter	.\test\test_mcrouter_basic.py	/^    def get_mcrouter(self):$/;"	m	class:TestBasicFailoverOverride
get_mcrouter	.\test\test_mcrouter_basic.py	/^    def get_mcrouter(self):$/;"	m	class:TestMcrouterBasicL1L2
get_mcrouter	.\test\test_mcrouter_basic.py	/^    def get_mcrouter(self, additional_args=[]):$/;"	m	class:TestMcrouterBasic
get_mcrouter	.\test\test_mcrouter_basic.py	/^    def get_mcrouter(self, additional_args=[]):$/;"	m	class:TestMcrouterBasic2
get_mcrouter	.\test\test_mcrouter_basic.py	/^    def get_mcrouter(self, additional_args=[]):$/;"	m	class:TestMcrouterInvalidRoute
get_mcrouter	.\test\test_migrated_failover.py	/^    def get_mcrouter(self):$/;"	m	class:TestMigratedFailover
get_mcrouter	.\test\test_noreply.py	/^    def get_mcrouter(self):$/;"	m	class:TestNoreply
get_mcrouter	.\test\test_probe_timeout.py	/^    def get_mcrouter(self):$/;"	m	class:TestProbeTimeout
get_mcrouter	.\test\test_rates.py	/^    def get_mcrouter(self):$/;"	m	class:TestRates
get_mcrouter	.\test\test_routing_prefixes.py	/^    def get_mcrouter(self):$/;"	m	class:TestMcrouterRoutingPrefixAscii
get_mcrouter	.\test\test_service_info.py	/^    def get_mcrouter(self):$/;"	m	class:TestServiceInfo
get_mcrouter	.\test\test_shadow.py	/^    def get_mcrouter(self, more_extra_args=[]):$/;"	m	class:TestShadow
get_mcrouter	.\test\test_shadow_with_file.py	/^    def get_mcrouter(self):$/;"	m	class:TestShadowWithFile
get_microsecond_from_tsc	.\lib\fbi\fb_cpu_util.h	/^static inline uint64_t get_microsecond_from_tsc(uint64_t count,$/;"	f
get_microseconds	.\lib\fbi\fb_cpu_util.h	/^static inline double get_microseconds(double cpu_freq) {$/;"	f
get_num_bins_used	.\stats.cpp	/^int get_num_bins_used(const mcrouter_t* router) {$/;"	f	namespace:facebook::memcache::mcrouter::__anon62
get_open_ports	.\test\McrouterTestCase.py	/^    def get_open_ports(self):$/;"	m	class:McrouterTestCase
get_proc_stat	.\stats.cpp	/^static int get_proc_stat(pid_t pid, proc_stat_data_t *data) {$/;"	f	namespace:facebook::memcache::mcrouter
get_route_handles	.\lib\test\RouteHandleTestUtil.h	/^inline std::vector<std::shared_ptr<TestRouteHandleIf>> get_route_handles($/;"	f	namespace:facebook::memcache
get_rsp	.\lib\mc\umbrella_protocol.c	93;"	d	file:
get_sa_address	.\lib\fbi\network.c	/^bool get_sa_address(const struct sockaddr *sa, const void **addr,$/;"	f
get_stats_key	.\McrouterLogger.cpp	/^inline std::string get_stats_key(const McrouterOptions& opts) {$/;"	f	namespace:facebook::memcache::mcrouter::__anon46
get_usec_interval	.\lib\fbi\fb_cpu_util.c	/^static long get_usec_interval(struct timeval *start, struct timeval *end) {$/;"	f	file:
getport	.\test\MCProcess.py	/^    def getport(self):$/;"	m	class:MCProcess
getport	.\test\mock_servers.py	/^    def getport(self):$/;"	m	class:MockServer
getsTb_	.\routes\RateLimiter.h	/^  folly::Optional<TokenBucket> getsTb_;$/;"	m	class:facebook::memcache::mcrouter::RateLimiter
gflags	.\lib\fibers\test\main.cpp	/^namespace gflags { }$/;"	n	file:
gflags	.\routes\test\Main.cpp	/^namespace gflags { }$/;"	n	file:
gflags	.\test\cpp_unit_tests\libmcrouter_test.cpp	/^namespace gflags { }$/;"	n	file:
globalTkos	.\TkoLog.h	/^  const TkoCounters& globalTkos;$/;"	m	struct:facebook::memcache::mcrouter::TkoLog
globalTkos	.\TkoTracker.cpp	/^const TkoCounters& TkoTracker::globalTkos() const {$/;"	f	class:facebook::memcache::mcrouter::TkoTracker
globalTkos_	.\TkoTracker.h	/^  TkoCounters& globalTkos_;$/;"	m	class:facebook::memcache::mcrouter::TkoTracker
globals	.\lib\fbi\cpp\globals.cpp	/^namespace facebook { namespace memcache { namespace globals {$/;"	n	namespace:facebook::memcache	file:
globals	.\lib\fbi\cpp\globals.h	/^namespace facebook { namespace memcache { namespace globals {$/;"	n	namespace:facebook::memcache
google	.\lib\fibers\test\main.cpp	/^namespace google { using namespace gflags; }$/;"	n	file:
google	.\routes\test\Main.cpp	/^namespace google { using namespace gflags; }$/;"	n	file:
google	.\test\cpp_unit_tests\libmcrouter_test.cpp	/^namespace google { using namespace gflags; }$/;"	n	file:
grab	.\scripts\common.sh	/^grab() {$/;"	f
group	.\options.h	/^  std::string group;$/;"	m	struct:facebook::memcache::McrouterOptionData
group	.\stats.h	/^  int group;$/;"	m	struct:facebook::memcache::mcrouter::stat_t
h_	.\lib\test\RouteHandleTestUtil.h	/^  TestHandle* h_;$/;"	m	struct:facebook::memcache::RecordingRoute
handleRequest	.\ServiceInfo.cpp	/^void ServiceInfo::handleRequest(const ProxyMcRequest& req) const {$/;"	f	class:facebook::memcache::mcrouter::ServiceInfo
handleRouteCommand	.\ServiceInfo.cpp	/^void ServiceInfo::ServiceInfoImpl::handleRouteCommand($/;"	f	class:facebook::memcache::mcrouter::ServiceInfo::ServiceInfoImpl
handleRouteCommandForOp	.\ServiceInfo.cpp	/^void ServiceInfo::ServiceInfoImpl::handleRouteCommandForOp($/;"	f	class:facebook::memcache::mcrouter::ServiceInfo::ServiceInfoImpl
handle_	.\proxy.h	/^  ObservableRuntimeVars::CallbackHandle handle_;$/;"	m	struct:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t
handle_tko	.\ProxyDestination.cpp	/^void ProxyDestination::handle_tko(const McReply& reply,$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
handlers	.\lib\fbi\cpp\LogFailure.cpp	/^  std::vector<std::pair<std::string, HandlerFunc>> handlers = {$/;"	m	struct:facebook::memcache::failure::__anon9::StaticContainer	file:
handlers	.\lib\fbi\cpp\LogFailure.cpp	/^namespace handlers {$/;"	n	namespace:facebook::memcache::failure	file:
handlers	.\lib\fbi\cpp\LogFailure.h	/^namespace handlers {$/;"	n	namespace:facebook::memcache::failure
harness_	.\lib\network\test\SessionTestHarness.cpp	/^  SessionTestHarness& harness_;$/;"	m	class:facebook::memcache::MockAsyncSocket	file:
harness_	.\lib\network\test\SessionTestHarness.h	/^    SessionTestHarness& harness_;$/;"	m	class:facebook::memcache::SessionTestHarness::OnRequest
hasActiveFiber	.\lib\fibers\FiberManager-inl.h	/^inline bool FiberManager::hasActiveFiber() {$/;"	f	class:facebook::memcache::FiberManager
hasNext	.\lib\fibers\AddTasks-inl.h	/^inline bool TaskIterator<T>::hasNext() const {$/;"	f	class:facebook::memcache::fiber::TaskIterator
hasParent	.\lib\network\McServerRequestContext.h	/^  bool hasParent() const {$/;"	f	class:facebook::memcache::McServerRequestContext
hasSameMemoryRegion	.\lib\IOBufUtil.cpp	/^bool hasSameMemoryRegion(const folly::IOBuf& a, const folly::IOBuf& b) {$/;"	f	namespace:facebook::memcache
hasSameMemoryRegion	.\lib\IOBufUtil.cpp	/^bool hasSameMemoryRegion(const folly::IOBuf& buf, folly::StringPiece range) {$/;"	f	namespace:facebook::memcache
hasTasks	.\lib\fibers\FiberManager.cpp	/^bool FiberManager::hasTasks() const {$/;"	f	class:facebook::memcache::FiberManager
hasUpdate	.\FileDataProvider.cpp	/^bool FileDataProvider::hasUpdate() {$/;"	f	class:facebook::memcache::mcrouter::FileDataProvider
hasValue	.\ExponentialSmoothData.h	/^  bool hasValue() const {$/;"	f	class:facebook::memcache::mcrouter::ExponentialSmoothData
hasValue	.\lib\McReplyBase.h	/^  bool hasValue() const {$/;"	f	class:facebook::memcache::McReplyBase
hash	.\proxy.h	/^  proxy_hash_policy_t hash;$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
hashFunc_	.\lib\routes\HashRoute.h	/^  HashFunc hashFunc_;$/;"	m	class:facebook::memcache::HashRoute
hash_salt	.\proxy.h	/^  std::string hash_salt;$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
hdr	.\lib\fbi\skiplist.h	/^  skiplist_node_t *hdr;$/;"	m	struct:skiplist_s
head	.\lib\fbi\log_limit.c	/^static int head = 0, tail = 0, count = 0;$/;"	v	file:
head	.\lib\fbi\nstring.h	/^  nstring_map_entry_t** head;$/;"	m	struct:nstring_map_iter_s
header_size	.\lib\mc\umbrella_protocol.h	/^  size_t header_size;$/;"	m	struct:um_message_info_s
heads	.\lib\fbi\nstring.h	/^  nstring_map_entry_t** heads;$/;"	m	struct:nstring_map_s
highValue	.\lib\McReplyBase.h	/^  double highValue() const {$/;"	f	class:facebook::memcache::McReplyBase
highval	.\lib\mc\msg.h	/^  double highval; \/\/\/< being used in counter ops$/;"	m	struct:mc_msg_s
hook_	.\lib\network\AsyncMcClientImpl.h	/^    UniqueIntrusiveListHook hook_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl::ReqInfo
hook_	.\lib\network\McServerSession.h	/^  folly::SafeIntrusiveListHook hook_;$/;"	m	class:facebook::memcache::McServerSession
hook_	.\lib\network\WriteBuffer.h	/^  UniqueIntrusiveListHook hook_;$/;"	m	class:facebook::memcache::WriteBuffer
host	.\lib\mc\protocol.h	/^  nstring_t host;$/;"	m	struct:mc_accesspoint_s
host	.\lib\network\ConnectionOptions.h	/^  std::string host;$/;"	m	struct:facebook::memcache::ConnectionOptions
host_	.\AccessPoint.h	/^  std::string host_;$/;"	m	struct:facebook::memcache::mcrouter::AccessPoint
hostid	.\lib\fbi\cpp\globals.cpp	/^uint32_t hostid() {$/;"	f	namespace:facebook::memcache::globals
hton16	.\lib\mc\umbrella.h	36;"	d
hton32	.\lib\mc\umbrella.h	35;"	d
hton64	.\lib\mc\umbrella.h	34;"	d
hton8	.\lib\mc\umbrella.h	37;"	d
id	.\lib\fbi\examples\thread-errs.c	/^  int id;$/;"	m	struct:blob_s	file:
id	.\lib\network\AsyncMcClientImpl.h	/^    uint64_t id;$/;"	m	class:facebook::memcache::AsyncMcClientImpl::ReqInfo
idMap_	.\lib\network\AsyncMcClientImpl.h	/^  std::unordered_map<uint64_t, ReqInfo*> idMap_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
id_	.\lib\fibers\AddTasks.h	/^  size_t id_;$/;"	m	class:facebook::memcache::fiber::TaskIterator
idx	.\ProxyClientCommon.h	/^  size_t idx;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientCommon
idx	.\lib\fbi\timer.h	/^  uint64_t idx;$/;"	m	struct:fb_timer_s
if_	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic if_(ConfigPreprocessor* p,$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
immediateConnectFailTest	.\lib\network\test\AsyncMcClientTest.cpp	/^void immediateConnectFailTest(bool useSsl = false) {$/;"	f
immediateFunc_	.\lib\fibers\FiberManager.h	/^  std::function<void()> immediateFunc_;$/;"	m	class:facebook::memcache::FiberManager
impl_	.\ServiceInfo.h	/^  std::unique_ptr<ServiceInfoImpl> impl_;$/;"	m	class:facebook::memcache::mcrouter::ServiceInfo
import	.\lib\config\test\config_preprocessor_test.cpp	/^  std::string import(folly::StringPiece path) {$/;"	f	class:MockImportResolver	file:
import	.\routes\McImportResolver.cpp	/^std::string McImportResolver::import(folly::StringPiece path) {$/;"	f	class:facebook::memcache::mcrouter::McImportResolver
importCache_	.\lib\config\ConfigPreprocessor.h	/^  std::unordered_map<std::string, folly::dynamic> importCache_;$/;"	m	class:facebook::memcache::ConfigPreprocessor
importMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic importMacro(ConfigPreprocessor* p,$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
in_key	.\lib\mc\parser.h	/^  int in_key;$/;"	m	struct:parser_s
in_skipped_key	.\lib\mc\parser.h	/^  int in_skipped_key;$/;"	m	struct:parser_s
inactive_	.\ProxyDestinationMap.h	/^  std::unique_ptr<StateList> inactive_;$/;"	m	class:facebook::memcache::mcrouter::ProxyDestinationMap
incMsgId	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::incMsgId(size_t& msgId) {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
inconsistent_hashing_lookup	.\lib\fbi\test\hash_test.cpp	/^  inconsistent_hashing_lookup(uint32_t hash_value,$/;"	f	file:
incr	.\test\MCProcess.py	/^    def incr(self, key, value=1, noreply=False):$/;"	m	class:MCProcess
increfOrNull	.\lib\McMsgRef.h	/^  static const mc_msg_t* increfOrNull(const mc_msg_t* msg) {$/;"	f	struct:facebook::memcache::McMsgRefPolicy
increfOrNull	.\lib\McRequestBase.h	/^    static mc_fbtrace_info_t* increfOrNull($/;"	f	struct:facebook::memcache::McRequestBase::McFbtraceRefPolicy
increfOrNull	.\lib\test\RequestReplyTest.cpp	/^  static mc_msg_t* increfOrNull(mc_msg_t* msg) {$/;"	f	struct:TestRefPolicy
increfs	.\lib\test\RequestReplyTest.cpp	/^static unordered_map<mc_msg_t*, int> increfs, decrefs;$/;"	v	file:
increment	.\lib\fbi\cpp\Trie-inl.h	/^  void increment() {$/;"	f	class:facebook::memcache::Trie::iterator_base
increment	.\lib\fbi\test\asox_queue_test.cpp	/^  int increment;$/;"	m	struct:thread_arg_t	file:
increment	.\lib\fbi\test\asox_sem_test.cpp	/^  int increment;$/;"	m	struct:__anon20::test_arg_t	file:
incrementSoftTkoCount	.\TkoTracker.cpp	/^bool TkoTracker::incrementSoftTkoCount() {$/;"	f	class:facebook::memcache::mcrouter::TkoTracker
index	.\lib\fbi\nstring.h	/^  size_t index;$/;"	m	struct:nstring_map_sorted_iter_s
indexInPool	.\ProxyClientCommon.h	/^  size_t indexInPool;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientCommon
index_range_rv	.\proxy.h	/^    std::string index_range_rv;$/;"	m	struct:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t::Data
inflightThrottleFlushTest	.\lib\network\test\AsyncMcClientTest.cpp	/^void inflightThrottleFlushTest(bool useSsl = false) {$/;"	f
inflightThrottleTest	.\lib\network\test\AsyncMcClientTest.cpp	/^void inflightThrottleTest(bool useSsl = false) {$/;"	f
infoVersion_	.\routes\BigValueRoute.h	/^    const uint32_t infoVersion_;$/;"	m	class:facebook::memcache::BigValueRoute::ChunksInfo
initFailureLogger	.\mcrouter_config.cpp	/^void initFailureLogger() { }$/;"	f	namespace:facebook::memcache::mcrouter
initFromPrefix	.\RoutingPrefix.cpp	/^void RoutingPrefix::initFromPrefix() {$/;"	f	class:facebook::memcache::mcrouter::RoutingPrefix
initFromPrefixUnsafe	.\RoutingPrefix.cpp	/^void RoutingPrefix::initFromPrefixUnsafe() {$/;"	f	class:facebook::memcache::mcrouter::RoutingPrefix
initParams	.\lib\config\ConfigPreprocessor.cpp	/^  void initParams(const vector<dynamic>& params) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::Macro	file:
init_proxy_event_priorities	.\priorities.cpp	/^void init_proxy_event_priorities(proxy_t* proxy) {$/;"	f	namespace:facebook::memcache::mcrouter
init_stats	.\stats.cpp	/^void init_stats(stat_t* stats) {$/;"	f	namespace:facebook::memcache::mcrouter
initializeAsyncMcClient	.\DestinationClient.cpp	/^void DestinationClient::initializeAsyncMcClient() {$/;"	f	class:facebook::memcache::mcrouter::DestinationClient
inotify_	.\FileDataProvider.h	/^  folly::File inotify_;$/;"	m	class:facebook::memcache::mcrouter::FileDataProvider
inputPacket	.\lib\network\test\SessionTestHarness.cpp	/^void SessionTestHarness::inputPacket(folly::StringPiece p) {$/;"	f	class:facebook::memcache::SessionTestHarness
inputPackets	.\lib\network\test\SessionTestHarness.h	/^  void inputPackets() {}$/;"	f	class:facebook::memcache::SessionTestHarness
inputPackets	.\lib\network\test\SessionTestHarness.h	/^  void inputPackets(folly::StringPiece p, Args&&... args) {$/;"	f	class:facebook::memcache::SessionTestHarness
insert	.\mcrouter_config.h	/^  std::pair<iterator, bool> insert(std::pair<folly::StringPiece, Value> val) {$/;"	f	class:facebook::memcache::mcrouter::StringKeyedUnorderedMap
insertHead	.\lib\fbi\cpp\AtomicLinkedList.h	/^  bool insertHead(T* t) {$/;"	f	class:facebook::memcache::AtomicLinkedList
insertSample	.\ExponentialSmoothData.cpp	/^void ExponentialSmoothData::insertSample(double sample) {$/;"	f	class:facebook::memcache::mcrouter::ExponentialSmoothData
inside_on_elem_ready	.\lib\fbi\asox_queue.c	/^  bool inside_on_elem_ready;$/;"	m	struct:asox_queue_s	file:
installShutdownHandler	.\lib\network\AsyncMcServer.cpp	/^void AsyncMcServer::installShutdownHandler(const std::vector<int>& signals) {$/;"	f	class:facebook::memcache::AsyncMcServer
int64	.\stats.h	/^    int64_t int64;$/;"	m	union:facebook::memcache::mcrouter::stat_t::__anon63
intMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic intMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
integer	.\options.h	/^    integer,$/;"	m	class:facebook::memcache::McrouterOptionData::Type
intervalSec_	.\lib\routes\MigrateRoute.h	/^  time_t intervalSec_;$/;"	m	class:facebook::memcache::MigrateRoute
inuse	.\lib\mc\umbrella.h	/^  int inuse;$/;"	m	struct:um_backing_msg_s
invalid_config	.\test\test_validate_config.py	/^    invalid_config = 'mcrouter\/test\/invalid_config.json'$/;"	v	class:TestValidateConfig
iovs	.\lib\mc\umbrella.h	/^  struct iovec* iovs;       \/\/ Pointer to the array of iovs$/;"	m	struct:extern_iov_s	typeref:struct:extern_iov_s::iovec
iovsCount_	.\lib\network\McSerializedRequest.h	/^  size_t iovsCount_;$/;"	m	class:facebook::memcache::McSerializedRequest
iovs_	.\lib\network\McSerializedRequest.h	/^  struct iovec iovs_[kMaxIovs];$/;"	m	class:facebook::memcache::McSerializedRequest	typeref:struct:facebook::memcache::McSerializedRequest::iovec
iovs_	.\lib\network\UmbrellaProtocol.h	/^  struct iovec iovs_[kMaxIovs];$/;"	m	class:facebook::memcache::UmbrellaSerializedReply	typeref:struct:facebook::memcache::UmbrellaSerializedReply::iovec
iovs_	.\lib\network\WriteBuffer.h	/^  struct iovec iovs_[kMaxIovs];$/;"	m	class:facebook::memcache::AsciiSerializedReply	typeref:struct:facebook::memcache::AsciiSerializedReply::iovec
ipAddress	.\lib\McReplyBase.h	/^  const struct in6_addr& ipAddress() const {$/;"	f	class:facebook::memcache::McReplyBase
ip_addr	.\lib\mc\msg.h	/^  struct in6_addr ip_addr; \/\/\/< metaget$/;"	m	struct:mc_msg_s	typeref:struct:mc_msg_s::in6_addr
ipv	.\lib\McReplyBase.h	/^  uint8_t ipv() const {$/;"	f	class:facebook::memcache::McReplyBase
ipv	.\lib\mc\msg.h	/^  uint8_t ipv; \/\/\/< metaget$/;"	m	struct:mc_msg_s
ipv4_addr_loopback	.\lib\fbi\network.h	/^static inline bool ipv4_addr_loopback(const struct in_addr *a) {$/;"	f
ipv6_addr_loopback	.\lib\fbi\network.h	/^static inline bool ipv6_addr_loopback(const struct in6_addr *a) {$/;"	f
isActive	.\awriter.h	/^  bool isActive() const {$/;"	f	class:facebook::memcache::mcrouter::AsyncWriter
isAlive	.\lib\network\AsyncMcServerWorker.h	/^  bool isAlive() const {$/;"	f	class:facebook::memcache::AsyncMcServerWorker
isArrayMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic isArrayMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
isBoolMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic isBoolMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
isConnectError	.\lib\McReplyBase.h	/^  bool isConnectError() const {$/;"	f	class:facebook::memcache::McReplyBase
isConnectTimeout	.\lib\McReplyBase.h	/^  bool isConnectTimeout() const {$/;"	f	class:facebook::memcache::McReplyBase
isDataTimeout	.\lib\McReplyBase.h	/^  bool isDataTimeout() const {$/;"	f	class:facebook::memcache::McReplyBase
isError	.\lib\McReplyBase.cpp	/^bool McReplyBase::isError() const {$/;"	f	class:facebook::memcache::McReplyBase
isFailoverDisabledForRequest	.\routes\FailoverWithExptimeRoute.h	/^  bool isFailoverDisabledForRequest(const ProxyMcRequest& req) const {$/;"	f	class:facebook::memcache::mcrouter::FailoverWithExptimeRoute
isFailoverDisabledForRequest	.\routes\FailoverWithExptimeRoute.h	/^  bool isFailoverDisabledForRequest(const Request& req) const {$/;"	f	class:facebook::memcache::mcrouter::FailoverWithExptimeRoute
isFailoverError	.\lib\McReplyBase.cpp	/^bool McReplyBase::isFailoverError() const {$/;"	f	class:facebook::memcache::McReplyBase
isHardTko	.\TkoTracker.cpp	/^bool TkoTracker::isHardTko() const {$/;"	f	class:facebook::memcache::mcrouter::TkoTracker
isHardTkoError	.\lib\McReplyBase.cpp	/^bool McReplyBase::isHardTkoError() const {$/;"	f	class:facebook::memcache::McReplyBase
isHit	.\lib\McReplyBase.h	/^  bool isHit() const {$/;"	f	class:facebook::memcache::McReplyBase
isIntMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic isIntMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
isMiss	.\lib\McReplyBase.h	/^  bool isMiss() const {$/;"	f	class:facebook::memcache::McReplyBase
isObjectMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic isObjectMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
isPartOfMultiget	.\lib\network\McServerSession.cpp	/^bool isPartOfMultiget(mc_protocol_t protocol, mc_op_t operation) {$/;"	f	namespace:facebook::memcache::__anon41
isPaused	.\lib\test\RouteHandleTestUtil.h	/^  bool isPaused;$/;"	m	struct:facebook::memcache::TestHandle
isRedirect	.\lib\McReplyBase.h	/^  bool isRedirect() const {$/;"	f	class:facebook::memcache::McReplyBase
isResponsible	.\TkoTracker.cpp	/^bool TkoTracker::isResponsible(ProxyDestination* pdstn) const {$/;"	f	class:facebook::memcache::mcrouter::TkoTracker
isSafeToDeleteProxy	.\ProxyThread.h	/^  bool isSafeToDeleteProxy;$/;"	m	class:facebook::memcache::mcrouter::ProxyThread
isSoftTko	.\TkoTracker.cpp	/^bool TkoTracker::isSoftTko() const {$/;"	f	class:facebook::memcache::mcrouter::TkoTracker
isSoftTkoError	.\lib\McReplyBase.cpp	/^bool McReplyBase::isSoftTkoError() const {$/;"	f	class:facebook::memcache::McReplyBase
isStored	.\lib\McReplyBase.h	/^  bool isStored() const {$/;"	f	class:facebook::memcache::McReplyBase
isStringMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic isStringMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
isTko	.\TkoTracker.h	/^  bool isTko() const {$/;"	f	class:facebook::memcache::mcrouter::TkoTracker
isTko	.\lib\McReplyBase.h	/^  bool isTko() const {$/;"	f	class:facebook::memcache::McReplyBase
isTko	.\lib\test\RouteHandleTestUtil.h	/^  bool isTko;$/;"	m	struct:facebook::memcache::TestHandle
isZombie	.\mcrouter_client.h	/^  bool isZombie;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_t
is_alive	.\test\MCProcess.py	/^    def is_alive(self):$/;"	m	class:MCProcess
is_root	.\lib\fbi\unix.h	/^static inline int is_root() {$/;"	f
is_stopped	.\test\mock_servers.py	/^    def is_stopped(self):$/;"	m	class:MockServer
is_transient	.\_router.h	/^  bool is_transient;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
is_valid_router_name	.\router.cpp	/^static bool is_valid_router_name(const std::string& name) {$/;"	f	namespace:facebook::memcache::mcrouter
issueRequests	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^bool MCRouterTestClient::issueRequests(const mcrouter_msg_t* msgs,$/;"	f	class:MCRouterTestClient
issue_command	.\test\MCProcess.py	/^    def issue_command(self, command):$/;"	m	class:MCProcess
item	.\lib\network\test\MockMc.h	/^    Item item;$/;"	m	struct:facebook::memcache::MockMc::CacheItem
iterator	.\lib\fbi\cpp\Trie.h	/^  typedef iterator_base<Trie, value_type> iterator;$/;"	t	class:facebook::memcache::Trie
iterator_base	.\lib\fbi\cpp\Trie-inl.h	/^  explicit iterator_base(T* trie)$/;"	f	class:facebook::memcache::Trie::iterator_base
iterator_base	.\lib\fbi\cpp\Trie-inl.h	/^  iterator_base()$/;"	f	class:facebook::memcache::Trie::iterator_base
iterator_base	.\lib\fbi\cpp\Trie-inl.h	/^class Trie<Value, MinChar, MaxChar>::iterator_base$/;"	c	class:facebook::memcache::Trie
iterator_to	.\lib\network\UniqueIntrusiveList.h	/^  iterator iterator_to(T& t) {$/;"	f	class:facebook::memcache::UniqueIntrusiveList
ix	.\lib\fbi\nstring.h	/^  size_t ix;$/;"	m	struct:nstring_map_iter_s
join	.\lib\network\AsyncMcServer.cpp	/^  void join() {$/;"	f	class:facebook::memcache::McServerThread
join	.\lib\network\AsyncMcServer.cpp	/^void AsyncMcServer::join() {$/;"	f	class:facebook::memcache::AsyncMcServer
join	.\lib\network\test\AsyncMcClientTest.cpp	/^  void join() {$/;"	f	class:__anon42::TestServer
joinAuxiliaryThreads	.\router.cpp	/^void mcrouter_t::joinAuxiliaryThreads() {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
json	.\test\test_async_files.py	/^import json$/;"	i
json_	.\ProxyConfigBuilder.h	/^  folly::dynamic json_;$/;"	m	class:facebook::memcache::mcrouter::ProxyConfigBuilder
jumpContext	.\lib\fibers\BoostContextCompatibility.h	/^inline intptr_t jumpContext(FContext* oldC, FContext::ContextStruct* newC,$/;"	f	namespace:facebook::memcache
jumpContext	.\lib\fibers\BoostContextCompatibility.h	/^inline intptr_t jumpContext(FContext::ContextStruct* oldC, FContext* newC,$/;"	f	namespace:facebook::memcache
kAbsoluteFilePrefix	.\ConfigApi.cpp	/^const char* const ConfigApi::kAbsoluteFilePrefix = "file:";$/;"	m	class:facebook::memcache::mcrouter::ConfigApi	file:
kAbsoluteFilePrefix	.\ConfigApi.h	/^  static const char* const kAbsoluteFilePrefix;$/;"	m	class:facebook::memcache::mcrouter::ConfigType::ConfigApi
kAdjustBufferSizeInterval	.\lib\network\McParser.cpp	/^const size_t kAdjustBufferSizeInterval = 10000;$/;"	m	namespace:facebook::memcache	file:
kAlreadyRepliedConfig	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	/^const std::string kAlreadyRepliedConfig =$/;"	v
kBadEnvironment	.\lib\fbi\cpp\LogFailure.cpp	/^const char* const Category::kBadEnvironment = "bad-environment";$/;"	m	class:facebook::memcache::failure::Category	file:
kBadEnvironment	.\lib\fbi\cpp\LogFailure.h	/^  static const char* const kBadEnvironment;$/;"	m	class:facebook::memcache::failure::Category
kBprDecay	.\lib\network\McParser.cpp	/^const double kBprDecay = 0.9;$/;"	m	namespace:facebook::memcache	file:
kBrokenLogic	.\lib\fbi\cpp\LogFailure.cpp	/^const char* const Category::kBrokenLogic = "broken-logic";$/;"	m	class:facebook::memcache::failure::Category	file:
kBrokenLogic	.\lib\fbi\cpp\LogFailure.h	/^  static const char* const kBrokenLogic;$/;"	m	class:facebook::memcache::failure::Category
kConfig	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^const std::string kConfig =$/;"	m	namespace:facebook::memcache::test	file:
kConfigFile	.\ConfigApi.cpp	/^const char* const kConfigFile = "config_file";$/;"	m	namespace:facebook::memcache::mcrouter	file:
kConfigImport	.\ConfigApi.cpp	/^const char* const kConfigImport = "config_import";$/;"	m	namespace:facebook::memcache::mcrouter	file:
kConfigReloadInterval	.\ConfigApi.cpp	/^const int kConfigReloadInterval = 60;$/;"	m	namespace:facebook::memcache::mcrouter	file:
kConfigSourcesInfoFileName	.\McrouterLogger.cpp	/^const char* kConfigSourcesInfoFileName = "config_sources_info";$/;"	m	namespace:facebook::memcache::mcrouter::__anon46	file:
kConstShard	.\test\cpp_unit_tests\mc_route_handle_provider_test.cpp	/^static const std::string kConstShard =$/;"	v	file:
kDeadBeef	.\ProxyDestination.h	/^  static const uint64_t kDeadBeef = 0xdeadbeefdeadbeefULL;$/;"	m	struct:facebook::memcache::mcrouter::ProxyDestination
kFailoverHostPortSeparator	.\routes\FailoverWithExptimeRoute.h	/^const char kFailoverHostPortSeparator = '@';$/;"	m	namespace:facebook::memcache::mcrouter
kFailoverTagStart	.\routes\FailoverWithExptimeRoute.h	/^const std::string kFailoverTagStart = ":failover=";$/;"	m	namespace:facebook::memcache::mcrouter
kFromMask	.\lib\routes\MigrateRoute.h	/^  static constexpr int kFromMask = 1;$/;"	m	class:facebook::memcache::MigrateRoute
kGlobalParams	.\lib\config\test\config_preprocessor_test.cpp	/^const std::unordered_map<std::string, folly::dynamic> kGlobalParams = {$/;"	v
kHashSeed	.\lib\WeightedCh3HashFunc.cpp	/^const uint32_t kHashSeed = 0xface2014;$/;"	m	namespace:facebook::memcache::__anon45	file:
kHostName	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^const std::string MemcacheLocal::kHostName = "localhost";$/;"	m	class:facebook::memcache::test::MemcacheLocal	file:
kHostName	.\test\cpp_unit_tests\MemcacheLocal.h	/^  const static std::string kHostName, kMemcachedPath, kMemcachedBin;$/;"	m	class:facebook::memcache::test::MemcacheLocal
kInfinity	.\lib\fbi\cpp\ObjectPool.h	/^const size_t kInfinity = std::numeric_limits<size_t>::max();$/;"	m	namespace:facebook::memcache
kInlineEntries	.\lib\network\UmbrellaProtocol.h	/^  static constexpr size_t kInlineEntries = 16;$/;"	m	class:facebook::memcache::UmbrellaSerializedReply
kInlineStrings	.\lib\network\UmbrellaProtocol.h	/^  static constexpr size_t kInlineStrings = 16;$/;"	m	class:facebook::memcache::UmbrellaSerializedReply
kInternalGetPrefix	.\proxy.cpp	/^const std::string kInternalGetPrefix = "__mcrouter__.";$/;"	m	namespace:facebook::memcache::mcrouter	file:
kInvalidConfig	.\lib\fbi\cpp\LogFailure.cpp	/^const char* const Category::kInvalidConfig = "invalid-config";$/;"	m	class:facebook::memcache::failure::Category	file:
kInvalidConfig	.\lib\fbi\cpp\LogFailure.h	/^  static const char* const kInvalidConfig;$/;"	m	class:facebook::memcache::failure::Category
kInvalidOption	.\lib\fbi\cpp\LogFailure.cpp	/^const char* const Category::kInvalidOption = "invalid-option";$/;"	m	class:facebook::memcache::failure::Category	file:
kInvalidOption	.\lib\fbi\cpp\LogFailure.h	/^  static const char* const kInvalidOption;$/;"	m	class:facebook::memcache::failure::Category
kInvalidPoolConfig	.\test\cpp_unit_tests\libmcrouter_test.cpp	/^std::string kInvalidPoolConfig =$/;"	v
kLastItemId	.\routes\McOpList.h	/^  static constexpr int kLastItemId = 20;$/;"	m	struct:facebook::memcache::McOpList
kMagic8Bytes	.\lib\fibers\Fiber.cpp	/^static const uint64_t kMagic8Bytes = 0xfaceb00cfaceb00c;$/;"	m	namespace:facebook::memcache::__anon29	file:
kMaxFreeQueueSz	.\lib\network\WriteBuffer.h	/^  constexpr static size_t kMaxFreeQueueSz = 50;$/;"	m	class:facebook::memcache::WriteBufferQueue
kMaxIovs	.\lib\network\McSerializedRequest.h	/^  static const size_t kMaxIovs = 20;$/;"	m	class:facebook::memcache::McSerializedRequest
kMaxIovs	.\lib\network\UmbrellaProtocol.h	/^  static constexpr size_t kMaxIovs = 16;$/;"	m	class:facebook::memcache::UmbrellaSerializedReply
kMaxIovs	.\lib\network\WriteBuffer.h	/^  static const size_t kMaxIovs = 16;$/;"	m	class:facebook::memcache::AsciiSerializedReply
kMaxKeySaltSize	.\lib\routes\HashRoute.h	/^  static const size_t kMaxKeySaltSize = 512;$/;"	m	class:facebook::memcache::HashRoute
kMaxSplits	.\routes\ShardSplitter.cpp	/^constexpr size_t kMaxSplits = 26 * 26;$/;"	m	namespace:facebook::memcache::mcrouter	file:
kMcrouterConfigKey	.\ConfigApi.cpp	/^const char* const kMcrouterConfigKey = "mcrouter_config";$/;"	m	namespace:facebook::memcache::mcrouter	file:
kMemcachedBin	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^const std::string MemcacheLocal::kMemcachedBin = "mock_mc_server";$/;"	m	class:facebook::memcache::test::MemcacheLocal	file:
kMemcachedBin	.\test\cpp_unit_tests\MemcacheLocal.h	/^  const static std::string kHostName, kMemcachedPath, kMemcachedBin;$/;"	m	class:facebook::memcache::test::MemcacheLocal
kMemcachedPath	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^const std::string MemcacheLocal::kMemcachedPath$/;"	m	class:facebook::memcache::test::MemcacheLocal	file:
kMemcachedPath	.\test\cpp_unit_tests\MemcacheLocal.h	/^  const static std::string kHostName, kMemcachedPath, kMemcachedBin;$/;"	m	class:facebook::memcache::test::MemcacheLocal
kNumChars	.\lib\fbi\cpp\Trie.h	/^  static size_t const kNumChars = (size_t)(MaxChar - MinChar) + 1;$/;"	m	class:facebook::memcache::Trie
kNumGetKeys	.\lib\fbi\cpp\test\TrieBenchmarks.cpp	/^static int const kNumGetKeys = 7;$/;"	v	file:
kNumRandKeys	.\lib\fbi\cpp\test\TrieTests.cpp	/^static int const kNumRandKeys = 1<<15;$/;"	v	file:
kNumTries	.\lib\WeightedCh3HashFunc.cpp	/^const size_t kNumTries = 32;$/;"	m	namespace:facebook::memcache::__anon45	file:
kOther	.\lib\fbi\cpp\LogFailure.cpp	/^const char* const Category::kOther = "other";$/;"	m	class:facebook::memcache::failure::Category	file:
kOther	.\lib\fbi\cpp\LogFailure.h	/^  static const char* const kOther;$/;"	m	class:facebook::memcache::failure::Category
kOutOfResources	.\lib\fbi\cpp\LogFailure.cpp	/^const char* const Category::kOutOfResources = "out-of-resources";$/;"	m	class:facebook::memcache::failure::Category	file:
kOutOfResources	.\lib\fbi\cpp\LogFailure.h	/^  static const char* const kOutOfResources;$/;"	m	class:facebook::memcache::failure::Category
kPemCaPath	.\lib\network\test\AsyncMcClientTest.cpp	/^const char* kPemCaPath = "mcrouter\/lib\/network\/test\/ca_cert.pem";$/;"	m	namespace:__anon42	file:
kPemCertPath	.\lib\network\test\AsyncMcClientTest.cpp	/^const char* kPemCertPath = "mcrouter\/lib\/network\/test\/test_cert.pem";$/;"	m	namespace:__anon42	file:
kPemKeyPath	.\lib\network\test\AsyncMcClientTest.cpp	/^const char* kPemKeyPath = "mcrouter\/lib\/network\/test\/test_key.pem";$/;"	m	namespace:__anon42	file:
kPoolRoute	.\test\cpp_unit_tests\mc_route_handle_provider_test.cpp	/^static const std::string kPoolRoute =$/;"	v	file:
kPortRangeBegin	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^const int MemcacheLocal::kPortRangeBegin = 40000;$/;"	m	class:facebook::memcache::test::MemcacheLocal	file:
kPortRangeBegin	.\test\cpp_unit_tests\MemcacheLocal.h	/^  const static int kPortRangeBegin, kPortRangeEnd;$/;"	m	class:facebook::memcache::test::MemcacheLocal
kPortRangeEnd	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^const int MemcacheLocal::kPortRangeEnd = 50000;$/;"	m	class:facebook::memcache::test::MemcacheLocal	file:
kPortRangeEnd	.\test\cpp_unit_tests\MemcacheLocal.h	/^  const static int kPortRangeBegin, kPortRangeEnd;$/;"	m	class:facebook::memcache::test::MemcacheLocal
kPortSearchOut	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^const int MemcacheLocal::kPortSearchOut = 20;$/;"	m	class:facebook::memcache::test::MemcacheLocal	file:
kPortSearchOut	.\test\cpp_unit_tests\MemcacheLocal.h	/^  const static int kPortSearchOut;$/;"	m	class:facebook::memcache::test::MemcacheLocal
kProbeExponentialFactor	.\ProxyDestination.cpp	/^constexpr double kProbeExponentialFactor = 1.5;$/;"	m	namespace:facebook::memcache::mcrouter::__anon53	file:
kProbeJitterDelta	.\ProxyDestination.cpp	/^constexpr double kProbeJitterDelta = kProbeJitterMax - kProbeJitterMin;$/;"	m	namespace:facebook::memcache::mcrouter::__anon53	file:
kProbeJitterMax	.\ProxyDestination.cpp	/^constexpr double kProbeJitterMax = 0.5;$/;"	m	namespace:facebook::memcache::mcrouter::__anon53	file:
kProbeJitterMin	.\ProxyDestination.cpp	/^constexpr double kProbeJitterMin = 0.05;$/;"	m	namespace:facebook::memcache::mcrouter::__anon53	file:
kReadBufferSizeMax	.\lib\network\AsyncMcClientImpl.cpp	/^constexpr size_t kReadBufferSizeMax = 4096;$/;"	m	namespace:facebook::memcache	file:
kReadBufferSizeMin	.\lib\network\AsyncMcClientImpl.cpp	/^constexpr size_t kReadBufferSizeMin = 256;$/;"	m	namespace:facebook::memcache	file:
kStatsSfx	.\McrouterLogger.cpp	/^const char* kStatsSfx = "stats";$/;"	m	namespace:facebook::memcache::mcrouter::__anon46	file:
kStatsStartupOptionsSfx	.\McrouterLogger.cpp	/^const char* kStatsStartupOptionsSfx = "startup_options";$/;"	m	namespace:facebook::memcache::mcrouter::__anon46	file:
kSystemError	.\lib\fbi\cpp\LogFailure.cpp	/^const char* const Category::kSystemError = "system-error";$/;"	m	class:facebook::memcache::failure::Category	file:
kSystemError	.\lib\fbi\cpp\LogFailure.h	/^  static const char* const kSystemError;$/;"	m	class:facebook::memcache::failure::Category
kTestFile	.\lib\config\test\config_preprocessor_test.cpp	/^const std::string kTestFile =$/;"	v
kTestFileComments	.\lib\config\test\config_preprocessor_test.cpp	/^const std::string kTestFileComments =$/;"	v
kTestFileErrors	.\lib\config\test\config_preprocessor_test.cpp	/^const std::string kTestFileErrors =$/;"	v
kTimeout	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^const int MemcacheLocal::kTimeout = 10;$/;"	m	class:facebook::memcache::test::MemcacheLocal	file:
kTimeout	.\test\cpp_unit_tests\MemcacheLocal.h	/^  const static int kTimeout;$/;"	m	class:facebook::memcache::test::MemcacheLocal
kToMask	.\lib\routes\MigrateRoute.h	/^  static constexpr int kToMask = 2;$/;"	m	class:facebook::memcache::MigrateRoute
kUserBufferSize	.\lib\fibers\Fiber.h	/^  static constexpr size_t kUserBufferSize = 256;$/;"	m	class:facebook::memcache::Fiber
kWarmUp	.\test\cpp_unit_tests\mc_route_handle_provider_test.cpp	/^static const std::string kWarmUp =$/;"	v	file:
keep_routing_prefix	.\ProxyClientCommon.h	/^  int keep_routing_prefix;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientCommon
keep_routing_prefix	.\proxy.h	/^  int keep_routing_prefix;$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
key	.\lib\McRequestBase.h	/^  const folly::IOBuf& key() const {$/;"	f	class:facebook::memcache::McRequestBase
key	.\lib\fbi\nstring.h	/^  nstring_t key;$/;"	m	struct:nstring_map_entry_s
key	.\lib\fbi\skiplist.h	/^  uint32_t key;$/;"	m	struct:skiplist_node_s
key	.\lib\mc\msg.h	/^  nstring_t key; \/\/\/< get\/set key, stats arg, flushre regexp$/;"	m	struct:mc_msg_s
key	.\pclient.h	/^  std::string key;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientShared
keyData_	.\lib\McRequestBase.h	/^  folly::IOBuf keyData_;$/;"	m	class:facebook::memcache::McRequestBase
keyWithFailoverTag	.\routes\FailoverWithExptimeRoute.h	/^  static std::string keyWithFailoverTag(const ProxyMcRequest& req,$/;"	f	class:facebook::memcache::mcrouter::FailoverWithExptimeRoute
keyWithFailoverTag	.\routes\FailoverWithExptimeRoute.h	/^  static std::string keyWithFailoverTag(const Request& req,$/;"	f	class:facebook::memcache::mcrouter::FailoverWithExptimeRoute
keyWithoutRoute	.\lib\McRequestBase.cpp	/^folly::StringPiece McRequestBase::keyWithoutRoute() const {$/;"	f	class:facebook::memcache::McRequestBase
keyWithoutRoute	.\lib\McRequestBase.h	/^    folly::StringPiece keyWithoutRoute;$/;"	m	struct:facebook::memcache::McRequestBase::Keys
key_	.\lib\network\McServerRequestContext.h	/^    folly::Optional<folly::IOBuf> key_;$/;"	m	struct:facebook::memcache::McServerRequestContext::AsciiState
key_fraction_range_rv	.\proxy.h	/^    std::string key_fraction_range_rv;$/;"	m	struct:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t::Data
key_idx	.\lib\mc\umbrella_protocol.c	/^  int key_idx;$/;"	m	struct:_parse_info_s	file:
keys	.\lib\fbi\cpp\test\TrieTests.cpp	/^static std::string keys[kNumRandKeys];$/;"	v	file:
keys	.\lib\fbi\nstring.h	/^  nstring_t keys[0];$/;"	m	struct:nstring_map_sorted_iter_s
keysMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic keysMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
keysToGet	.\lib\fbi\cpp\test\TrieBenchmarks.cpp	/^static std::string keysToGet[kNumGetKeys] = {$/;"	v	file:
keys_	.\lib\McRequestBase.h	/^  } keys_;$/;"	m	class:facebook::memcache::McRequestBase	typeref:struct:facebook::memcache::McRequestBase::Keys
known_protocol	.\lib\mc\parser.h	/^  mc_protocol_t known_protocol; \/\/\/< protocol we are parsing$/;"	m	struct:parser_s
lastLoadTime	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^  std::chrono::time_point<std::chrono::steady_clock> lastLoadTime;$/;"	m	struct:facebook::memcache::ContextInfo	file:
lastUpdateTime_	.\TokenBucket.h	/^  double lastUpdateTime_;$/;"	m	class:facebook::memcache::mcrouter::TokenBucket
last_config_attempt	.\_router.h	/^  time_t last_config_attempt;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
last_time	.\lib\fbi\debug.c	/^  timeval_t last_time;$/;"	m	struct:msg_info	file:
lastfile	.\lib\fbi\queue.h	/^        char * lastfile;$/;"	m	struct:qm_trace
lastline	.\lib\fbi\queue.h	/^        int lastline;$/;"	m	struct:qm_trace
latency_avg_power	.\lib\fbi\timer.h	/^  int latency_avg_power;$/;"	m	struct:fb_timer_s
latency_countdown	.\lib\fbi\timer.h	/^  int latency_countdown;$/;"	m	struct:fb_timer_s
leaseGet	.\lib\network\test\MockMc.cpp	/^std::pair<MockMc::Item*, uint64_t> MockMc::leaseGet(folly::StringPiece key) {$/;"	f	class:facebook::memcache::MockMc
leaseGet	.\test\MCProcess.py	/^    def leaseGet(self, keys):$/;"	m	class:MCProcess
leaseSet	.\lib\network\test\MockMc.cpp	/^MockMc::LeaseSetResult MockMc::leaseSet(folly::StringPiece key, Item item,$/;"	f	class:facebook::memcache::MockMc
leaseSet	.\test\MCProcess.py	/^    def leaseSet(self, key, value_token, is_stalestored=False):$/;"	m	class:MCProcess
leaseToken	.\lib\McReplyBase.h	/^  uint64_t leaseToken() const {$/;"	f	class:facebook::memcache::McReplyBase
leaseToken	.\lib\McRequestBase.h	/^  uint64_t leaseToken() const {$/;"	f	class:facebook::memcache::McRequestBase
lease_id	.\lib\mc\msg.h	/^  uint64_t lease_id;$/;"	m	struct:mc_msg_s
legacy_get_service_info	.\proxy.h	/^  bool legacy_get_service_info;$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t
len	.\lib\fbi\nstring.h	/^  size_t len;$/;"	m	struct:nstring_s
len	.\lib\mc\umbrella.h	/^      uint32_t len;     \/\/   How long is the string?$/;"	m	struct:um_elist_entry_s::__anon34::__anon35
len	.\lib\mc\umbrella.h	/^  uint32_t len;       \/\/ How long is it?$/;"	m	struct:extern_string_s
lessMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic lessMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
level	.\lib\fbi\skiplist.h	/^  int level;$/;"	m	struct:skiplist_s
lfca_alloc	.\lib\fbi\lfcalloc.c	/^void *lfca_alloc(lfchunk_allocator_t *a, size_t size) {$/;"	f
lfca_init	.\lib\fbi\lfcalloc.c	/^void lfca_init(lfchunk_allocator_t *a, void *buf, size_t size) {$/;"	f
lfca_reinit	.\lib\fbi\lfcalloc.c	/^void lfca_reinit(lfchunk_allocator_t *a, void *buf, size_t size) {$/;"	f
lfca_space_left	.\lib\fbi\lfcalloc.c	/^size_t lfca_space_left(lfchunk_allocator_t *a) {$/;"	f
lfchunk_allocator_t	.\lib\fbi\lfcalloc.h	/^} lfchunk_allocator_t;$/;"	t	typeref:struct:__anon12
libasox_queuetest_multicount_common	.\lib\fbi\test\asox_queue_test.cpp	/^void libasox_queuetest_multicount_common(asox_queue_flags_t flags) {$/;"	f	namespace:__anon17
limit	.\lib\fbi\lfcalloc.h	/^  void *limit;$/;"	m	struct:__anon12
line	.\lib\fbi\debug.c	/^  int line;$/;"	m	struct:msg_info	file:
lineno	.\lib\fbi\error.h	/^  int lineno; \/\/!< Source code line number$/;"	m	struct:fbi_err_s
links	.\awriter.h	/^  TAILQ_ENTRY(awriter_entry_t) links;$/;"	m	struct:facebook::memcache::mcrouter::awriter_entry_t
listHook_	.\lib\fibers\TimeoutController.h	/^  ListHook listHook_;$/;"	m	class:facebook::memcache::TimeoutHandle
list_	.\lib\network\UniqueIntrusiveList.h	/^  folly::CountedIntrusiveList<T, PtrToMember> list_;$/;"	m	class:facebook::memcache::UniqueIntrusiveList
live_clients	.\_router.h	/^  std::atomic<int> live_clients;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
load	.\FileDataProvider.cpp	/^std::string FileDataProvider::load() const {$/;"	f	class:facebook::memcache::mcrouter::FileDataProvider
localThreadId	.\lib\fibers\Fiber.cpp	/^pid_t localThreadId() {$/;"	f	namespace:facebook::memcache::__anon29
local_queue	.\lib\fbi\asox_queue.c	/^  asox_queue_entry_t *local_queue;$/;"	m	struct:asox_queue_s	file:
lock	.\lib\fbi\cpp\LogFailure.cpp	/^  std::mutex lock;$/;"	m	struct:facebook::memcache::failure::__anon9::StaticContainer	file:
lock	.\lib\fbi\cpp\ShutdownLock.h	/^  void lock() {$/;"	f	class:facebook::memcache::ShutdownLock
lock	.\lib\fbi\cpp\sfrlock.h	/^  void lock() {$/;"	f	class:SFRReadLock
lock	.\lib\fbi\cpp\sfrlock.h	/^  void lock() {$/;"	f	class:SFRWriteLock
lock	.\lib\fbi\test\asox_queue_test.cpp	/^  pthread_rwlock_t *lock;$/;"	m	struct:__anon19::Info	file:
lock	.\test\cpp_unit_tests\awriter_test.cpp	/^  pthread_mutex_t lock;$/;"	m	class:AtomicCounter	file:
lock_	.\lib\fbi\cpp\ShutdownLock.h	/^  SFRLock lock_;$/;"	m	class:facebook::memcache::ShutdownLock
lock_	.\lib\fbi\cpp\sfrlock.h	/^  sfrlock_t lock_;$/;"	m	class:SFRLock
lock_	.\lib\fbi\cpp\sfrlock.h	/^  sfrlock_t* lock_;$/;"	m	class:SFRReadLock
lock_	.\lib\fbi\cpp\sfrlock.h	/^  sfrlock_t* lock_;$/;"	m	class:SFRWriteLock
log	.\McrouterLogger.cpp	/^void McrouterLogger::log() {$/;"	f	class:facebook::memcache::mcrouter::McrouterLogger
log	.\ProxyRequestLogger-inl.h	/^void ProxyRequestLogger::log(const ProxyClientCommon& pclient,$/;"	f	class:facebook::memcache::mcrouter::ProxyRequestLogger
log	.\lib\fbi\cpp\LogFailure.cpp	/^void log(folly::StringPiece service,$/;"	f	namespace:facebook::memcache::failure
log	.\lib\fbi\cpp\LogFailure.h	/^void log(folly::StringPiece service,$/;"	f	namespace:facebook::memcache::failure
logError	.\ProxyRequestLogger-inl.h	/^inline void logError(proxy_t& proxy, const McReplyBase& reply,$/;"	f	namespace:facebook::memcache::mcrouter::__anon55
logFailure	.\McrouterLogFailure.h	/^void logFailure(folly::StringPiece category, folly::StringPiece msg,$/;"	f	namespace:facebook::memcache::mcrouter
logFailure	.\McrouterLogFailure.h	/^void logFailure(mcrouter_t* router,$/;"	f	namespace:facebook::memcache::mcrouter
logOutlier	.\ProxyRequestLogger-inl.h	/^inline void logOutlier(proxy_t& proxy, McOperation<operation>,$/;"	f	namespace:facebook::memcache::mcrouter::__anon55
logRequestClass	.\ProxyRequestLogger-inl.h	/^inline void logRequestClass(proxy_t& proxy, McOperation<operation>,$/;"	f	namespace:facebook::memcache::mcrouter::__anon55
logStartupOptions	.\McrouterLogger.cpp	/^void McrouterLogger::logStartupOptions() {$/;"	f	class:facebook::memcache::mcrouter::McrouterLogger
logTkoEvent	.\mcrouter_config.cpp	/^void logTkoEvent(proxy_t* proxy, const TkoLog& tkoLog) { }$/;"	f	namespace:facebook::memcache::mcrouter
logToStdError	.\lib\fbi\cpp\LogFailure.cpp	/^std::pair<std::string, HandlerFunc> logToStdError() {$/;"	f	namespace:facebook::memcache::failure::handlers
logToStdErrorImpl	.\lib\fbi\cpp\LogFailure.cpp	/^void logToStdErrorImpl(folly::StringPiece service,$/;"	f	namespace:facebook::memcache::failure::__anon9
log_context	.\test\cpp_unit_tests\awriter_test.cpp	/^  writelog_entry_t log_context;$/;"	m	struct:testing_context_t	file:
logger	.\_router.h	/^  std::shared_ptr<RouterLogger> logger;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
loggerThreadCv_	.\McrouterLogger.h	/^  std::condition_variable loggerThreadCv_;$/;"	m	class:facebook::memcache::mcrouter::McrouterLogger
loggerThreadMutex_	.\McrouterLogger.h	/^  std::mutex loggerThreadMutex_;$/;"	m	class:facebook::memcache::mcrouter::McrouterLogger
loggerThreadRun	.\McrouterLogger.cpp	/^void McrouterLogger::loggerThreadRun() {$/;"	f	class:facebook::memcache::mcrouter::McrouterLogger
loggerThreadSleep	.\McrouterLogger.cpp	/^void McrouterLogger::loggerThreadSleep() {$/;"	f	class:facebook::memcache::mcrouter::McrouterLogger
loggerThread_	.\McrouterLogger.h	/^  std::thread loggerThread_;$/;"	m	class:facebook::memcache::mcrouter::McrouterLogger
logger_	.\LoggingProxyRequestContext.h	/^  ProxyRequestLogger logger_;$/;"	m	class:facebook::memcache::mcrouter::LoggingProxyRequestContext
lognormal_variate	.\lib\fbi\test\hash_test.cpp	/^uint32_t lognormal_variate(double mu, double sigma, uint32_t min_clip,$/;"	f	namespace:__anon22
long_option	.\options.h	/^  std::string long_option;$/;"	m	struct:facebook::memcache::McrouterOptionData
loop	.\lib\fibers\SimpleLoopController.h	/^  void loop(F&& func) {$/;"	f	class:facebook::memcache::SimpleLoopController
loop	.\lib\fibers\test\FibersTestApp.cpp	/^  void loop() {$/;"	f	struct:Application
loopController	.\lib\fibers\FiberManager.cpp	/^LoopController& FiberManager::loopController() {$/;"	f	class:facebook::memcache::FiberManager
loopController	.\lib\fibers\FiberManager.cpp	/^const LoopController& FiberManager::loopController() const {$/;"	f	class:facebook::memcache::FiberManager
loopController_	.\lib\fibers\FiberManager.h	/^  std::unique_ptr<LoopController> loopController_;$/;"	m	class:facebook::memcache::FiberManager
loopController_	.\lib\fibers\TimeoutController.h	/^  LoopController& loopController_;$/;"	m	class:facebook::memcache::TimeoutController
loopForever	.\lib\fibers\Fiber.cpp	/^static constexpr bool loopForever = true;$/;"	m	namespace:facebook::memcache	file:
loopForever	.\lib\fibers\Fiber.cpp	/^volatile bool loopForever = true;$/;"	m	namespace:facebook::memcache	file:
loopOnce	.\lib\network\test\AsyncMcClientTest.cpp	/^  void loopOnce() {$/;"	f	class:__anon42::TestClient
loopUntilNoReady	.\lib\fibers\FiberManager-inl.h	/^inline bool FiberManager::loopUntilNoReady() {$/;"	f	class:facebook::memcache::FiberManager
lowValue	.\lib\McReplyBase.h	/^  double lowValue() const {$/;"	f	class:facebook::memcache::McReplyBase
lowval	.\lib\mc\msg.h	/^  double lowval; \/\/\/< being used in counter ops$/;"	m	struct:mc_msg_s
m1	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  int m1, m2;$/;"	m	struct:TestType	file:
m2	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  int m1, m2;$/;"	m	struct:TestType	file:
macros_	.\lib\config\ConfigPreprocessor.h	/^  std::unordered_map<std::string, std::unique_ptr<Macro>> macros_;$/;"	m	class:facebook::memcache::ConfigPreprocessor
magic	.\lib\mc\msg.c	/^  uint32_t magic;$/;"	m	struct:nzlib_format_s	file:
magic	.\proxy.h	/^  uint64_t magic;$/;"	m	struct:facebook::memcache::mcrouter::proxy_t
magic_byte	.\lib\mc\umbrella.h	/^  int magic_byte;$/;"	m	struct:entry_list_msg_preparer_s
magic_byte	.\lib\mc\umbrella.h	/^  uint8_t magic_byte;$/;"	m	struct:entry_list_hdr_s
main	.\lib\fbi\cpp\test\TrieBenchmarks.cpp	/^int main(int argc, char **argv){$/;"	f
main	.\lib\fbi\cpp\test\TrieTests.cpp	/^int main(int argc, char **argv){$/;"	f
main	.\lib\fbi\examples\thread-errs.c	/^int main(int argc, char** argv) {$/;"	f
main	.\lib\fibers\test\FibersTestApp.cpp	/^int main() {$/;"	f
main	.\lib\fibers\test\main.cpp	/^int main(int argc, char** argv) {$/;"	f
main	.\lib\network\test\MockMcServer.cpp	/^int main(int argc, char** argv) {$/;"	f
main	.\lib\test\Main.cpp	/^int main(int argc, char** argv) {$/;"	f
main	.\main.cpp	/^int main(int argc, char **argv) {$/;"	f
main	.\routes\test\Main.cpp	/^int main(int argc, char** argv) {$/;"	f
main	.\test\cpp_unit_tests\libmcrouter_test.cpp	/^int main(int argc, char** argv) {$/;"	f
mainContext_	.\lib\fibers\FiberManager.h	/^  FContext::ContextStruct mainContext_;  \/**< stores loop function context *\/$/;"	m	class:facebook::memcache::FiberManager
makeAllAsyncRoute	.\routes\AllAsyncRoute.cpp	/^McrouterRouteHandlePtr makeAllAsyncRoute($/;"	f	namespace:facebook::memcache::mcrouter
makeAllFastestRoute	.\routes\AllFastestRoute.cpp	/^McrouterRouteHandlePtr makeAllFastestRoute($/;"	f	namespace:facebook::memcache::mcrouter
makeAllInitialRoute	.\routes\AllInitialRoute.cpp	/^McrouterRouteHandlePtr makeAllInitialRoute($/;"	f	namespace:facebook::memcache::mcrouter
makeAllMajorityRoute	.\routes\AllMajorityRoute.cpp	/^McrouterRouteHandlePtr makeAllMajorityRoute($/;"	f	namespace:facebook::memcache::mcrouter
makeAllSyncRoute	.\routes\AllSyncRoute.cpp	/^McrouterRouteHandlePtr makeAllSyncRoute($/;"	f	namespace:facebook::memcache::mcrouter
makeAsynclogRoute	.\routes\AsynclogRoute.cpp	/^McrouterRouteHandlePtr makeAsynclogRoute(McrouterRouteHandlePtr rh,$/;"	f	namespace:facebook::memcache::mcrouter
makeBigValueRoute	.\routes\BigValueRoute.cpp	/^McrouterRouteHandlePtr makeBigValueRoute(McrouterRouteHandlePtr rh,$/;"	f	namespace:facebook::memcache::mcrouter
makeContext	.\lib\fibers\BoostContextCompatibility.h	/^inline FContext makeContext(void* stackLimit, size_t stackSize,$/;"	f	namespace:facebook::memcache
makeDestinationHandle	.\routes\McRouteHandleProvider.cpp	/^McrouterRouteHandlePtr McRouteHandleProvider::makeDestinationHandle($/;"	f	class:facebook::memcache::mcrouter::McRouteHandleProvider
makeDestinationRoute	.\routes\DestinationRoute.cpp	/^McrouterRouteHandlePtr makeDestinationRoute($/;"	f	namespace:facebook::memcache::mcrouter
makeDevNullRoute	.\routes\DevNullRoute.cpp	/^McrouterRouteHandlePtr makeDevNullRoute(const char* name) {$/;"	f	namespace:facebook::memcache::mcrouter
makeErrorRoute	.\routes\ErrorRoute.cpp	/^McrouterRouteHandlePtr makeErrorRoute(const char* name) {$/;"	f	namespace:facebook::memcache::mcrouter
makeErrorRoute	.\routes\ErrorRoute.cpp	/^McrouterRouteHandlePtr makeErrorRoute(const char* name,$/;"	f	namespace:facebook::memcache::mcrouter
makeFailoverTargets	.\routes\ReliablePoolRoute.h	/^  makeFailoverTargets(std::string init_salt) const {$/;"	f	class:facebook::memcache::mcrouter::ReliablePoolRoute
makeFailoverWithExptimeRoute	.\routes\FailoverWithExptimeRoute.cpp	/^McrouterRouteHandlePtr makeFailoverWithExptimeRoute($/;"	f	namespace:facebook::memcache::mcrouter
makeHash	.\lib\config\RouteHandleProvider-inl.h	/^RouteHandleProvider<RouteHandleIf>::makeHash($/;"	f	class:facebook::memcache::RouteHandleProvider
makeHashRouteCh3	.\routes\HashRoute.cpp	/^McrouterRouteHandlePtr makeHashRouteCh3($/;"	f	namespace:facebook::memcache::mcrouter
makeHashRouteConstShard	.\routes\HashRoute.cpp	/^McrouterRouteHandlePtr makeHashRouteConstShard($/;"	f	namespace:facebook::memcache::mcrouter
makeHashRouteCrc32	.\routes\HashRoute.cpp	/^McrouterRouteHandlePtr makeHashRouteCrc32($/;"	f	namespace:facebook::memcache::mcrouter
makeHashRouteWeightedCh3	.\routes\HashRoute.cpp	/^McrouterRouteHandlePtr makeHashRouteWeightedCh3($/;"	f	namespace:facebook::memcache::mcrouter
makeLatestRoute	.\routes\LatestRoute.cpp	/^McrouterRouteHandlePtr makeLatestRoute($/;"	f	namespace:facebook::memcache::mcrouter
makeMcrouterRouteHandle	.\routes\McRouteHandleBuilder.h	/^McrouterRouteHandlePtr makeMcrouterRouteHandle(Args&&... args) {$/;"	f	namespace:facebook::memcache::mcrouter
makeMigrateRoute	.\routes\MigrateRoute.cpp	/^McrouterRouteHandlePtr makeMigrateRoute($/;"	f	namespace:facebook::memcache::mcrouter
makeMissFailoverRoute	.\routes\MissFailoverRoute.cpp	/^McrouterRouteHandlePtr makeMissFailoverRoute($/;"	f	namespace:facebook::memcache::mcrouter
makeMsgIOBufHelper	.\lib\IOBufUtil.cpp	/^std::unique_ptr<folly::IOBuf> makeMsgIOBufHelper(const McMsgRef& msgRef,$/;"	f	namespace:facebook::memcache
makeMsgIOBufStackHelper	.\lib\IOBufUtil.cpp	/^folly::IOBuf makeMsgIOBufStackHelper(const McMsgRef& msgRef) {$/;"	f	namespace:facebook::memcache
makeMsgKeyIOBuf	.\lib\IOBufUtil.cpp	/^std::unique_ptr<folly::IOBuf> makeMsgKeyIOBuf(const McMsgRef& msgRef,$/;"	f	namespace:facebook::memcache
makeMsgKeyIOBufStack	.\lib\IOBufUtil.cpp	/^folly::IOBuf makeMsgKeyIOBufStack(const McMsgRef& msgRef) {$/;"	f	namespace:facebook::memcache
makeMsgValueIOBuf	.\lib\IOBufUtil.cpp	/^std::unique_ptr<folly::IOBuf> makeMsgValueIOBuf(const McMsgRef& msgRef,$/;"	f	namespace:facebook::memcache
makeMsgValueIOBufStack	.\lib\IOBufUtil.cpp	/^folly::IOBuf makeMsgValueIOBufStack(const McMsgRef& msgRef) {$/;"	f	namespace:facebook::memcache
makeNullRoute	.\routes\NullRoute.cpp	/^McrouterRouteHandlePtr makeNullRoute(const char* name) {$/;"	f	namespace:facebook::memcache::mcrouter
makePolicyMap	.\routes\RouteHandleMap.cpp	/^std::shared_ptr<RoutePolicyMap> makePolicyMap(UniqueVectorMap& uniqueVectors,$/;"	f	namespace:facebook::memcache::mcrouter::__anon58
makePool	.\routes\McRouteHandleProvider.cpp	/^McRouteHandleProvider::makePool(const folly::dynamic& json) {$/;"	f	class:facebook::memcache::mcrouter::McRouteHandleProvider
makePoolRoute	.\routes\McRouteHandleProvider.cpp	/^McrouterRouteHandlePtr McRouteHandleProvider::makePoolRoute($/;"	f	class:facebook::memcache::mcrouter::McRouteHandleProvider
makePrefixPolicyRoute	.\routes\PrefixPolicyRoute.cpp	/^McrouterRouteHandlePtr makePrefixPolicyRoute($/;"	f	namespace:facebook::memcache::mcrouter
makeRateLimitRoute	.\routes\RateLimitRoute.cpp	/^McrouterRouteHandlePtr makeRateLimitRoute($/;"	f	namespace:facebook::memcache::mcrouter
makeReliablePoolRouteCh3	.\routes\ReliablePoolRoute.cpp	/^McrouterRouteHandlePtr makeReliablePoolRouteCh3($/;"	f	namespace:facebook::memcache::mcrouter
makeReply	.\lib\network\test\SessionTestHarness.h	/^  McReply makeReply(const McRequest& req, McOperation<mc_op_get>) {$/;"	f	class:facebook::memcache::SessionTestHarness
makeReply	.\lib\network\test\SessionTestHarness.h	/^  McReply makeReply(const McRequest& req, Operation) {$/;"	f	class:facebook::memcache::SessionTestHarness
makeRouteHandle	.\lib\config\RouteHandleBuilder.h	/^std::shared_ptr<RouteHandleIf> makeRouteHandle(Args&&... args) {$/;"	f	namespace:facebook::memcache
makeShadow	.\routes\McExtraRouteHandleProvider.cpp	/^McrouterRouteHandlePtr McExtraRouteHandleProvider::makeShadow($/;"	f	class:facebook::memcache::mcrouter::McExtraRouteHandleProvider
makeShadowRouteDefault	.\routes\ShadowRoute.cpp	/^McrouterRouteHandlePtr makeShadowRouteDefault($/;"	f	namespace:facebook::memcache::mcrouter
makeShardSplitRoute	.\routes\ShardSplitRoute.cpp	/^McrouterRouteHandlePtr makeShardSplitRoute($/;"	f	namespace:facebook::memcache::mcrouter
makeWarmUpRoute	.\routes\WarmUpRoute.cpp	/^McrouterRouteHandlePtr makeWarmUpRoute($/;"	f	namespace:facebook::memcache::mcrouter
makeWarmUpRouteAdd	.\routes\WarmUpRoute.cpp	/^McrouterRouteHandlePtr makeWarmUpRouteAdd($/;"	f	namespace:facebook::memcache::mcrouter
make_delete_request	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^make_delete_request(const std::string& key) {$/;"	f	file:
make_get_request	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^make_get_request(const std::string& key) {$/;"	f	file:
make_random_key	.\lib\fbi\test\hash_test.cpp	/^char* make_random_key(char* buffer, size_t maxLength) {$/;"	f	namespace:__anon22
make_set_request	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^make_set_request(const std::string& key,$/;"	f	file:
manage_children	.\main.cpp	/^static void manage_children() {$/;"	f	file:
map	.\lib\fbi\nstring.h	/^  const nstring_map_t *map;$/;"	m	struct:nstring_map_sorted_iter_s
map	.\lib\fbi\nstring.h	/^  const nstring_map_t* map;$/;"	m	struct:nstring_map_iter_s
mapped_type	.\lib\fbi\cpp\Trie.h	/^  typedef Value mapped_type;$/;"	t	class:facebook::memcache::Trie
markAsActive	.\ProxyDestinationMap.cpp	/^void ProxyDestinationMap::markAsActive(ProxyDestination& destination) {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestinationMap
mark_tko	.\ProxyDestination.cpp	/^void ProxyDestination::mark_tko() {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
match_pattern_helper	.\route.cpp	/^static bool match_pattern_helper(const char* pi,$/;"	f	namespace:facebook::memcache::mcrouter
match_pattern_route	.\route.cpp	/^bool match_pattern_route(StringPiece pattern,$/;"	f	namespace:facebook::memcache::mcrouter
match_routing_key_hash	.\route.cpp	/^bool match_routing_key_hash(uint32_t routingKeyHash,$/;"	f	namespace:facebook::memcache::mcrouter
matchingUnescapedBracket	.\lib\config\ConfigPreprocessor.cpp	/^size_t matchingUnescapedBracket(StringPiece s, size_t i) {$/;"	f	namespace:facebook::memcache::__anon4
max	.\lib\fbi\waitable_count.h	/^  unsigned max;$/;"	m	struct:waitable_counter
maxCapacity_	.\lib\fbi\cpp\ObjectPool.h	/^  const size_t maxCapacity_;            \/\/ Maximum number of objects that can be$/;"	m	class:facebook::memcache::ObjectPool
maxOutstanding	.\lib\fibers\test\FibersTestApp.cpp	/^  size_t maxOutstanding;$/;"	m	struct:Application	file:
maxQueueSize_	.\awriter.h	/^  const size_t maxQueueSize_;$/;"	m	class:facebook::memcache::mcrouter::AsyncWriter
maxSoftTkos_	.\TkoTracker.h	/^  const size_t maxSoftTkos_;$/;"	m	class:facebook::memcache::mcrouter::TkoTracker
max_outstanding	.\mcrouter_client.h	/^  unsigned int max_outstanding;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_t
may_send	.\ProxyDestination.cpp	/^int ProxyDestination::may_send(const McMsgRef& req) {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
mcParser_	.\lib\network\McParser.h	/^  mc_parser_t mcParser_;$/;"	m	class:facebook::memcache::McParser
mc_	.\lib\network\test\MockMcServer.cpp	/^  MockMc mc_;$/;"	m	class:MockMcOnRequest	file:
mc_accesspoint	.\AccessPoint.h	/^  const mc_accesspoint_t& mc_accesspoint() const {$/;"	f	struct:facebook::memcache::mcrouter::AccessPoint
mc_accesspoint_copy	.\lib\mc\protocol.h	/^static inline void mc_accesspoint_copy(mc_accesspoint_t* dest,$/;"	f
mc_accesspoint_eq	.\lib\mc\protocol.h	/^static inline int mc_accesspoint_eq(const mc_accesspoint_t* a,$/;"	f
mc_accesspoint_hash	.\lib\mc\protocol.c	/^nstring_t* mc_accesspoint_hash(const mc_accesspoint_t* accesspoint) {$/;"	f
mc_accesspoint_isascii	.\lib\mc\protocol.h	/^static inline int mc_accesspoint_isascii(const mc_accesspoint_t* accesspoint) {$/;"	f
mc_accesspoint_isbinary	.\lib\mc\protocol.h	/^static inline int mc_accesspoint_isbinary(const mc_accesspoint_t* accesspoint) {$/;"	f
mc_accesspoint_isstream	.\lib\mc\protocol.h	/^static inline int mc_accesspoint_isstream(const mc_accesspoint_t* accesspoint) {$/;"	f
mc_accesspoint_len	.\lib\mc\protocol.h	/^static inline size_t mc_accesspoint_len(const mc_accesspoint_t* accesspoint) {$/;"	f
mc_accesspoint_s	.\lib\mc\protocol.h	/^typedef struct mc_accesspoint_s {$/;"	s
mc_accesspoint_t	.\lib\mc\protocol.h	/^} mc_accesspoint_t;$/;"	t	typeref:struct:mc_accesspoint_s
mc_ascii_cas_req_to_hdr	.\lib\mc\protocol.c	/^static ssize_t mc_ascii_cas_req_to_hdr(const mc_msg_t* req,$/;"	f	file:
mc_ascii_delete_req_to_hdr	.\lib\mc\protocol.c	/^static ssize_t mc_ascii_delete_req_to_hdr(const mc_msg_t* req,$/;"	f	file:
mc_ascii_protocol	.\lib\mc\protocol.h	/^  mc_ascii_protocol = 1,$/;"	e	enum:mc_protocol_e
mc_ascii_req_max_hdr_len	.\lib\mc\_protocol.h	/^static inline size_t mc_ascii_req_max_hdr_len(const mc_msg_t* req) {$/;"	f
mc_ascii_req_max_hdr_length	.\lib\mc\protocol.c	/^size_t mc_ascii_req_max_hdr_length(const mc_msg_t* req) {$/;"	f
mc_ascii_req_to_string	.\async.cpp	/^ssize_t mc_ascii_req_to_string(const mc_msg_t* req, char* buf, size_t nbuf) {$/;"	f	namespace:facebook::memcache::mcrouter
mc_ascii_response_buf_cleanup	.\lib\mc\ascii_response.c	/^void mc_ascii_response_buf_cleanup(mc_ascii_response_buf_t* buf) {$/;"	f
mc_ascii_response_buf_init	.\lib\mc\ascii_response.c	/^void mc_ascii_response_buf_init(mc_ascii_response_buf_t* buf) {$/;"	f
mc_ascii_response_buf_s	.\lib\mc\ascii_response.h	/^typedef struct mc_ascii_response_buf_s {$/;"	s
mc_ascii_response_buf_t	.\lib\mc\ascii_response.h	/^} mc_ascii_response_buf_t;$/;"	t	typeref:struct:mc_ascii_response_buf_s
mc_ascii_response_write_iovs	.\lib\mc\ascii_response.c	/^size_t mc_ascii_response_write_iovs(mc_ascii_response_buf_t* buf,$/;"	f
mc_binary_protocol	.\lib\mc\protocol.h	/^  mc_binary_protocol = 2,$/;"	e	enum:mc_protocol_e
mc_client_req_is_valid	.\lib\mc\msg.c	/^int mc_client_req_is_valid(const mc_msg_t* req) {$/;"	f
mc_fbtrace_decref	.\lib\mc\mc_fbtrace_info.c	/^static void mc_fbtrace_decref(mc_fbtrace_t* fbt) {$/;"	f	file:
mc_fbtrace_incref	.\lib\mc\mc_fbtrace_info.c	/^static mc_fbtrace_t* mc_fbtrace_incref(mc_fbtrace_t* fbt) {$/;"	f	file:
mc_fbtrace_info_decref	.\lib\mc\mc_fbtrace_info.c	/^void mc_fbtrace_info_decref(mc_fbtrace_info_t* fbt_i) {$/;"	f
mc_fbtrace_info_deep_copy	.\lib\mc\mc_fbtrace_info.c	/^mc_fbtrace_info_t* mc_fbtrace_info_deep_copy(const mc_fbtrace_info_t* orig) {$/;"	f
mc_fbtrace_info_incref	.\lib\mc\mc_fbtrace_info.c	/^mc_fbtrace_info_t* mc_fbtrace_info_incref(mc_fbtrace_info_t* fbt_i) {$/;"	f
mc_fbtrace_info_s	.\lib\mc\mc_fbtrace_info.h	/^typedef struct mc_fbtrace_info_s {$/;"	s
mc_fbtrace_info_t	.\lib\mc\mc_fbtrace_info.h	/^} mc_fbtrace_info_t;$/;"	t	typeref:struct:mc_fbtrace_info_s
mc_fbtrace_s	.\lib\mc\mc_fbtrace_info.h	/^typedef struct mc_fbtrace_s {$/;"	s
mc_fbtrace_t	.\lib\mc\mc_fbtrace_info.h	/^} mc_fbtrace_t;$/;"	t	typeref:struct:mc_fbtrace_s
mc_msg_compress	.\lib\mc\msg.c	/^void mc_msg_compress(mc_msg_t **msgP) {$/;"	f
mc_msg_contains	.\lib\mc\msg.c	/^int mc_msg_contains(const mc_msg_t *msg, void *p, size_t n) {$/;"	f
mc_msg_copy	.\lib\mc\msg.c	/^void mc_msg_copy(mc_msg_t *dst, const mc_msg_t *src) {$/;"	f
mc_msg_decompress	.\lib\mc\msg.c	/^int mc_msg_decompress(mc_msg_t **msgP) {$/;"	f
mc_msg_decref	.\lib\mc\msg.c	/^void mc_msg_decref(mc_msg_t* msg) {$/;"	f
mc_msg_dup	.\lib\mc\msg.c	/^mc_msg_t* mc_msg_dup(const mc_msg_t *msg) {$/;"	f
mc_msg_dup_append_key_full	.\lib\mc\msg.c	/^mc_msg_t* mc_msg_dup_append_key_full(const mc_msg_t *msg,$/;"	f
mc_msg_flags_t	.\lib\mc\msg.h	/^enum mc_msg_flags_t {$/;"	g
mc_msg_grow	.\lib\mc\msg.c	/^int mc_msg_grow(mc_msg_t **msg_ptr, size_t len, void **field_ptr) {$/;"	f
mc_msg_incref	.\lib\mc\msg.c	/^mc_msg_t* mc_msg_incref(mc_msg_t* msg) {$/;"	f
mc_msg_init_not_refcounted	.\lib\mc\msg.c	/^void mc_msg_init_not_refcounted(mc_msg_t* msg) {$/;"	f
mc_msg_new	.\lib\mc\msg.c	/^mc_msg_t* mc_msg_new(size_t extra_size) {$/;"	f
mc_msg_new_with_key	.\lib\mc\msg.c	/^mc_msg_t *mc_msg_new_with_key(const char *key) {$/;"	f
mc_msg_new_with_key_and_value	.\lib\mc\msg.c	/^mc_msg_t *mc_msg_new_with_key_and_value(const char *key,$/;"	f
mc_msg_new_with_key_and_value_full	.\lib\mc\msg.c	/^mc_msg_t *mc_msg_new_with_key_and_value_full(const char *key,$/;"	f
mc_msg_new_with_key_full	.\lib\mc\msg.c	/^mc_msg_t *mc_msg_new_with_key_full(const char *key, size_t nkey) {$/;"	f
mc_msg_num_outstanding	.\lib\mc\msg.c	/^uint64_t mc_msg_num_outstanding() {$/;"	f
mc_msg_nzlib_compress	.\lib\mc\msg.c	/^void mc_msg_nzlib_compress(mc_msg_t **msgP) {$/;"	f
mc_msg_nzlib_decompress	.\lib\mc\msg.c	/^int mc_msg_nzlib_decompress(mc_msg_t **msgP) {$/;"	f
mc_msg_realloc	.\lib\mc\msg.c	/^mc_msg_t* mc_msg_realloc(mc_msg_t *msg, size_t new_extra_size) {$/;"	f
mc_msg_s	.\lib\mc\msg.h	/^typedef struct mc_msg_s {$/;"	s
mc_msg_shallow_copy	.\lib\mc\msg.c	/^void mc_msg_shallow_copy(mc_msg_t *dst, const mc_msg_t *src) {$/;"	f
mc_msg_t	.\lib\mc\msg.h	/^} mc_msg_t;$/;"	t	typeref:struct:mc_msg_s
mc_msg_track_num_outstanding	.\lib\mc\msg.c	/^void mc_msg_track_num_outstanding(int enable) {$/;"	f
mc_msg_use_atomic_refcounts	.\lib\mc\msg.c	/^void mc_msg_use_atomic_refcounts(int enable){$/;"	f
mc_nops	.\lib\mc\msg.h	/^  mc_nops \/\/ placeholder$/;"	e	enum:mc_op_e
mc_nprotocols	.\lib\mc\protocol.h	/^  mc_nprotocols, \/\/ placeholder$/;"	e	enum:mc_protocol_e
mc_nres	.\lib\mc\msg.h	/^  mc_nres \/\/ placeholder$/;"	e	enum:mc_res_e
mc_op	.\lib\McOperation.h	/^  static const mc_op_t mc_op = (mc_op_t)op;$/;"	m	struct:facebook::memcache::McOperation
mc_op_add	.\lib\mc\msg.h	/^  mc_op_add,$/;"	e	enum:mc_op_e
mc_op_append	.\lib\mc\msg.h	/^  mc_op_append,$/;"	e	enum:mc_op_e
mc_op_bump_count	.\lib\mc\msg.h	/^  mc_op_bump_count,$/;"	e	enum:mc_op_e
mc_op_bump_unique_count	.\lib\mc\msg.h	/^  mc_op_bump_unique_count,$/;"	e	enum:mc_op_e
mc_op_cas	.\lib\mc\msg.h	/^  mc_op_cas,$/;"	e	enum:mc_op_e
mc_op_decr	.\lib\mc\msg.h	/^  mc_op_decr,$/;"	e	enum:mc_op_e
mc_op_delete	.\lib\mc\msg.h	/^  mc_op_delete,$/;"	e	enum:mc_op_e
mc_op_e	.\lib\mc\msg.h	/^typedef enum mc_op_e {$/;"	g
mc_op_echo	.\lib\mc\msg.h	/^  mc_op_echo,$/;"	e	enum:mc_op_e
mc_op_end	.\lib\mc\msg.h	/^  mc_op_end,$/;"	e	enum:mc_op_e
mc_op_exec	.\lib\mc\msg.h	/^  mc_op_exec,$/;"	e	enum:mc_op_e
mc_op_flushall	.\lib\mc\msg.h	/^  mc_op_flushall,$/;"	e	enum:mc_op_e
mc_op_flushre	.\lib\mc\msg.h	/^  mc_op_flushre,$/;"	e	enum:mc_op_e
mc_op_from_string	.\lib\mc\msg.c	/^mc_op_t mc_op_from_string(const char* str) {$/;"	f
mc_op_get	.\lib\mc\msg.h	/^  mc_op_get,$/;"	e	enum:mc_op_e
mc_op_get_count	.\lib\mc\msg.h	/^  mc_op_get_count,$/;"	e	enum:mc_op_e
mc_op_get_service_info	.\lib\mc\msg.h	/^  mc_op_get_service_info, \/\/\/< Queries various service state$/;"	e	enum:mc_op_e
mc_op_get_unique_count	.\lib\mc\msg.h	/^  mc_op_get_unique_count,$/;"	e	enum:mc_op_e
mc_op_gets	.\lib\mc\msg.h	/^  mc_op_gets,$/;"	e	enum:mc_op_e
mc_op_incr	.\lib\mc\msg.h	/^  mc_op_incr,$/;"	e	enum:mc_op_e
mc_op_lease_get	.\lib\mc\msg.h	/^  mc_op_lease_get,$/;"	e	enum:mc_op_e
mc_op_lease_set	.\lib\mc\msg.h	/^  mc_op_lease_set,$/;"	e	enum:mc_op_e
mc_op_metaget	.\lib\mc\msg.h	/^  mc_op_metaget,$/;"	e	enum:mc_op_e
mc_op_prepend	.\lib\mc\msg.h	/^  mc_op_prepend,$/;"	e	enum:mc_op_e
mc_op_quit	.\lib\mc\msg.h	/^  mc_op_quit,$/;"	e	enum:mc_op_e
mc_op_replace	.\lib\mc\msg.h	/^  mc_op_replace,$/;"	e	enum:mc_op_e
mc_op_servererr	.\lib\mc\msg.h	/^  mc_op_servererr, \/\/\/< not a real op$/;"	e	enum:mc_op_e
mc_op_set	.\lib\mc\msg.h	/^  mc_op_set,$/;"	e	enum:mc_op_e
mc_op_shutdown	.\lib\mc\msg.h	/^  mc_op_shutdown,$/;"	e	enum:mc_op_e
mc_op_stats	.\lib\mc\msg.h	/^  mc_op_stats,$/;"	e	enum:mc_op_e
mc_op_t	.\lib\mc\msg.h	/^} mc_op_t;$/;"	t	typeref:enum:mc_op_e
mc_op_to_string	.\lib\mc\msg.h	/^static inline const char* mc_op_to_string(const mc_op_t op) {$/;"	f
mc_op_unknown	.\lib\mc\msg.h	/^  mc_op_unknown = 0,$/;"	e	enum:mc_op_e
mc_op_verbosity	.\lib\mc\msg.h	/^  mc_op_verbosity,$/;"	e	enum:mc_op_e
mc_op_version	.\lib\mc\msg.h	/^  mc_op_version,$/;"	e	enum:mc_op_e
mc_parser_cleanup_tbuf	.\lib\mc\parser.c	/^void mc_parser_cleanup_tbuf(mc_parser_t *parser) {$/;"	f
mc_parser_determine_protocol	.\lib\mc\parser.c	/^mc_protocol_t mc_parser_determine_protocol(mc_parser_t *parser,$/;"	f
mc_parser_ensure_tbuf	.\lib\mc\parser.c	/^int mc_parser_ensure_tbuf(mc_parser_t *parser, int n) {$/;"	f
mc_parser_init	.\lib\mc\parser.c	/^void mc_parser_init(mc_parser_t *parser,$/;"	f
mc_parser_num_partial_messages	.\lib\mc\parser.c	/^unsigned long mc_parser_num_partial_messages() {$/;"	f
mc_parser_parse	.\lib\mc\parser.c	/^void mc_parser_parse(mc_parser_t *parser, const uint8_t *buf, size_t len) {$/;"	f
mc_parser_reset	.\lib\mc\parser.c	/^void mc_parser_reset(mc_parser_t *parser) {$/;"	f
mc_parser_reset_num_partial_messages	.\lib\mc\parser.c	/^void mc_parser_reset_num_partial_messages() {$/;"	f
mc_parser_t	.\lib\mc\parser.h	/^} mc_parser_t;$/;"	t	typeref:struct:parser_s
mc_protocol_e	.\lib\mc\protocol.h	/^typedef enum mc_protocol_e {$/;"	g
mc_protocol_t	.\lib\mc\protocol.h	/^} mc_protocol_t;$/;"	t	typeref:enum:mc_protocol_e
mc_protocol_to_string	.\lib\mc\protocol.h	/^static inline const char* mc_protocol_to_string(const mc_protocol_t value) {$/;"	f
mc_req_has_key	.\lib\mc\msg.h	/^static inline int mc_req_has_key(const mc_msg_t* req) {$/;"	f
mc_req_has_value	.\lib\mc\msg.h	/^static inline int mc_req_has_value(const mc_msg_t* req) {$/;"	f
mc_res_aborted	.\lib\mc\msg.h	/^  mc_res_aborted,$/;"	e	enum:mc_res_e
mc_res_bad_cas_id	.\lib\mc\msg.h	/^  mc_res_bad_cas_id,$/;"	e	enum:mc_res_e
mc_res_bad_command	.\lib\mc\msg.h	/^  mc_res_bad_command,$/;"	e	enum:mc_res_e
mc_res_bad_exptime	.\lib\mc\msg.h	/^  mc_res_bad_exptime,$/;"	e	enum:mc_res_e
mc_res_bad_flags	.\lib\mc\msg.h	/^  mc_res_bad_flags,$/;"	e	enum:mc_res_e
mc_res_bad_key	.\lib\mc\msg.h	/^  mc_res_bad_key,$/;"	e	enum:mc_res_e
mc_res_bad_lease_id	.\lib\mc\msg.h	/^  mc_res_bad_lease_id,$/;"	e	enum:mc_res_e
mc_res_bad_value	.\lib\mc\msg.h	/^  mc_res_bad_value,$/;"	e	enum:mc_res_e
mc_res_busy	.\lib\mc\msg.h	/^  mc_res_busy, \/* the request was refused for load shedding *\/$/;"	e	enum:mc_res_e
mc_res_client_error	.\lib\mc\msg.h	/^  mc_res_client_error,$/;"	e	enum:mc_res_e
mc_res_connect_error	.\lib\mc\msg.h	/^  mc_res_connect_error,$/;"	e	enum:mc_res_e
mc_res_connect_timeout	.\lib\mc\msg.h	/^  mc_res_connect_timeout,$/;"	e	enum:mc_res_e
mc_res_deleted	.\lib\mc\msg.h	/^  mc_res_deleted,$/;"	e	enum:mc_res_e
mc_res_e	.\lib\mc\msg.h	/^typedef enum mc_res_e {$/;"	g
mc_res_exists	.\lib\mc\msg.h	/^  mc_res_exists,$/;"	e	enum:mc_res_e
mc_res_found	.\lib\mc\msg.h	/^  mc_res_found,$/;"	e	enum:mc_res_e
mc_res_foundstale	.\lib\mc\msg.h	/^  mc_res_foundstale, \/* hot-miss w\/ stale data *\/$/;"	e	enum:mc_res_e
mc_res_is_err	.\lib\mc\msg.h	/^static inline int mc_res_is_err(const mc_res_t result) {$/;"	f
mc_res_local_error	.\lib\mc\msg.h	/^  mc_res_local_error, \/* an error internal to libmc *\/$/;"	e	enum:mc_res_e
mc_res_notfound	.\lib\mc\msg.h	/^  mc_res_notfound,$/;"	e	enum:mc_res_e
mc_res_notfoundhot	.\lib\mc\msg.h	/^  mc_res_notfoundhot, \/* hot-miss w\/o stale data *\/$/;"	e	enum:mc_res_e
mc_res_notstored	.\lib\mc\msg.h	/^  mc_res_notstored,$/;"	e	enum:mc_res_e
mc_res_ok	.\lib\mc\msg.h	/^  mc_res_ok,$/;"	e	enum:mc_res_e
mc_res_ooo	.\lib\mc\msg.h	/^  mc_res_ooo, \/* out of order (UDP) *\/$/;"	e	enum:mc_res_e
mc_res_remote_error	.\lib\mc\msg.h	/^  mc_res_remote_error,$/;"	e	enum:mc_res_e
mc_res_stalestored	.\lib\mc\msg.h	/^  mc_res_stalestored,$/;"	e	enum:mc_res_e
mc_res_stored	.\lib\mc\msg.h	/^  mc_res_stored,$/;"	e	enum:mc_res_e
mc_res_t	.\lib\mc\msg.h	/^} mc_res_t;$/;"	t	typeref:enum:mc_res_e
mc_res_timeout	.\lib\mc\msg.h	/^  mc_res_timeout, \/* request timeout (connection was already established) *\/$/;"	e	enum:mc_res_e
mc_res_tko	.\lib\mc\msg.h	/^  mc_res_tko, \/* total knock out - the peer is down for the count *\/$/;"	e	enum:mc_res_e
mc_res_to_response_string	.\lib\mc\ascii_response.c	/^static inline const char* mc_res_to_response_string(const mc_res_t result) {$/;"	f	file:
mc_res_to_string	.\lib\mc\msg.h	/^static inline const char* mc_res_to_string(const mc_res_t result) {$/;"	f
mc_res_try_again	.\lib\mc\msg.h	/^  mc_res_try_again, \/* this request was refused, but we should keep sending$/;"	e	enum:mc_res_e
mc_res_unknown	.\lib\mc\msg.h	/^  mc_res_unknown = 0,$/;"	e	enum:mc_res_e
mc_res_waiting	.\lib\mc\msg.h	/^  mc_res_waiting,$/;"	e	enum:mc_res_e
mc_serialize_req_ascii	.\lib\mc\protocol.c	/^int mc_serialize_req_ascii(const mc_msg_t* req, char* headerBuffer,$/;"	f
mc_stream	.\lib\mc\protocol.h	/^  mc_stream = IPPROTO_TCP,$/;"	e	enum:mc_transport_e
mc_string_new	.\lib\mc\parser.c	/^void mc_string_new(nstring_t *nstr, const char *buf, size_t len) {$/;"	f
mc_string_to_protocol	.\lib\mc\protocol.h	/^static inline mc_protocol_t mc_string_to_protocol(const char * str) {$/;"	f
mc_transport_e	.\lib\mc\protocol.h	/^typedef enum mc_transport_e {$/;"	g
mc_transport_t	.\lib\mc\protocol.h	/^} mc_transport_t;$/;"	t	typeref:enum:mc_transport_e
mc_transport_to_string	.\lib\mc\protocol.h	/^static inline const char* mc_transport_to_string(const mc_transport_t value) {$/;"	f
mc_umbrella_protocol	.\lib\mc\protocol.h	/^  mc_umbrella_protocol = 3,$/;"	e	enum:mc_protocol_e
mc_unknown_protocol	.\lib\mc\protocol.h	/^  mc_unknown_protocol = 0,$/;"	e	enum:mc_protocol_e
mc_unknown_transport	.\lib\mc\protocol.h	/^  mc_unknown_transport = 0,$/;"	e	enum:mc_transport_e
mcproxy_stats	.\stats.h	/^  mcproxy_stats        =        0x1,$/;"	e	enum:facebook::memcache::mcrouter::stat_group_t
mcrouter	.\AccessPoint.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\AccessPoint.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\AtomicTokenBucket.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\CallbackPool-inl.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\CallbackPool.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\ConfigApi.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\ConfigApi.h	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\DestinationClient.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\DestinationClient.h	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\ExponentialSmoothData.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\ExponentialSmoothData.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\FileDataProvider.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\FileDataProvider.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\FileObserver.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\FileObserver.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\LoggingProxyRequestContext.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\McrouterLogFailure.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\McrouterLogger.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\McrouterLogger.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\Observable-inl.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\Observable.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\PeriodicTaskScheduler.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\PeriodicTaskScheduler.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\PoolFactory.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\PoolFactory.h	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\PoolFactoryIf.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\ProxyClientCommon.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\ProxyClientCommon.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\ProxyConfig.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\ProxyConfig.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\ProxyConfigBuilder.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\ProxyConfigBuilder.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\ProxyConfigIf.h	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\ProxyDestination.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\ProxyDestination.h	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\ProxyDestinationMap.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\ProxyDestinationMap.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\ProxyMcReply.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\ProxyMcReply.h	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\ProxyMcRequest.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\ProxyMcRequest.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\ProxyRequestContext.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\ProxyRequestContext.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\ProxyRequestLogger-inl.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\ProxyRequestLogger.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\ProxyThread.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\ProxyThread.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\RecordingContext.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\RecordingContext.h	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\RoutingPrefix.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\RoutingPrefix.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\RuntimeVarsData.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\RuntimeVarsData.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\ServiceInfo.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\ServiceInfo.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\TkoCounters.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\TkoLog.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\TkoLog.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\TkoTracker.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\TkoTracker.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\TokenBucket.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\_router.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\async.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\async.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\awriter.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\flavor.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\flavor.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\lib\fibers\EventBaseLoopController-inl.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\lib\fibers\EventBaseLoopController.h	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\mcrouter_client.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\mcrouter_config.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\mcrouter_config.h	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\pclient-inl.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\pclient.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\pclient.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\priorities.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\priorities.h	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\proxy.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\proxy.h	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\route.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\route.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\router.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\router.h	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\AllAsyncRoute.cpp	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\AllFastestRoute.cpp	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\AllInitialRoute.cpp	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\AllMajorityRoute.cpp	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\AllSyncRoute.cpp	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\AsynclogRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\AsynclogRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\BigValueRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\DefaultShadowPolicy.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\DestinationRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\DestinationRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\DevNullRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\DevNullRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\ErrorRoute.cpp	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\ExtraRouteHandleProviderIf.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\FailoverWithExptimeRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\FailoverWithExptimeRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\FailoverWithExptimeRouteIf.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\FailoverWithExptimeRouteIf.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\HashRoute.cpp	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\LatestRoute.cpp	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\McExtraRouteHandleProvider.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\McExtraRouteHandleProvider.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\McImportResolver.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\McImportResolver.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\McRouteHandleBuilder.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\McRouteHandleProvider.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\McRouteHandleProvider.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\McrouterRouteHandle.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\MigrateRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\MissFailoverRoute.cpp	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\NullRoute.cpp	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\PrefixPolicyRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\PrefixPolicyRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\PrefixRouteSelector.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\PrefixRouteSelector.h	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\ProxyRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\RateLimitRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\RateLimitRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\RateLimiter.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\RateLimiter.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\ReliablePoolRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\ReliablePoolRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\RootRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\RouteHandleMap.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\RouteHandleMap.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\RoutePolicyMap.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\RoutePolicyMap.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\RouteSelectorMap.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\ShadowRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\ShadowRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\ShadowRouteIf.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\ShardHashFunc.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\ShardHashFunc.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\ShardSplitRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\ShardSplitRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\ShardSplitter.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\routes\ShardSplitter.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\TimeProviderFunc.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\routes\WarmUpRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\server.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\server.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\standalone_options.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\standalone_options.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouter	.\stats.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook::memcache	file:
mcrouter	.\stats.h	/^namespace mcrouter {$/;"	n	namespace:facebook::memcache
mcrouterGet	.\router.cpp	/^  mcrouter_t* mcrouterGet(const std::string& persistence_id) {$/;"	f	class:facebook::memcache::mcrouter::__anon56::McrouterManager
mcrouterGetCreate	.\router.cpp	/^  mcrouter_t* mcrouterGetCreate(const std::string& persistence_id,$/;"	f	class:facebook::memcache::mcrouter::__anon56::McrouterManager
mcrouterLogger	.\_router.h	/^  std::unique_ptr<McrouterLogger> mcrouterLogger;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
mcrouterLoopOnce	.\mcrouter_config.h	/^inline bool mcrouterLoopOnce(folly::EventBase* eventBase) {$/;"	f	namespace:facebook::memcache::mcrouter
mcrouterManager	.\router.cpp	/^folly::Singleton<McrouterManager> mcrouterManager;$/;"	m	namespace:facebook::memcache::mcrouter::__anon56	file:
mcrouter_client_assign_proxy	.\router.cpp	/^void mcrouter_client_assign_proxy(mcrouter_client_t *client) {$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_client_callbacks_t	.\router.h	/^struct mcrouter_client_callbacks_t {$/;"	s	namespace:facebook::memcache::mcrouter
mcrouter_client_cleanup	.\router.cpp	/^static void mcrouter_client_cleanup(mcrouter_client_t *client) {$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_client_decref	.\router.cpp	/^void mcrouter_client_decref(mcrouter_client_t* client) {$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_client_disconnect	.\router.cpp	/^void mcrouter_client_disconnect(mcrouter_client_t *client) {$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_client_get_base	.\router.cpp	/^folly::EventBase* mcrouter_client_get_base(mcrouter_client_t *client) {$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_client_incref	.\router.cpp	/^mcrouter_client_t *mcrouter_client_incref(mcrouter_client_t* client) {$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_client_list_t	.\mcrouter_client.h	/^typedef TAILQ_HEAD(, mcrouter_client_t) mcrouter_client_list_t;$/;"	t	namespace:facebook::memcache::mcrouter
mcrouter_client_new	.\router.cpp	/^mcrouter_client_t *mcrouter_client_new(mcrouter_t *router,$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_client_set_context	.\router.cpp	/^void mcrouter_client_set_context(mcrouter_client_t* client, void* context) {$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_client_stats	.\router.cpp	/^std::unordered_map<std::string, int64_t> mcrouter_client_stats($/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_client_stats_t	.\mcrouter_client.h	/^struct mcrouter_client_stats_t {$/;"	s	namespace:facebook::memcache::mcrouter
mcrouter_client_t	.\mcrouter_client.h	/^struct mcrouter_client_t {$/;"	s	namespace:facebook::memcache::mcrouter
mcrouter_client_t	.\router.cpp	/^mcrouter_client_t::mcrouter_client_t($/;"	f	class:facebook::memcache::mcrouter::mcrouter_client_t
mcrouter_enqueue_reply	.\router.cpp	/^void mcrouter_enqueue_reply(proxy_request_t *preq) {$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_exception	.\router.h	/^  explicit mcrouter_exception(const std::string& e)$/;"	f	struct:facebook::memcache::mcrouter::mcrouter_exception
mcrouter_exception	.\router.h	/^struct mcrouter_exception : std::runtime_error {$/;"	s	namespace:facebook::memcache::mcrouter
mcrouter_free	.\router.cpp	/^void mcrouter_free(mcrouter_t *router) {$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_get	.\router.cpp	/^mcrouter_t* mcrouter_get(const std::string& persistence_id) {$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_get_opts	.\router.cpp	/^const McrouterOptions& mcrouter_get_opts(mcrouter_t *router) {$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_init	.\router.cpp	/^mcrouter_t* mcrouter_init(const std::string& persistence_id,$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_msg_t	.\router.h	/^struct mcrouter_msg_t {$/;"	s	namespace:facebook::memcache::mcrouter
mcrouter_new	.\router.cpp	/^mcrouter_t *mcrouter_new(const McrouterOptions& input_options) {$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_new_transient	.\router.cpp	/^mcrouter_t* mcrouter_new_transient(const McrouterOptions& options) {$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_on_cancel_t	.\router.h	/^typedef void (mcrouter_on_cancel_t)(mcrouter_client_t *client,$/;"	t	namespace:facebook::memcache::mcrouter
mcrouter_on_client_destroyed	.\router.cpp	/^static void mcrouter_on_client_destroyed(mcrouter_t* router) {$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_on_disconnect_ts_t	.\router.h	/^typedef void (mcrouter_on_disconnect_ts_t)(void *client_context);$/;"	t	namespace:facebook::memcache::mcrouter
mcrouter_on_reply_t	.\router.h	/^typedef void (mcrouter_on_reply_t)(mcrouter_client_t *client,$/;"	t	namespace:facebook::memcache::mcrouter
mcrouter_on_request_sweep_t	.\router.h	/^typedef void (mcrouter_on_request_sweep_t)(mcrouter_msg_t *router_req);$/;"	t	namespace:facebook::memcache::mcrouter
mcrouter_option	.\options-template.h	11;"	d
mcrouter_option	.\options-template.h	29;"	d
mcrouter_option	.\options-template.h	30;"	d
mcrouter_option	.\options-template.h	41;"	d
mcrouter_option	.\options-template.h	42;"	d
mcrouter_option	.\options-template.h	69;"	d
mcrouter_option	.\standalone_options_list.h	94;"	d
mcrouter_option_double	.\options-template.h	16;"	d
mcrouter_option_double	.\options-template.h	66;"	d
mcrouter_option_group	.\mcrouter_options_list.h	11;"	d
mcrouter_option_group	.\mcrouter_options_list.h	425;"	d
mcrouter_option_group	.\options-template.h	55;"	d
mcrouter_option_group	.\options-template.h	56;"	d
mcrouter_option_group	.\standalone_options_list.h	11;"	d
mcrouter_option_group	.\standalone_options_list.h	93;"	d
mcrouter_option_integer	.\options-template.h	14;"	d
mcrouter_option_integer	.\options-template.h	65;"	d
mcrouter_option_other	.\options-template.h	20;"	d
mcrouter_option_other	.\options-template.h	68;"	d
mcrouter_option_string	.\options-template.h	12;"	d
mcrouter_option_string	.\options-template.h	64;"	d
mcrouter_option_toggle	.\options-template.h	18;"	d
mcrouter_option_toggle	.\options-template.h	67;"	d
mcrouter_queue_entry_t	.\router.cpp	/^struct mcrouter_queue_entry_t {$/;"	s	namespace:facebook::memcache::mcrouter::__anon56	file:
mcrouter_request_ready_cb	.\router.cpp	/^void mcrouter_request_ready_cb(asox_queue_t q,$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_send	.\router.cpp	/^int mcrouter_send(mcrouter_client_t *client,$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_send_helper	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	/^void mcrouter_send_helper(mcrouter_client_t *client,$/;"	f
mcrouter_set_thread_name	.\router.cpp	/^void mcrouter_set_thread_name(pthread_t tid,$/;"	f	namespace:facebook::memcache::mcrouter
mcrouter_t	.\_router.h	/^struct mcrouter_t {$/;"	s	namespace:facebook::memcache::mcrouter
mcrouter_t	.\router.cpp	/^mcrouter_t::mcrouter_t(const McrouterOptions& input_options) :$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
mcrouter_time	.\test\test_mcrouter_sanity.py	/^    mcrouter_time = 0$/;"	v	class:TestMcrouterSanity
mcrouters_	.\router.cpp	/^  std::unordered_map<std::string, mcrouter_t*> mcrouters_;$/;"	m	class:facebook::memcache::mcrouter::__anon56::McrouterManager	file:
md5	.\ConfigApi.h	/^    std::string md5;$/;"	m	struct:facebook::memcache::mcrouter::ConfigType::ConfigApi::FileInfo
measure_time	.\lib\fbi\test\test_util.cpp	/^double measure_time(std::function<void(void)> f) {$/;"	f
measure_time_concurrent	.\lib\fbi\test\test_util.cpp	/^double measure_time_concurrent(unsigned thread_count,$/;"	f
memcache	.\AccessPoint.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\AccessPoint.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\AtomicTokenBucket.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\CallbackPool-inl.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\CallbackPool.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\ConfigApi.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\ConfigApi.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\DestinationClient.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\DestinationClient.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\ExponentialSmoothData.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\ExponentialSmoothData.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\FileDataProvider.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\FileDataProvider.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\FileObserver.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\FileObserver.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\LoggingProxyRequestContext.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\McrouterLogFailure.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\McrouterLogger.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\McrouterLogger.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\Observable-inl.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\Observable.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\PeriodicTaskScheduler.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\PeriodicTaskScheduler.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\PoolFactory.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\PoolFactory.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\PoolFactoryIf.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\ProxyClientCommon.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\ProxyClientCommon.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\ProxyConfig.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\ProxyConfig.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\ProxyConfigBuilder.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\ProxyConfigBuilder.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\ProxyConfigIf.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\ProxyDestination.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\ProxyDestination.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\ProxyDestinationMap.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\ProxyDestinationMap.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\ProxyMcReply.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\ProxyMcReply.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\ProxyMcRequest.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\ProxyMcRequest.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\ProxyRequestContext.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\ProxyRequestContext.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\ProxyRequestLogger-inl.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\ProxyRequestLogger.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\ProxyThread.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\ProxyThread.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\RecordingContext.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\RecordingContext.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\RoutingPrefix.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\RoutingPrefix.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\RuntimeVarsData.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\RuntimeVarsData.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\ServiceInfo.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\ServiceInfo.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\TkoCounters.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\TkoLog.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\TkoLog.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\TkoTracker.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\TkoTracker.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\TokenBucket.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\_router.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\async.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\async.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\awriter.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\flavor.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\flavor.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\lib\Ch3HashFunc.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\Crc32HashFunc.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\IOBufUtil.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\IOBufUtil.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\McMsgRef.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\McOperation.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\McOperationTraits.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\McReply.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\McReplyBase-inl.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\McReplyBase.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\McReplyBase.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\McRequest.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\McRequestBase.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\McRequestBase.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\McRequestWithContext-inl.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\McRequestWithContext.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\Operation.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\OperationTraits.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\Reply.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\RouteHandleIf.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\StatsReply.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\StatsReply.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\WeightedCh3HashFunc.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\WeightedCh3HashFunc.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\config\ConfigPreprocessor.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\config\ConfigPreprocessor.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\config\ImportResolverIf.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\config\RouteHandleBuilder.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\config\RouteHandleFactory-inl.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\config\RouteHandleFactory.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\config\RouteHandleProvider-inl.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\config\RouteHandleProvider.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\config\RouteHandleProviderIf.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fbi\cpp\AtomicLinkedList.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fbi\cpp\AtomicSharedPtr.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fbi\cpp\LogFailure.cpp	/^namespace facebook { namespace memcache { namespace failure {$/;"	n	namespace:facebook	file:
memcache	.\lib\fbi\cpp\LogFailure.h	/^namespace facebook { namespace memcache { namespace failure {$/;"	n	namespace:facebook
memcache	.\lib\fbi\cpp\ObjectPool.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fbi\cpp\ShutdownLock.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fbi\cpp\StartupLock.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fbi\cpp\Trie-inl.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fbi\cpp\Trie.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fbi\cpp\TypeList.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fbi\cpp\globals.cpp	/^namespace facebook { namespace memcache { namespace globals {$/;"	n	namespace:facebook	file:
memcache	.\lib\fbi\cpp\globals.h	/^namespace facebook { namespace memcache { namespace globals {$/;"	n	namespace:facebook
memcache	.\lib\fbi\cpp\traits.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fbi\cpp\util.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\fbi\cpp\util.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\AddTasks-inl.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n	namespace:facebook
memcache	.\lib\fibers\AddTasks.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n	namespace:facebook
memcache	.\lib\fibers\Baton-inl.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\Baton.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\fibers\Baton.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\BoostContextCompatibility.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\EventBaseLoopController-inl.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\lib\fibers\EventBaseLoopController.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\Fiber-inl.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\Fiber.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\fibers\Fiber.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\FiberManager-inl.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\FiberManager.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\fibers\FiberManager.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\FiberPromise-inl.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\FiberPromise.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\ForEach-inl.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n	namespace:facebook
memcache	.\lib\fibers\ForEach.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n	namespace:facebook
memcache	.\lib\fibers\GenericBaton.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\GuardPageAllocator-inl.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\GuardPageAllocator.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\LoopController.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\SimpleLoopController.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\TimeoutController.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\fibers\TimeoutController.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\fibers\WhenN-inl.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n	namespace:facebook
memcache	.\lib\fibers\WhenN.h	/^namespace facebook { namespace memcache { namespace fiber {$/;"	n	namespace:facebook
memcache	.\lib\network\AsyncMcClient-inl.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\AsyncMcClient.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\AsyncMcClientImpl-inl.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\AsyncMcClientImpl.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\network\AsyncMcClientImpl.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\AsyncMcServer.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\network\AsyncMcServer.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\AsyncMcServerWorker.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\network\AsyncMcServerWorker.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\AsyncMcServerWorkerOptions.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\ConnectionOptions.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\McParser.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\network\McParser.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\McSerializedRequest.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\network\McSerializedRequest.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\McServerRequestContext-inl.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\McServerRequestContext.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\network\McServerRequestContext.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\McServerSession.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\network\McServerSession.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\MultiOpParent.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\network\MultiOpParent.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\network\ThreadLocalSSLContextProvider.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\UmbrellaProtocol.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\network\UmbrellaProtocol.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\UniqueIntrusiveList.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\WriteBuffer.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\network\WriteBuffer.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\test\MockMc.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\network\test\MockMc.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\test\SessionTestHarness.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\lib\network\test\SessionTestHarness.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\network\test\TestUtil.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\routes\AllAsyncRoute.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\routes\AllFastestRoute.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\routes\AllInitialRoute.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\routes\AllMajorityRoute.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\routes\AllSyncRoute.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\routes\ErrorRoute.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\routes\FailoverRoute.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\routes\HashRoute.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\routes\HostIdRoute.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\routes\LatestRoute.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\routes\MigrateRoute.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\routes\MissFailoverRoute.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\routes\NullRoute.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\routes\WarmUpRoute.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\test\RouteHandleTestUtil.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\test\TestRequest.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\lib\test\TestRouteHandle.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\mcrouter_client.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\mcrouter_config.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\mcrouter_config.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\options.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\options.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\pclient-inl.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\pclient.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\pclient.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\priorities.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\priorities.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\proxy.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\proxy.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\route.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\route.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\router.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\router.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\routes\AllAsyncRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\routes\AllFastestRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\routes\AllInitialRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\routes\AllMajorityRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\routes\AllSyncRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\routes\AsynclogRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\AsynclogRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\BigValueRoute-inl.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\routes\BigValueRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\BigValueRoute.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\routes\BigValueRouteIf.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\routes\DefaultShadowPolicy.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\DestinationRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\DestinationRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\DevNullRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\DevNullRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\ErrorRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\routes\ExtraRouteHandleProviderIf.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\FailoverRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\routes\FailoverWithExptimeRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\FailoverWithExptimeRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\FailoverWithExptimeRouteIf.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\FailoverWithExptimeRouteIf.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\HashRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\routes\HostIdRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\routes\LatestRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\routes\McExtraRouteHandleProvider.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\McExtraRouteHandleProvider.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\McImportResolver.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\McImportResolver.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\McOpList.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\routes\McRouteHandleBuilder.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\McRouteHandleProvider.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\McRouteHandleProvider.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\McrouterRouteHandle.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\MigrateRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\MissFailoverRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\routes\NullRoute.cpp	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook	file:
memcache	.\routes\PrefixPolicyRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\PrefixPolicyRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\PrefixRouteSelector.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\PrefixRouteSelector.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\routes\ProxyRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\RateLimitRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\RateLimitRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\RateLimiter.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\RateLimiter.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\ReliablePoolRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\ReliablePoolRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\RootRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\RouteHandleMap.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\RouteHandleMap.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\RoutePolicyMap.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\RoutePolicyMap.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\RouteSelectorMap.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\ShadowRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\ShadowRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\ShadowRouteIf.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\ShardHashFunc.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\ShardHashFunc.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\ShardSplitRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\ShardSplitRoute.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\ShardSplitter.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\routes\ShardSplitter.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\TimeProviderFunc.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\routes\WarmUpRoute.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\server.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\server.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\standalone_options.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\standalone_options.h	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook
memcache	.\stats.cpp	/^namespace facebook { namespace memcache { namespace mcrouter {$/;"	n	namespace:facebook	file:
memcache	.\stats.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcache	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^namespace facebook { namespace memcache { namespace test {$/;"	n	namespace:facebook	file:
memcache	.\test\cpp_unit_tests\MemcacheLocal.h	/^namespace facebook { namespace memcache { namespace test {$/;"	n	namespace:facebook
memcache	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^namespace facebook { namespace memcache { namespace test {$/;"	n	namespace:facebook	file:
memcache	.\test\cpp_unit_tests\mcrouter_test_client.h	/^namespace facebook { namespace memcache {$/;"	n	namespace:facebook
memcacheLocal	.\test\cpp_unit_tests\libmcrouter_test.cpp	/^std::unique_ptr<MemcacheLocal> memcacheLocal = nullptr; \/\/ local memcached$/;"	v
memory_stats	.\stats.h	/^  memory_stats         =    0x20000,$/;"	e	enum:facebook::memcache::mcrouter::stat_group_t
mergeChunkGetReplies	.\routes\BigValueRoute-inl.h	/^Reply BigValueRoute<RouteHandleIf>::mergeChunkGetReplies($/;"	f	class:facebook::memcache::BigValueRoute
mergeMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic mergeMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
message	.\lib\fbi\error.h	/^  nstring_t message; \/\/!< Default error message$/;"	m	struct:fbi_err_s
message_size	.\lib\mc\umbrella_protocol.h	/^  size_t message_size;$/;"	m	struct:um_message_info_s
metadata	.\lib\mc\mc_fbtrace_info.h	/^  char metadata[FBTRACE_METADATA_SZ + 1];$/;"	m	struct:mc_fbtrace_info_s
metaget	.\test\MCProcess.py	/^    def metaget(self, keys):$/;"	m	class:MCProcess
migration_interval_sec	.\proxy.h	/^  uint64_t migration_interval_sec;$/;"	m	class:facebook::memcache::mcrouter::ProxyMigratedPool
migration_start_ts	.\proxy.h	/^  uint64_t migration_start_ts;$/;"	m	class:facebook::memcache::mcrouter::ProxyMigratedPool
min	.\lib\fbi\timer.h	/^  uint64_t min;$/;"	m	struct:fb_timer_s
mockDecref	.\lib\test\RequestReplyTest.cpp	/^static void mockDecref(mc_msg_t* msg) {$/;"	f	file:
mockIncref	.\lib\test\RequestReplyTest.cpp	/^static void mockIncref(mc_msg_t* msg) {$/;"	f	file:
modMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic modMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
mode	.\lib\fbi\test\asox_queue_test.cpp	/^  int mode;$/;"	m	struct:thread_arg_t	file:
move	.\AccessPoint.cpp	/^      port_(std::move(other.port_)) {$/;"	f	namespace:facebook::memcache::mcrouter
move	.\RoutingPrefix.cpp	/^    : prefix_(std::move(other.prefix_)) {$/;"	f	namespace:facebook::memcache::mcrouter
move	.\lib\network\McServerRequestContext.cpp	/^      asciiState_(std::move(other.asciiState_)) {$/;"	f	namespace:facebook::memcache
move	.\mcrouter_config.h	/^      : Base(std::move(other)) {$/;"	f	class:facebook::memcache::mcrouter::StringKeyedUnorderedMap
moveRef	.\lib\McMsgRef.h	/^  static Ref moveRef(T* ref) {$/;"	f	class:facebook::memcache::Ref
moveToMcReply	.\ProxyMcReply.cpp	/^McReply ProxyMcReply::moveToMcReply(ProxyMcReply&& proxyMcReply) {$/;"	f	class:facebook::memcache::mcrouter::ProxyMcReply
ms_to_timeval	.\lib\fbi\time.h	/^static inline timeval_t ms_to_timeval(const uint32_t ms) {$/;"	f
msec	.\lib\fbi\debug.c	209;"	d	file:
msec	.\lib\fbi\debug.c	237;"	d	file:
msg	.\lib\fbi\debug.c	/^  char msg[SZ_FORMAT_STR];$/;"	m	struct:msg_info	file:
msg	.\lib\mc\parser.h	/^  mc_msg_t *msg;$/;"	m	struct:parser_s
msg	.\lib\mc\umbrella.h	/^  entry_list_msg_t msg;    \/\/ So we have something for iovecs to point to$/;"	m	struct:entry_list_s
msg	.\lib\mc\umbrella.h	/^  mc_msg_t* msg;$/;"	m	struct:um_backing_msg_s
msgReady	.\lib\network\McParser.cpp	/^void McParser::msgReady(McMsgRef msg, uint64_t reqid) {$/;"	f	class:facebook::memcache::McParser
msg_	.\lib\McReplyBase.h	/^  McMsgRef msg_;$/;"	m	class:facebook::memcache::McReplyBase
msg_	.\lib\McRequestBase.h	/^  McMsgRef msg_;$/;"	m	class:facebook::memcache::McRequestBase
msg_	.\lib\network\UmbrellaProtocol.h	/^  entry_list_msg_t msg_;$/;"	m	class:facebook::memcache::UmbrellaSerializedReply
msg_cas	.\lib\mc\umbrella.h	/^  msg_cas = 0x400,$/;"	e	enum:msg_field_e
msg_delta	.\lib\mc\umbrella.h	/^  msg_delta = 0x100,$/;"	e	enum:msg_field_e
msg_double	.\lib\mc\umbrella.h	/^  msg_double = 0x80,$/;"	e	enum:msg_field_e
msg_err_code	.\lib\mc\umbrella.h	/^  msg_err_code = 0x8,$/;"	e	enum:msg_field_e
msg_exptime	.\lib\mc\umbrella.h	/^  msg_exptime = 0x20,$/;"	e	enum:msg_field_e
msg_fbtrace	.\lib\mc\umbrella.h	/^  msg_fbtrace = 0x800,$/;"	e	enum:msg_field_e
msg_field_e	.\lib\mc\umbrella.h	/^typedef enum msg_field_e {$/;"	g
msg_field_t	.\lib\mc\umbrella.h	/^} msg_field_t;$/;"	t	typeref:enum:msg_field_e
msg_flags	.\lib\mc\umbrella.h	/^  msg_flags = 0x10,$/;"	e	enum:msg_field_e
msg_header	.\lib\mc\umbrella.h	/^  entry_list_hdr_t msg_header; \/\/ Mostly for the magic byte$/;"	m	struct:entry_list_msg_s
msg_header_buf	.\lib\mc\umbrella.h	/^  char msg_header_buf[sizeof(entry_list_msg_t)];$/;"	m	struct:entry_list_msg_preparer_s
msg_info	.\lib\fbi\debug.c	/^struct msg_info {$/;"	s	file:
msg_key	.\lib\mc\umbrella.h	/^  msg_key = 0x2000,$/;"	e	enum:msg_field_e
msg_lease_id	.\lib\mc\umbrella.h	/^  msg_lease_id = 0x200,$/;"	e	enum:msg_field_e
msg_number	.\lib\mc\umbrella.h	/^  msg_number = 0x40,$/;"	e	enum:msg_field_e
msg_op	.\lib\mc\umbrella.h	/^  msg_op = 0x1,$/;"	e	enum:msg_field_e
msg_ready	.\lib\mc\parser.h	/^  void (*msg_ready)(void *context, uint64_t reqid, mc_msg_t *msg);$/;"	m	struct:parser_s
msg_ready_cb	.\lib\mc\umbrella_protocol.h	/^typedef void (msg_ready_cb)(void* context, uint64_t reqid, mc_msg_t* msg);$/;"	t
msg_reqid	.\lib\mc\umbrella.h	/^  msg_reqid = 0x4,$/;"	e	enum:msg_field_e
msg_result	.\lib\mc\umbrella.h	/^  msg_result = 0x2,$/;"	e	enum:msg_field_e
msg_stats	.\lib\mc\umbrella.h	/^  msg_stats = 0x1000,$/;"	e	enum:msg_field_e
msg_undefined	.\lib\mc\umbrella.h	/^  msg_undefined = 0,$/;"	e	enum:msg_field_e
msg_value	.\lib\mc\umbrella.h	/^  msg_value = 0x4000,$/;"	e	enum:msg_field_e
msgbuf	.\lib\mc\umbrella.h	/^  char *msgbuf;$/;"	m	struct:entry_list_msg_preparer_s
mtx	.\lib\fbi\cpp\ObjectPool.h	/^  std::mutex mtx;                       \/\/ Mutex for mutual exclusion$/;"	m	class:facebook::memcache::ThreadSafeObjectPool
mulMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic mulMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
multi_count_client	.\lib\fbi\test\asox_queue_test.cpp	/^void multi_count_client(asox_queue_t queue, int N, int nentries, int *running) {$/;"	f	namespace:__anon17
murmur_hash_64A	.\lib\fbi\hash.c	/^uint64_t murmur_hash_64A(const void* const key, const size_t len,$/;"	f
murmur_rehash_64A	.\lib\fbi\hash.c	/^static uint64_t murmur_rehash_64A(uint64_t k) {$/;"	f	file:
mutex_	.\router.cpp	/^  std::mutex mutex_;$/;"	m	class:facebook::memcache::mcrouter::__anon56::McrouterManager	file:
mux	.\ProxyThread.h	/^  std::mutex mux;$/;"	m	class:facebook::memcache::mcrouter::ProxyThread
mval	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  int mval;$/;"	m	struct:TestTypeThrowing	file:
mx	.\pclient.h	/^  std::mutex mx;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientOwner
my_elem_ready	.\lib\fbi\test\asox_queue_test.cpp	/^void my_elem_ready(asox_queue_t q, asox_queue_entry_t *entry, void *arg) {$/;"	f	namespace:__anon16
my_on_signal	.\lib\fbi\test\asox_sem_test.cpp	/^bool my_on_signal(asox_sem_t sem, uint64_t num_signals, void *arg) {$/;"	f	namespace:__anon20
myflag	.\lib\fbi\test\asox_queue_test.cpp	/^  int myflag;$/;"	m	struct:thread_arg_t	file:
myflag	.\lib\fbi\test\asox_sem_test.cpp	/^  int myflag;$/;"	m	struct:__anon20::test_arg_t	file:
mythread	.\lib\fbi\test\asox_queue_test.cpp	/^  int mythread;$/;"	m	struct:thread_arg_t	file:
mythread	.\lib\fbi\test\asox_sem_test.cpp	/^  int mythread;$/;"	m	struct:__anon20::test_arg_t	file:
nAllocations	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  static int nAllocations;$/;"	m	struct:TestAllocator	file:
nAllocations	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^template<typename T> int TestAllocator<T>::nAllocations;$/;"	m	class:TestAllocator	file:
nConstructed	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  static int nConstructed;$/;"	m	struct:TestType	file:
nConstructed	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^int TestType::nConstructed;$/;"	m	class:TestType	file:
nDeAllocations	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  static int nDeAllocations;$/;"	m	struct:TestAllocator	file:
nDeAllocations	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^template<typename T> int TestAllocator<T>::nDeAllocations;$/;"	m	class:TestAllocator	file:
nDestructed	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  static int nDestructed;$/;"	m	struct:TestType	file:
nDestructed	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^int TestType::nDestructed;$/;"	m	class:TestType	file:
n_	.\lib\Ch3HashFunc.h	/^  size_t n_;$/;"	m	class:facebook::memcache::Ch3HashFunc
n_	.\lib\Crc32HashFunc.h	/^  size_t n_;$/;"	m	class:facebook::memcache::Crc32HashFunc
n_	.\lib\test\RouteHandleTest.cpp	/^  size_t n_;$/;"	m	class:HashFunc	file:
n_	.\routes\ShardHashFunc.h	/^  size_t n_;$/;"	m	class:facebook::memcache::mcrouter::ConstShardHashFunc
n_	.\routes\test\ReliablePoolRouteTest.cpp	/^  size_t n_;$/;"	m	class:HashFunc	file:
name	.\lib\McOperation.h	/^  static const char* const name;$/;"	m	struct:facebook::memcache::McOperation
name	.\lib\McOperation.h	/^const char* const McOperation<op>::name = mc_op_to_string((mc_op_t)op);$/;"	m	class:facebook::memcache::McOperation
name	.\options.h	/^  std::string name;$/;"	m	struct:facebook::memcache::McrouterOptionData
name	.\stats.h	/^  folly::StringPiece name;$/;"	m	struct:facebook::memcache::mcrouter::stat_t
name_	.\lib\RouteHandleIf.h	/^  std::string name_;$/;"	m	class:facebook::memcache::RouteHandle
name_	.\lib\config\ConfigPreprocessor.cpp	/^  const string name_;$/;"	m	class:facebook::memcache::ConfigPreprocessor::Macro	file:
name_	.\lib\config\ConfigPreprocessor.cpp	/^  std::string name_;$/;"	m	class:facebook::memcache::ConfigPreprocessor::Const	file:
name_	.\proxy.h	/^  std::string name_;$/;"	m	class:facebook::memcache::mcrouter::ProxyGenericPool
names	.\lib\fbi\timer.h	/^  nstring_t *names;$/;"	m	struct:fb_timer_s
nbody	.\lib\mc\umbrella.h	/^  uint32_t nbody;          \/\/ body bytes used$/;"	m	struct:entry_list_s
nbuf	.\lib\mc\umbrella.h	/^  uint32_t nbuf;$/;"	m	struct:entry_list_msg_preparer_s
nbytes	.\lib\fbi\asox_queue.h	/^  size_t nbytes;$/;"	m	struct:asox_queue_entry_s
nentries	.\lib\mc\umbrella.h	/^  uint16_t nentries; \/\/ How many entries are there$/;"	m	struct:entry_list_msg_s
nentries	.\lib\mc\umbrella.h	/^  uint32_t nentries;          \/\/ entries array slots used$/;"	m	struct:entry_list_s
nerrs	.\lib\fbi\error.c	/^  size_t nerrs;$/;"	m	struct:_context_s	file:
nestedLimit_	.\lib\config\ConfigPreprocessor.cpp	/^  size_t& nestedLimit_;$/;"	m	class:facebook::memcache::__anon4::NestedLimitGuard	file:
nestedLimit_	.\lib\config\ConfigPreprocessor.h	/^  mutable size_t nestedLimit_;$/;"	m	class:facebook::memcache::ConfigPreprocessor
nestrings	.\lib\mc\umbrella.h	/^  uint32_t nestrings; \/\/ number of external strings$/;"	m	struct:entry_list_s
new_del_req	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	/^McMsgRef new_del_req(const char *key) {$/;"	f
new_get_req	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	/^McMsgRef new_get_req(const char *key) {$/;"	f
new_mc_fbtrace	.\lib\mc\mc_fbtrace_info.c	/^static mc_fbtrace_t* new_mc_fbtrace() {$/;"	f	file:
new_mc_fbtrace_info	.\lib\mc\mc_fbtrace_info.c	/^mc_fbtrace_info_t* new_mc_fbtrace_info(int is_copy) {$/;"	f
new_reply	.\proxy.cpp	/^MutableMcMsgRef new_reply(const char* str) {$/;"	f	namespace:facebook::memcache::mcrouter
next	.\lib\fbi\asox_queue.h	/^  struct asox_queue_entry_s *next;$/;"	m	struct:asox_queue_entry_s	typeref:struct:asox_queue_entry_s::asox_queue_entry_s
next	.\lib\fbi\cpp\AtomicLinkedList.h	/^  static T*& next(T* t) {$/;"	f	class:facebook::memcache::AtomicLinkedList
next	.\lib\fbi\lfcalloc.h	/^  void *next;$/;"	m	struct:__anon12
next	.\lib\fbi\nstring.h	/^  nstring_map_entry_t* next;$/;"	m	struct:nstring_map_iter_s
next	.\lib\fbi\nstring.h	/^  struct nstring_map_entry_s* next;$/;"	m	struct:nstring_map_entry_s	typeref:struct:nstring_map_entry_s::nstring_map_entry_s
nextRemoteReady_	.\lib\fibers\Fiber.h	/^  AtomicLinkedListHook<Fiber> nextRemoteReady_;$/;"	m	class:facebook::memcache::Fiber
nextRemoteTask	.\lib\fibers\FiberManager.h	/^    AtomicLinkedListHook<RemoteTask> nextRemoteTask;$/;"	m	struct:facebook::memcache::FiberManager::RemoteTask
nextTimeout_	.\lib\fibers\TimeoutController.h	/^  TimePoint nextTimeout_;$/;"	m	class:facebook::memcache::TimeoutController
next_	.\lib\fbi\cpp\Trie.h	/^  std::array<std::unique_ptr<Trie>, kNumChars> next_;$/;"	m	class:facebook::memcache::Trie
next_pow2	.\lib\fbi\util.h	/^static inline uint32_t next_pow2(uint32_t v) {$/;"	f
next_proxy	.\_router.h	/^  unsigned int next_proxy;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
next_proxy_mutex	.\_router.h	/^  std::mutex next_proxy_mutex;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
niovs	.\lib\mc\umbrella.h	/^  size_t niovs;             \/\/ Number of iovecs in iovs$/;"	m	struct:extern_iov_s
nlocal_errors	.\mcrouter_client.h	/^  uint32_t nlocal_errors;     \/\/ number of local errors$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_stats_t
noReply	.\lib\network\McServerRequestContext.cpp	/^bool McServerRequestContext::noReply(const McReply& reply) const {$/;"	f	class:facebook::memcache::McServerRequestContext
noReply_	.\lib\network\McServerRequestContext.h	/^  bool noReply_;$/;"	m	class:facebook::memcache::McServerRequestContext
noServerTimeoutTest	.\lib\network\test\AsyncMcClientTest.cpp	/^void noServerTimeoutTest(bool useSsl = false) {$/;"	f
no_long	.\mcrouter_options_list.h	14;"	d
no_long	.\mcrouter_options_list.h	424;"	d
no_long	.\standalone_options_list.h	14;"	d
no_long	.\standalone_options_list.h	92;"	d
no_short	.\mcrouter_options_list.h	15;"	d
no_short	.\mcrouter_options_list.h	423;"	d
no_short	.\standalone_options_list.h	15;"	d
no_short	.\standalone_options_list.h	91;"	d
node	.\lib\mc\mc_fbtrace_info.h	/^  fbtrace_node_t node;$/;"	m	struct:mc_fbtrace_s
noexcept	.\AccessPoint.h	/^  AccessPoint(AccessPoint&& other) noexcept;$/;"	m	struct:facebook::memcache::mcrouter::AccessPoint
noexcept	.\RoutingPrefix.h	/^  RoutingPrefix& operator=(RoutingPrefix&& other) noexcept;$/;"	m	class:facebook::memcache::mcrouter::RoutingPrefix
noexcept	.\RoutingPrefix.h	/^  RoutingPrefix& operator=(const RoutingPrefix& other) noexcept;$/;"	m	class:facebook::memcache::mcrouter::RoutingPrefix
noexcept	.\RoutingPrefix.h	/^  RoutingPrefix(RoutingPrefix&& other) noexcept;$/;"	m	class:facebook::memcache::mcrouter::RoutingPrefix
noexcept	.\RoutingPrefix.h	/^  RoutingPrefix(const RoutingPrefix& other) noexcept;$/;"	m	class:facebook::memcache::mcrouter::RoutingPrefix
noexcept	.\lib\McRequest.h	/^  McRequest(McRequest&& other) noexcept = default;$/;"	m	class:facebook::memcache::McRequest
noexcept	.\lib\McRequestBase.h	/^    explicit Keys(folly::StringPiece key) noexcept;$/;"	m	struct:facebook::memcache::McRequestBase::Keys
noexcept	.\lib\McRequestBase.h	/^  McRequestBase(McRequestBase&& other) noexcept = default;$/;"	m	class:facebook::memcache::McRequestBase
noexcept	.\lib\McRequestWithContext.h	/^  McRequestWithContext(McRequestWithContext&& other) noexcept = default;$/;"	m	class:facebook::memcache::McRequestWithContext
noexcept	.\lib\fibers\FiberPromise.h	/^  FiberPromise(FiberPromise&&) noexcept;$/;"	m	class:facebook::memcache::FiberPromise
noexcept	.\lib\network\AsyncMcServerWorker.h	/^  AsyncMcServerWorker(AsyncMcServerWorker&&) noexcept = delete;$/;"	m	class:facebook::memcache::AsyncMcServerWorker
noexcept	.\lib\network\McServerRequestContext.h	/^  McServerRequestContext(McServerRequestContext&& other) noexcept;$/;"	m	class:facebook::memcache::McServerRequestContext
noexcept	.\lib\network\UmbrellaProtocol.h	/^  UmbrellaSerializedReply(UmbrellaSerializedReply&&) noexcept = delete;$/;"	m	class:facebook::memcache::UmbrellaSerializedReply
noexcept	.\lib\network\WriteBuffer.h	/^  AsciiSerializedReply(AsciiSerializedReply&&) noexcept = delete;$/;"	m	class:facebook::memcache::AsciiSerializedReply
noexcept	.\lib\network\WriteBuffer.h	/^  WriteBuffer(WriteBuffer&&) noexcept = delete;$/;"	m	class:facebook::memcache::WriteBuffer
noexcept	.\lib\network\WriteBuffer.h	/^  WriteBufferQueue(WriteBufferQueue&&) noexcept = delete;$/;"	m	class:facebook::memcache::WriteBufferQueue
nonMagicInBytes	.\lib\fibers\Fiber.cpp	/^static size_t nonMagicInBytes(const FContext& context) {$/;"	f	namespace:facebook::memcache::__anon29
nonownedProxies_	.\_router.h	/^  std::vector<proxy_t*> nonownedProxies_;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
noop	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic noop(const folly::dynamic& json, const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
noreply	.\lib\mc\msg.h	/^  bool noreply;$/;"	m	struct:mc_msg_s
normalIndex_	.\routes\ShadowRoute.h	/^  const size_t normalIndex_;$/;"	m	class:facebook::memcache::mcrouter::ShadowRoute
normal_	.\routes\FailoverWithExptimeRoute.h	/^  std::shared_ptr<RouteHandleIf> normal_;$/;"	m	class:facebook::memcache::mcrouter::FailoverWithExptimeRoute
normal_	.\routes\ShadowRoute.h	/^  const std::shared_ptr<RouteHandleIf> normal_;$/;"	m	class:facebook::memcache::mcrouter::ShadowRoute
notMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic notMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
notify	.\CallbackPool-inl.h	/^void CallbackPool<Args...>::notify(Args... args) {$/;"	f	class:facebook::memcache::mcrouter::CallbackPool
notify	.\lib\fbi\cpp\StartupLock.h	/^  void notify() {$/;"	f	class:facebook::memcache::StartupLock
notify	.\test\cpp_unit_tests\awriter_test.cpp	/^  void notify(int v) {$/;"	f	class:AtomicCounter
notify_command_line	.\main.cpp	/^void notify_command_line(int argc, char ** argv) {$/;"	f
nowSec	.\mcrouter_config.h	/^inline double nowSec() {$/;"	f	namespace:facebook::memcache::mcrouter
nowUs	.\mcrouter_config.h	/^inline int64_t nowUs() {$/;"	f	namespace:facebook::memcache::mcrouter
nowWallSec	.\mcrouter_config.h	/^inline time_t nowWallSec() {$/;"	f	namespace:facebook::memcache::mcrouter
nremote_errors	.\mcrouter_client.h	/^  uint32_t nremote_errors;    \/\/ number of remote errors$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_stats_t
nreq	.\mcrouter_client.h	/^  uint32_t nreq;              \/\/ number of requests$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_stats_t
nstring_cmp	.\lib\fbi\nstring.h	/^static inline int nstring_cmp(const nstring_t* a, const nstring_t* b) {$/;"	f
nstring_copy	.\lib\fbi\nstring.h	/^static inline void nstring_copy(nstring_t* dest,$/;"	f
nstring_cpy	.\lib\fbi\nstring.h	/^static inline void nstring_cpy(nstring_t* dest, const nstring_t* src) {$/;"	f
nstring_del	.\lib\fbi\nstring.c	/^void nstring_del(const nstring_t* val) {$/;"	f
nstring_dup	.\lib\fbi\nstring.c	/^nstring_t* nstring_dup(const nstring_t* src) {$/;"	f
nstring_hash	.\lib\fbi\nstring.h	111;"	d
nstring_len_for_printf	.\lib\mc\protocol.c	/^static inline int nstring_len_for_printf(const nstring_t* ns) {$/;"	f	file:
nstring_map_clear	.\lib\fbi\nstring.h	/^static inline void nstring_map_clear(nstring_map_t* map) {$/;"	f
nstring_map_del	.\lib\fbi\nstring.h	/^static inline void nstring_map_del(nstring_map_t* map) {$/;"	f
nstring_map_entry_s	.\lib\fbi\nstring.h	/^typedef struct nstring_map_entry_s {$/;"	s
nstring_map_entry_t	.\lib\fbi\nstring.h	/^} nstring_map_entry_t;$/;"	t	typeref:struct:nstring_map_entry_s
nstring_map_get	.\lib\fbi\nstring.h	/^static inline const void* nstring_map_get(const nstring_map_t* map,$/;"	f
nstring_map_iter_del	.\lib\fbi\nstring.c	/^void nstring_map_iter_del(nstring_map_iter_t *iter) {$/;"	f
nstring_map_iter_get_key	.\lib\fbi\nstring.c	/^nstring_t* nstring_map_iter_get_key(nstring_map_iter_t *iter) {$/;"	f
nstring_map_iter_get_value	.\lib\fbi\nstring.c	/^const void* nstring_map_iter_get_value(nstring_map_iter_t *iter) {$/;"	f
nstring_map_iter_has_next	.\lib\fbi\nstring.h	/^static inline int nstring_map_iter_has_next(const nstring_map_iter_t* iter) {$/;"	f
nstring_map_iter_init	.\lib\fbi\nstring.h	/^static inline void nstring_map_iter_init(const nstring_map_t* map,$/;"	f
nstring_map_iter_is_valid	.\lib\fbi\nstring.h	/^static inline int nstring_map_iter_is_valid(const nstring_map_iter_t* iter) {$/;"	f
nstring_map_iter_new	.\lib\fbi\nstring.c	/^nstring_map_iter_t* nstring_map_iter_new(const nstring_map_t* map) {$/;"	f
nstring_map_iter_next	.\lib\fbi\nstring.h	/^static inline nstring_map_entry_t* nstring_map_iter_next(nstring_map_iter_t *iter) {$/;"	f
nstring_map_iter_s	.\lib\fbi\nstring.h	/^typedef struct nstring_map_iter_s {$/;"	s
nstring_map_iter_t	.\lib\fbi\nstring.h	/^} nstring_map_iter_t;$/;"	t	typeref:struct:nstring_map_iter_s
nstring_map_new	.\lib\fbi\nstring.h	/^static inline nstring_map_t* nstring_map_new(const size_t buckets,$/;"	f
nstring_map_prev	.\lib\fbi\nstring.h	/^static inline nstring_map_entry_t** nstring_map_prev(nstring_map_t* map,$/;"	f
nstring_map_remove	.\lib\fbi\nstring.h	/^static inline void nstring_map_remove(nstring_map_t* map,$/;"	f
nstring_map_s	.\lib\fbi\nstring.h	/^typedef struct nstring_map_s {$/;"	s
nstring_map_set	.\lib\fbi\nstring.h	/^static inline int nstring_map_set(nstring_map_t* map,$/;"	f
nstring_map_size	.\lib\fbi\nstring.h	/^static inline size_t nstring_map_size(const nstring_map_t* map) {$/;"	f
nstring_map_sizeof	.\lib\fbi\nstring.h	/^static inline size_t nstring_map_sizeof(const size_t buckets) {$/;"	f
nstring_map_sorted_iter_compare	.\lib\fbi\nstring.h	/^static inline int nstring_map_sorted_iter_compare(const nstring_t *a, const nstring_t *b) {$/;"	f
nstring_map_sorted_iter_del	.\lib\fbi\nstring.h	/^static inline void nstring_map_sorted_iter_del(nstring_map_sorted_iter_t i) {$/;"	f
nstring_map_sorted_iter_new	.\lib\fbi\nstring.h	/^static inline nstring_map_sorted_iter_t nstring_map_sorted_iter_new(const nstring_map_t* map) {$/;"	f
nstring_map_sorted_iter_next	.\lib\fbi\nstring.h	/^static inline nstring_map_entry_t* nstring_map_sorted_iter_next(nstring_map_sorted_iter_t i) {$/;"	f
nstring_map_sorted_iter_s	.\lib\fbi\nstring.h	/^typedef struct nstring_map_sorted_iter_s {$/;"	s
nstring_map_sorted_iter_t	.\lib\fbi\nstring.h	/^} *nstring_map_sorted_iter_t;$/;"	t	typeref:struct:nstring_map_sorted_iter_s
nstring_map_t	.\lib\fbi\nstring.h	/^} nstring_map_t;$/;"	t	typeref:struct:nstring_map_s
nstring_ncmp	.\lib\fbi\nstring.h	/^static inline int nstring_ncmp(const nstring_t* a,$/;"	f
nstring_ncpy	.\lib\fbi\nstring.h	/^static inline void nstring_ncpy(nstring_t* dest, const nstring_t* src) {$/;"	f
nstring_new	.\lib\fbi\nstring.c	/^nstring_t* nstring_new(const char* str, size_t len) {$/;"	f
nstring_of	.\lib\fbi\nstring.h	/^static inline nstring_t nstring_of(char* str) {$/;"	f
nstring_s	.\lib\fbi\nstring.h	/^typedef struct nstring_s {$/;"	s
nstring_safe	.\lib\fbi\nstring.h	/^static inline const char* nstring_safe(const nstring_t* nstring) {$/;"	f
nstring_sizeof	.\lib\fbi\nstring.h	/^static inline size_t nstring_sizeof(const size_t len) {$/;"	f
nstring_t	.\lib\fbi\nstring.h	/^} nstring_t;$/;"	t	typeref:struct:nstring_s
nstrstr	.\lib\fbi\nstring.h	/^static inline ssize_t nstrstr(nstring_t haystack, nstring_t needle) {$/;"	f
ntmo	.\mcrouter_client.h	/^  uint32_t ntmo;              \/\/ number of timeouts$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_stats_t
ntoh16	.\lib\mc\umbrella.h	31;"	d
ntoh32	.\lib\mc\umbrella.h	30;"	d
ntoh64	.\lib\mc\umbrella.h	29;"	d
ntoh8	.\lib\mc\umbrella.h	32;"	d
numChunks	.\routes\BigValueRoute-inl.h	/^uint32_t BigValueRoute<RouteHandleIf>::ChunksInfo::numChunks() const {$/;"	f	class:facebook::memcache::BigValueRoute::ChunksInfo
numChunks_	.\routes\BigValueRoute.h	/^    uint32_t numChunks_;$/;"	m	class:facebook::memcache::BigValueRoute::ChunksInfo
num_counters	.\lib\fbi\test\counter_test.cpp	/^  int num_counters;$/;"	m	struct:test_params_s	file:
num_major_faults	.\stats.cpp	/^  unsigned long num_major_faults;$/;"	m	struct:facebook::memcache::mcrouter::proc_stat_data_t	file:
num_minor_faults	.\stats.cpp	/^  unsigned long num_minor_faults;$/;"	m	struct:facebook::memcache::mcrouter::proc_stat_data_t	file:
num_pending	.\mcrouter_client.h	/^  int num_pending;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_t
num_pending_signals	.\lib\fbi\asox_semaphore.c	/^  volatile int64_t num_pending_signals;$/;"	m	struct:asox_sem_s	file:
num_rounds	.\lib\fbi\test\asox_queue_test.cpp	/^  int num_rounds;$/;"	m	struct:thread_arg_t	file:
num_rounds	.\lib\fbi\test\asox_sem_test.cpp	/^  int num_rounds;$/;"	m	struct:__anon20::test_arg_t	file:
num_stat_types	.\stats.h	/^  num_stat_types$/;"	e	enum:facebook::memcache::mcrouter::stat_type_t
num_stats	.\stats.h	/^  num_stats,$/;"	e	enum:facebook::memcache::mcrouter::stat_name_t
num_threads	.\lib\fbi\test\counter_test.cpp	/^  int num_threads;$/;"	m	struct:test_params_s	file:
num_timers	.\lib\fbi\timer.c	/^static int num_timers = 0;$/;"	v	file:
number	.\lib\McReplyBase.h	/^  uint32_t number() const {$/;"	f	class:facebook::memcache::McReplyBase
number	.\lib\mc\msg.h	/^  uint32_t number; \/\/\/< flushall delay, verbosity, age in metaget$/;"	m	struct:mc_msg_s
nzlib_format_s	.\lib\mc\msg.c	/^typedef struct nzlib_format_s {$/;"	s	file:
nzlib_format_t	.\lib\mc\msg.c	/^} nzlib_format_t;$/;"	t	typeref:struct:nzlib_format_s	file:
objectPool	.\lib\fbi\cpp\ObjectPool.h	/^  ObjectPool<T,Allocator> objectPool;   \/\/ Object pool used for allocations$/;"	m	class:facebook::memcache::ThreadSafeObjectPool
ods_stats	.\stats.h	/^  ods_stats            =       0x40,$/;"	e	enum:facebook::memcache::mcrouter::stat_group_t
off	.\lib\mc\parser.h	/^  size_t off;$/;"	m	struct:parser_s
offset	.\lib\mc\ascii_response.h	/^  size_t offset;$/;"	m	struct:mc_ascii_response_buf_s
offset	.\lib\mc\umbrella.h	/^      uint32_t offset;  \/\/   How far into the body does the string start?$/;"	m	struct:um_elist_entry_s::__anon34::__anon35
old_config_req_t	.\proxy.h	/^  explicit old_config_req_t(std::shared_ptr<ProxyConfigIf> config)$/;"	f	struct:facebook::memcache::mcrouter::old_config_req_t
old_config_req_t	.\proxy.h	/^struct old_config_req_t {$/;"	s	namespace:facebook::memcache::mcrouter
onAccepted_	.\lib\network\AsyncMcServerWorker.h	/^  std::function<void()> onAccepted_;$/;"	m	class:facebook::memcache::AsyncMcServerWorker
onClosed_	.\lib\network\AsyncMcServerWorker.h	/^  std::function<void(McServerSession&)> onClosed_;$/;"	m	class:facebook::memcache::AsyncMcServerWorker
onDestroyed	.\lib\test\TestRequest.h	/^  std::function<void()> onDestroyed;$/;"	m	struct:facebook::memcache::Context
onDown	.\lib\network\AsyncMcClientImpl.h	/^      onDown;$/;"	m	struct:facebook::memcache::AsyncMcClientImpl::ConnectionStatusCallbacks
onEventBaseAttached	.\proxy.cpp	/^void proxy_t::onEventBaseAttached() {$/;"	f	class:facebook::memcache::mcrouter::proxy_t
onFiber	.\lib\fibers\FiberManager.h	/^inline bool onFiber() {$/;"	f	namespace:facebook::memcache::fiber
onReplyReceived	.\LoggingProxyRequestContext.h	/^  void onReplyReceived(const ProxyClientCommon& pclient,$/;"	f	class:facebook::memcache::mcrouter::LoggingProxyRequestContext
onRequest	.\lib\network\test\AsyncMcClientTest.cpp	/^  void onRequest(McServerRequestContext&& ctx,$/;"	f	class:__anon42::ServerOnRequest
onRequest	.\lib\network\test\MockMcServer.cpp	/^  void onRequest(McServerRequestContext&& ctx,$/;"	f	class:MockMcOnRequest
onRequest	.\lib\network\test\SessionTestHarness.h	/^    void onRequest(McServerRequestContext&& ctx,$/;"	f	class:facebook::memcache::SessionTestHarness::OnRequest
onRequest	.\lib\network\test\SessionTestHarness.h	/^  void onRequest(McServerRequestContext&& ctx,$/;"	f	class:facebook::memcache::SessionTestHarness
onRequest	.\server.cpp	/^  void onRequest(McServerRequestContext&& ctx,$/;"	f	class:facebook::memcache::mcrouter::__anon60::ServerOnRequest
onRequest_	.\lib\network\AsyncMcServerWorker.h	/^  std::shared_ptr<McServerOnRequest> onRequest_;$/;"	m	class:facebook::memcache::AsyncMcServerWorker
onRequest_	.\lib\network\McServerRequestContext.h	/^  OnRequest onRequest_;$/;"	m	class:facebook::memcache::McServerOnRequestWrapper
onRequest_	.\lib\network\McServerSession.h	/^  std::shared_ptr<McServerOnRequest> onRequest_;$/;"	m	class:facebook::memcache::McServerSession
onResetTimer	.\ProxyDestinationMap.cpp	/^void onResetTimer(const asox_timer_t timer, void* arg) {$/;"	f	namespace:facebook::memcache::mcrouter::__anon54
onShutdown_	.\lib\network\AsyncMcServerWorker.h	/^  std::function<void()> onShutdown_;$/;"	m	class:facebook::memcache::AsyncMcServerWorker
onShutdown_	.\lib\network\McServerSession.h	/^  std::function<void()> onShutdown_;$/;"	m	class:facebook::memcache::McServerSession
onTerminated_	.\lib\network\McServerSession.h	/^  std::function<void(McServerSession&)> onTerminated_;$/;"	m	class:facebook::memcache::McServerSession
onTimeout	.\lib\fibers\TimeoutController.cpp	/^void TimeoutHandle::onTimeout() {$/;"	f	class:facebook::memcache::TimeoutHandle
onTkoEvent	.\ProxyDestination.cpp	/^void ProxyDestination::onTkoEvent(TkoLogEvent event, mc_res_t result) const {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
onTransactionCompleted	.\lib\network\McServerSession.cpp	/^void McServerSession::onTransactionCompleted(bool isSubRequest) {$/;"	f	class:facebook::memcache::McServerSession
onTransactionStarted	.\lib\network\McServerSession.cpp	/^void McServerSession::onTransactionStarted(bool isSubRequest) {$/;"	f	class:facebook::memcache::McServerSession
onUp	.\lib\network\AsyncMcClientImpl.h	/^    std::function<void()> onUp;$/;"	m	struct:facebook::memcache::AsyncMcClientImpl::ConnectionStatusCallbacks
onWriteQuiescence_	.\lib\network\AsyncMcServerWorker.h	/^  std::function<void(McServerSession&)> onWriteQuiescence_;$/;"	m	class:facebook::memcache::AsyncMcServerWorker
onWriteQuiescence_	.\lib\network\McServerSession.h	/^  std::function<void(McServerSession&)> onWriteQuiescence_;$/;"	m	class:facebook::memcache::McServerSession
on_assert_fail	.\main.cpp	/^void on_assert_fail(const char *msg) {$/;"	f
on_cancel	.\router.h	/^  mcrouter_on_cancel_t* on_cancel;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_callbacks_t
on_cancel	.\test\cpp_unit_tests\libmcrouter_test.cpp	/^void on_cancel(mcrouter_client_t* client,$/;"	f
on_disconnect	.\router.h	/^  mcrouter_on_disconnect_ts_t* on_disconnect;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_callbacks_t
on_disconnect	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	/^void on_disconnect(void* context) {$/;"	f
on_down	.\ProxyDestination.cpp	/^void ProxyDestination::on_down() {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
on_elem_ready	.\lib\fbi\asox_queue.h	/^  asox_queue_element_ready* on_elem_ready;$/;"	m	struct:asox_queue_callbacks_s
on_elem_sweep	.\lib\fbi\asox_queue.h	/^  asox_queue_element_sweep* on_elem_sweep;$/;"	m	struct:asox_queue_callbacks_s
on_probe_timer	.\ProxyDestination.cpp	/^void on_probe_timer(const asox_timer_t timer, void* arg) {$/;"	f	namespace:facebook::memcache::mcrouter::__anon53
on_reply	.\ProxyDestination.cpp	/^void ProxyDestination::on_reply(const McMsgRef& req,$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
on_reply	.\router.h	/^  mcrouter_on_reply_t* on_reply;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_callbacks_t
on_reply	.\test\cpp_unit_tests\libmcrouter_test.cpp	/^void on_reply(mcrouter_client_t *client,$/;"	f
on_reply	.\test\cpp_unit_tests\mcrouter_cpp_tests.cpp	/^void on_reply(mcrouter_client_t *client,$/;"	f
on_reply	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^static void on_reply(mcrouter_client_t *client,$/;"	f	file:
on_signal	.\lib\fbi\asox_semaphore.h	/^  asox_sem_on_signal* on_signal;$/;"	m	struct:asox_sem_callbacks_s
on_timer	.\ProxyDestination.cpp	/^void ProxyDestination::on_timer(const asox_timer_t timer) {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
on_timer	.\lib\fbi\asox_timer.c	/^  asox_on_timer_t* on_timer;$/;"	m	struct:_asox_timer_s	file:
on_up	.\ProxyDestination.cpp	/^void ProxyDestination::on_up() {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
op	.\lib\mc\msg.h	/^  mc_op_t op;$/;"	m	struct:mc_msg_s
op	.\lib\network\AsyncMcClientImpl.h	/^    mc_op_t op;$/;"	m	class:facebook::memcache::AsyncMcClientImpl::ReqInfo
op	.\proxy.h	/^  proxy_pool_failover_type_t op[FAILOVER_MAX][mc_nops];$/;"	m	struct:facebook::memcache::mcrouter::proxy_pool_failover_policy_t
op	.\routes\McOpList.h	/^template <> struct McOpList::Item< 1> { typedef McOperation<mc_op_echo> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item< 2> { typedef McOperation<mc_op_version> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item< 3> { typedef McOperation<mc_op_replace> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item< 4> { typedef McOperation<mc_op_cas> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item< 5> { typedef McOperation<mc_op_decr> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item< 6> { typedef McOperation<mc_op_stats> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item< 7> { typedef McOperation<mc_op_metaget> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item< 8> { typedef McOperation<mc_op_gets> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item< 9> { typedef McOperation<mc_op_get_service_info> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item<10> { typedef McOperation<mc_op_bump_unique_count> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item<11> { typedef McOperation<mc_op_get_count> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item<12> { typedef McOperation<mc_op_bump_count> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item<13> { typedef McOperation<mc_op_get_unique_count> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item<14> { typedef McOperation<mc_op_incr> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item<15> { typedef McOperation<mc_op_add> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item<16> { typedef McOperation<mc_op_lease_set> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item<17> { typedef McOperation<mc_op_set> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item<18> { typedef McOperation<mc_op_delete> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item<19> { typedef McOperation<mc_op_lease_get> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op	.\routes\McOpList.h	/^template <> struct McOpList::Item<20> { typedef McOperation<mc_op_get> op; };$/;"	t	struct:facebook::memcache::McOpList::Item
op_count	.\mcrouter_client.h	/^  uint32_t op_count[mc_nops]; \/\/ number of requests for certain op$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_stats_t
op_key_bytes	.\mcrouter_client.h	/^  uint32_t op_key_bytes[mc_nops]; \/\/ request key bytes$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_stats_t
op_value_bytes	.\mcrouter_client.h	/^  uint32_t op_value_bytes[mc_nops]; \/\/ request + reply value bytes$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_stats_t
open_pidfile	.\main.cpp	/^FILE* open_pidfile(const char* pidfile) {$/;"	f
operationPolicies_	.\routes\PrefixPolicyRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> operationPolicies_;$/;"	m	class:facebook::memcache::mcrouter::PrefixPolicyRoute
operation_	.\lib\network\McServerRequestContext.h	/^  mc_op_t operation_;$/;"	m	class:facebook::memcache::McServerRequestContext
operator ()	.\lib\Ch3HashFunc.h	/^  size_t operator() (folly::StringPiece hashable) const {$/;"	f	class:facebook::memcache::Ch3HashFunc
operator ()	.\lib\Crc32HashFunc.h	/^  size_t operator() (folly::StringPiece hashable) const {$/;"	f	class:facebook::memcache::Crc32HashFunc
operator ()	.\lib\McMsgRef.h	/^    void operator()(mc_msg_t* msg) const {$/;"	f	class:facebook::memcache::McMsgRefPolicy::Deleter
operator ()	.\lib\McRequestBase.h	/^      void operator()(mc_fbtrace_info_t* info) const {$/;"	f	struct:facebook::memcache::McRequestBase::McFbtraceRefPolicy::Deleter
operator ()	.\lib\WeightedCh3HashFunc.cpp	/^size_t WeightedCh3HashFunc::operator()(folly::StringPiece key) const {$/;"	f	class:facebook::memcache::WeightedCh3HashFunc
operator ()	.\lib\fibers\FiberManager-inl.h	/^    void operator()() {$/;"	f	class:facebook::memcache::FiberManager::AddTaskFinallyHelper::Finally
operator ()	.\lib\fibers\FiberManager-inl.h	/^    void operator()() {$/;"	f	class:facebook::memcache::FiberManager::AddTaskFinallyHelper::Func
operator ()	.\lib\network\AsyncMcClientImpl.h	/^      void operator()(ReqInfo* ptr) const {$/;"	f	class:facebook::memcache::AsyncMcClientImpl::ReqInfo::Deleter
operator ()	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^  size_t operator()(const CertPaths& paths) const {$/;"	f	struct:facebook::memcache::CertPathsHasher
operator ()	.\lib\test\RouteHandleTest.cpp	/^  size_t operator()(folly::StringPiece key) const {$/;"	f	class:HashFunc
operator ()	.\proxy.cpp	/^  void operator() (GenericProxyRequestContext* ctx) const {$/;"	f	struct:facebook::memcache::mcrouter::MainContextDeleter
operator ()	.\routes\RouteHandleMap.cpp	/^  size_t operator()(const RouteSelectorVector& v) const {$/;"	f	struct:facebook::memcache::mcrouter::__anon58::VectorHash
operator ()	.\routes\ShardHashFunc.cpp	/^size_t ConstShardHashFunc::operator()(folly::StringPiece key) const {$/;"	f	class:facebook::memcache::mcrouter::ConstShardHashFunc
operator ()	.\routes\TimeProviderFunc.h	/^  time_t operator() (const Request& req) const {$/;"	f	class:facebook::memcache::mcrouter::TimeProviderFunc
operator ()	.\routes\test\ReliablePoolRouteTest.cpp	/^  size_t operator()(folly::StringPiece key) const {$/;"	f	class:HashFunc
operator *	.\lib\McMsgRef.h	/^  T& operator*() const { return *ref_; }$/;"	f	class:facebook::memcache::Ref
operator ->	.\lib\McMsgRef.h	/^  T* operator->() const { return ref_; }$/;"	f	class:facebook::memcache::Ref
operator =	.\AccessPoint.cpp	/^AccessPoint& AccessPoint::operator=(AccessPoint&& other) {$/;"	f	class:facebook::memcache::mcrouter::AccessPoint
operator =	.\AccessPoint.cpp	/^AccessPoint& AccessPoint::operator=(const AccessPoint& other) {$/;"	f	class:facebook::memcache::mcrouter::AccessPoint
operator =	.\lib\McMsgRef.h	/^  Ref& operator=(Ref&& from) {$/;"	f	class:facebook::memcache::Ref
operator =	.\lib\McMsgRef.h	/^  Ref& operator=(std::unique_ptr<M, D>&& from) {$/;"	f	class:facebook::memcache::Ref
operator =	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::operator=(Trie&& other) {$/;"	f	class:facebook::memcache::Trie
operator =	.\lib\fbi\cpp\Trie-inl.h	/^Trie<Value, MinChar, MaxChar>::operator=(const Trie& other) {$/;"	f	class:facebook::memcache::Trie
operator =	.\lib\fibers\FiberPromise-inl.h	/^FiberPromise<T>& FiberPromise<T>::operator=(FiberPromise&& other) {$/;"	f	class:facebook::memcache::FiberPromise
operator =	.\lib\network\McServerRequestContext.cpp	/^McServerRequestContext& McServerRequestContext::operator=($/;"	f	class:facebook::memcache::McServerRequestContext
operator ==	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^  bool operator==(const CertPaths& other) const {$/;"	f	struct:facebook::memcache::CertPaths
operator []	.\mcrouter_config.h	/^  mapped_type& operator[](folly::StringPiece key) {$/;"	f	class:facebook::memcache::mcrouter::StringKeyedUnorderedMap
operator const std::string&	.\RoutingPrefix.h	/^  \/* implicit *\/ operator const std::string&() const { return prefix_; }$/;"	f	class:facebook::memcache::mcrouter::RoutingPrefix
operator folly::StringPiece	.\RoutingPrefix.h	/^  \/* implicit *\/ operator folly::StringPiece() const { return prefix_; }$/;"	f	class:facebook::memcache::mcrouter::RoutingPrefix
optionTypeToString	.\options.cpp	/^std::string optionTypeToString(McrouterOptionData::Type type) {$/;"	f	namespace:facebook::memcache::__anon48
options	.\options.cpp	/^namespace options {$/;"	n	namespace:facebook::memcache	file:
options	.\options.h	/^namespace options {$/;"	n	namespace:facebook::memcache
options	.\standalone_options.cpp	/^namespace options {$/;"	n	namespace:facebook::memcache::mcrouter	file:
options	.\standalone_options.h	/^namespace options {$/;"	n	namespace:facebook::memcache::mcrouter
options_	.\lib\fibers\FiberManager.h	/^  const Options options_;       \/**< FiberManager options *\/$/;"	m	class:facebook::memcache::FiberManager
options_	.\lib\network\McServerSession.h	/^  AsyncMcServerWorkerOptions options_;$/;"	m	class:facebook::memcache::McServerSession
options_	.\routes\BigValueRoute.h	/^  const BigValueRouteOptions options_;$/;"	m	class:facebook::memcache::BigValueRoute
opts	.\_router.h	/^  const McrouterOptions opts;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
opts	.\main.cpp	/^static McrouterOptions opts;$/;"	v	file:
opts	.\proxy.h	/^  const McrouterOptions opts;$/;"	m	struct:facebook::memcache::mcrouter::proxy_t
opts_	.\ConfigApi.h	/^  const McrouterOptions& opts_;$/;"	m	class:facebook::memcache::mcrouter::ConfigType::ConfigApi
opts_	.\PoolFactory.h	/^  Options opts_;$/;"	m	class:facebook::memcache::mcrouter::PoolFactory
opts_	.\lib\network\AsyncMcServer.h	/^  Options opts_;$/;"	m	class:facebook::memcache::AsyncMcServer
opts_	.\lib\network\AsyncMcServerWorker.h	/^  AsyncMcServerWorkerOptions opts_;$/;"	m	class:facebook::memcache::AsyncMcServerWorker
opts_	.\lib\network\test\AsyncMcClientTest.cpp	/^  AsyncMcServer::Options opts_;$/;"	m	class:__anon42::TestServer	file:
opts_	.\routes\RootRoute.h	/^  const McrouterOptions& opts_;$/;"	m	class:facebook::memcache::mcrouter::RootRoute
orMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic orMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
orderedUnique	.\routes\RoutePolicyMap.cpp	/^orderedUnique(const vector<McrouterRouteHandlePtr>& v) {$/;"	f	namespace:facebook::memcache::mcrouter
orig_req	.\proxy.h	/^  McMsgRef orig_req; \/\/\/< Reference to the incoming request$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t
os	.\test\MCProcess.py	/^import os$/;"	i
os	.\test\test_async_files.py	/^import os$/;"	i
os	.\test\test_bad_params.py	/^import os$/;"	i
other	.\lib\McMsgRef.h	/^  Ref& operator=(const Ref& other) = delete;$/;"	m	class:facebook::memcache::Ref
other	.\lib\McMsgRef.h	/^  Ref(const Ref& other) = delete;$/;"	m	class:facebook::memcache::Ref
other	.\lib\McReplyBase.h	/^  McReplyBase& operator=(McReplyBase&& other) = default;$/;"	m	class:facebook::memcache::McReplyBase
other	.\lib\McReplyBase.h	/^  McReplyBase(McReplyBase&& other) = default;$/;"	m	class:facebook::memcache::McReplyBase
other	.\lib\McRequest.h	/^  McRequest& operator=(McRequest&& other) = default;$/;"	m	class:facebook::memcache::McRequest
other	.\lib\McRequestBase.h	/^  McRequestBase& operator=(McRequestBase&& other) = default;$/;"	m	class:facebook::memcache::McRequestBase
other	.\lib\McRequestWithContext.h	/^  McRequestWithContext& operator=(McRequestWithContext&& other) = default;$/;"	m	class:facebook::memcache::McRequestWithContext
other	.\lib\fbi\cpp\sfrlock.h	/^  SFRLock& operator=(const SFRLock& other) = delete;$/;"	m	class:SFRLock
other	.\lib\fbi\cpp\sfrlock.h	/^  SFRLock(const SFRLock& other) = delete;$/;"	m	class:SFRLock
other	.\lib\fibers\AddTasks.h	/^  TaskIterator& operator=(TaskIterator&& other) = delete;$/;"	m	class:facebook::memcache::fiber::TaskIterator
other	.\lib\fibers\AddTasks.h	/^  TaskIterator& operator=(const TaskIterator& other) = delete;$/;"	m	class:facebook::memcache::fiber::TaskIterator
other	.\lib\fibers\AddTasks.h	/^  TaskIterator(const TaskIterator& other) = delete;$/;"	m	class:facebook::memcache::fiber::TaskIterator
other	.\lib\network\AsyncMcClientImpl.h	/^    ReqInfo& operator=(const ReqInfo& other) = delete;$/;"	m	class:facebook::memcache::AsyncMcClientImpl::ReqInfo
outOfOrder	.\lib\network\McParser.h	/^  bool outOfOrder() const {$/;"	f	class:facebook::memcache::McParser
outOfOrder_	.\lib\network\test\AsyncMcClientTest.cpp	/^  bool outOfOrder_ = false;$/;"	m	class:__anon42::TestServer	file:
outOfOrder_	.\lib\network\test\AsyncMcClientTest.cpp	/^  bool outOfOrder_;$/;"	m	class:__anon42::ServerOnRequest	file:
output_	.\lib\network\test\SessionTestHarness.h	/^  std::vector<std::string> output_;$/;"	m	class:facebook::memcache::SessionTestHarness
outstandingThrottleTest	.\lib\network\test\AsyncMcClientTest.cpp	/^void outstandingThrottleTest(bool useSsl = false) {$/;"	f
outstanding_	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^  sem_t outstanding_;$/;"	m	class:facebook::memcache::test::ResultsSet	file:
outstanding_reqs_sem	.\mcrouter_client.h	/^  counting_sem_t outstanding_reqs_sem;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_t
override	.\lib\fibers\EventBaseLoopController.h	/^  void cancel() override;$/;"	m	class:facebook::memcache::mcrouter::EventBaseLoopController
override	.\lib\fibers\EventBaseLoopController.h	/^  void schedule() override;$/;"	m	class:facebook::memcache::mcrouter::EventBaseLoopController
override	.\lib\fibers\EventBaseLoopController.h	/^  void scheduleThreadSafe() override;$/;"	m	class:facebook::memcache::mcrouter::EventBaseLoopController
override	.\lib\fibers\EventBaseLoopController.h	/^  void setFiberManager(FiberManager* fm) override;$/;"	m	class:facebook::memcache::mcrouter::EventBaseLoopController
override	.\lib\fibers\EventBaseLoopController.h	/^  void timedSchedule(std::function<void()> func, TimePoint time) override;$/;"	m	class:facebook::memcache::mcrouter::EventBaseLoopController
override	.\lib\network\AsyncMcClientImpl.h	/^                  const TransportException& ex) noexcept override;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
override	.\lib\network\AsyncMcClientImpl.h	/^  void connectError(const TransportException& ex) noexcept override;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
override	.\lib\network\AsyncMcClientImpl.h	/^  void connectSuccess() noexcept override;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
override	.\lib\network\AsyncMcClientImpl.h	/^  void getReadBuffer(void** bufReturn, size_t* lenReturn) override;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
override	.\lib\network\AsyncMcClientImpl.h	/^  void parseError(McReply errorReply) override;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
override	.\lib\network\AsyncMcClientImpl.h	/^  void readDataAvailable(size_t len) noexcept override;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
override	.\lib\network\AsyncMcClientImpl.h	/^  void readEOF() noexcept override;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
override	.\lib\network\AsyncMcClientImpl.h	/^  void readError(const TransportException& ex) noexcept override;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
override	.\lib\network\AsyncMcClientImpl.h	/^  void replyReady(McReply mcReply, mc_op_t operation, uint64_t reqid) override;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
override	.\lib\network\AsyncMcClientImpl.h	/^  void writeSuccess() noexcept override;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
override	.\lib\network\McServerSession.h	/^    noexcept override;$/;"	m	class:facebook::memcache::McServerSession
override	.\lib\network\McServerSession.h	/^    void runLoopCallback() noexcept override;$/;"	m	struct:facebook::memcache::McServerSession::SendWritesCallback
override	.\lib\network\McServerSession.h	/^  void getReadBuffer(void** bufReturn, size_t* lenReturn) override;$/;"	m	class:facebook::memcache::McServerSession
override	.\lib\network\McServerSession.h	/^  void readDataAvailable(size_t len) noexcept override;$/;"	m	class:facebook::memcache::McServerSession
override	.\lib\network\McServerSession.h	/^  void readEOF() noexcept override;$/;"	m	class:facebook::memcache::McServerSession
override	.\lib\network\McServerSession.h	/^  void writeSuccess() noexcept override;$/;"	m	class:facebook::memcache::McServerSession
override	.\routes\FailoverWithExptimeRouteIf.cpp	/^void FailoverWithExptimeSettings::OperationSettings::override($/;"	f	class:facebook::memcache::mcrouter::FailoverWithExptimeSettings::OperationSettings
override	.\routes\McExtraRouteHandleProvider.h	/^             folly::StringPiece shadowPolicy) override;$/;"	m	class:facebook::memcache::mcrouter::McExtraRouteHandleProvider
override	.\routes\McRouteHandleProvider.h	/^             std::vector<McrouterRouteHandlePtr> children) override;$/;"	m	class:facebook::memcache::mcrouter::McRouteHandleProvider
override	.\routes\McRouteHandleProvider.h	/^         const std::string& type, const folly::dynamic& json) override;$/;"	m	class:facebook::memcache::mcrouter::McRouteHandleProvider
overrideItems	.\routes\RoutePolicyMap.cpp	/^overrideItems(vector<McrouterRouteHandlePtr> original,$/;"	f	namespace:facebook::memcache::mcrouter
owner_	.\pclient.h	/^  ProxyClientOwner& owner_;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientShared
pagesize	.\lib\fibers\GuardPageAllocator-inl.h	/^size_t pagesize() {$/;"	f	namespace:facebook::memcache::__anon31
paramNames_	.\lib\config\ConfigPreprocessor.cpp	/^  vector<std::pair<string, dynamic>> paramNames_;$/;"	m	class:facebook::memcache::ConfigPreprocessor::Macro	file:
parent	.\lib\network\McServerRequestContext.h	/^  MultiOpParent& parent() const {$/;"	f	class:facebook::memcache::McServerRequestContext
parent_	.\lib\fbi\cpp\Trie.h	/^  Trie* parent_;$/;"	m	class:facebook::memcache::Trie
parent_	.\lib\network\McServerRequestContext.h	/^    std::shared_ptr<MultiOpParent> parent_;$/;"	m	struct:facebook::memcache::McServerRequestContext::AsciiState
parseClusters	.\PoolFactory.cpp	/^int PoolFactory::parseClusters(const dynamic& json) {$/;"	f	class:facebook::memcache::mcrouter::PoolFactory
parseError	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::parseError(McReply errorReply) {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
parseError	.\lib\network\McParser.cpp	/^void McParser::parseError(parser_error_t error) {$/;"	f	class:facebook::memcache::McParser
parseError	.\lib\network\McServerSession.cpp	/^void McServerSession::parseError(McReply reply) {$/;"	f	class:facebook::memcache::McServerSession
parseMigratedPools	.\PoolFactory.cpp	/^int PoolFactory::parseMigratedPools(const dynamic& json, bool is_regional) {$/;"	f	class:facebook::memcache::mcrouter::PoolFactory
parsePool	.\PoolFactory.cpp	/^PoolFactory::parsePool(const string& pool_name_str,$/;"	f	class:facebook::memcache::mcrouter::PoolFactory
parsePool	.\test\cpp_unit_tests\mc_route_handle_provider_test.cpp	/^  parsePool(const std::string& pool_name_str,$/;"	f	class:MockPoolFactory
parsePools	.\PoolFactory.cpp	/^int PoolFactory::parsePools(const dynamic& json, int is_regional) {$/;"	f	class:facebook::memcache::mcrouter::PoolFactory
parse_error	.\lib\mc\parser.h	/^  void (*parse_error)(void *context, parser_error_t error);$/;"	m	struct:parser_s
parse_json_options	.\flavor.cpp	/^bool parse_json_options(const folly::dynamic& json,$/;"	f	namespace:facebook::memcache::mcrouter
parse_options	.\main.cpp	/^static void parse_options(int argc,$/;"	f	file:
parse_protocol	.\PoolFactory.cpp	/^mc_protocol_t parse_protocol(const dynamic& jobj,$/;"	f	namespace:facebook::memcache::mcrouter::__anon49
parse_transport	.\PoolFactory.cpp	/^mc_transport_t parse_transport(const dynamic& jobj,$/;"	f	namespace:facebook::memcache::mcrouter::__anon49
parserMsgReady	.\lib\network\McParser.cpp	/^void McParser::parserMsgReady(void* context,$/;"	f	class:facebook::memcache::McParser
parserParseError	.\lib\network\McParser.cpp	/^void McParser::parserParseError(void* context,$/;"	f	class:facebook::memcache::McParser
parser_	.\lib\network\AsyncMcClientImpl.h	/^  std::unique_ptr<McParser> parser_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
parser_	.\lib\network\McServerSession.h	/^  McParser parser_;$/;"	m	class:facebook::memcache::McServerSession
parser_body	.\lib\mc\parser.h	/^  parser_body,$/;"	e	enum:_parser_state_e
parser_error_e	.\lib\mc\parser.h	/^typedef enum parser_error_e {$/;"	g
parser_error_t	.\lib\mc\parser.h	/^} parser_error_t;$/;"	t	typeref:enum:parser_error_e
parser_error_to_string	.\lib\mc\parser.h	/^static inline const char* parser_error_to_string(const parser_error_t error) {$/;"	f
parser_idle	.\lib\mc\parser.h	/^  parser_idle,$/;"	e	enum:_parser_state_e
parser_malformed_request	.\lib\mc\parser.h	/^  parser_malformed_request,$/;"	e	enum:parser_error_e
parser_msg_header	.\lib\mc\parser.h	/^  parser_msg_header,$/;"	e	enum:_parser_state_e
parser_out_of_memory	.\lib\mc\parser.h	/^  parser_out_of_memory,$/;"	e	enum:parser_error_e
parser_partial	.\lib\mc\parser.h	/^  parser_partial,$/;"	e	enum:_parser_state_e
parser_s	.\lib\mc\parser.h	/^typedef struct parser_s {$/;"	s
parser_state	.\lib\mc\parser.h	/^  _parser_state_t parser_state;$/;"	m	struct:parser_s
parser_state_to_string	.\lib\mc\parser.h	/^static inline const char* parser_state_to_string(const _parser_state_t state) {$/;"	f
parser_type_t	.\lib\mc\parser.h	/^} parser_type_t;$/;"	t	typeref:enum:__anon33
parser_unspecified_error	.\lib\mc\parser.h	/^  parser_unspecified_error = 0,$/;"	e	enum:parser_error_e
partial_token	.\lib\mc\parser.h	/^  int partial_token; \/\/\/ < 1 indicate the parser is in the middle of a token$/;"	m	struct:parser_s
path	.\ConfigApi.h	/^    std::string path;$/;"	m	struct:facebook::memcache::mcrouter::ConfigType::ConfigApi::FileInfo
path	.\async.cpp	/^  std::string path;$/;"	m	struct:facebook::memcache::mcrouter::__anon1::write_file_entry_t	file:
pause	.\lib\network\McServerSession.cpp	/^void McServerSession::pause(PauseReason reason) {$/;"	f	class:facebook::memcache::McServerSession
pause	.\lib\network\McServerSession.h	/^  void pause() {$/;"	f	class:facebook::memcache::McServerSession
pause	.\lib\network\test\SessionTestHarness.h	/^  void pause() {$/;"	f	class:facebook::memcache::SessionTestHarness
pause	.\lib\test\RouteHandleTestUtil.h	/^  void pause() {$/;"	f	struct:facebook::memcache::TestHandle
pause	.\test\MCProcess.py	/^    def pause(self):$/;"	m	class:MCProcess
pausedKeys	.\lib\network\test\SessionTestHarness.h	/^  std::vector<std::string> pausedKeys() {$/;"	f	class:facebook::memcache::SessionTestHarness
pclient_owner	.\_router.h	/^  ProxyClientOwner pclient_owner;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
pclient_shared	.\pclient.h	/^    pclient_shared;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientOwner
pdb	.\test\MCProcess.py	/^import pdb$/;"	i
pdstnKey	.\ProxyDestination.h	/^  const std::string pdstnKey;\/\/\/< consists of ap, server_timeout$/;"	m	struct:facebook::memcache::mcrouter::ProxyDestination
pdstn_	.\DestinationClient.h	/^  std::weak_ptr<ProxyDestination> pdstn_;$/;"	m	class:facebook::memcache::mcrouter::DestinationClient
pdstns	.\pclient.h	/^  std::unordered_set<ProxyDestination*> pdstns;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientShared
peak	.\lib\fbi\timer.h	/^  uint64_t peak;$/;"	m	struct:fb_timer_s
pemCaPath	.\lib\network\AsyncMcServer.h	/^    std::string pemCaPath;$/;"	m	struct:facebook::memcache::AsyncMcServer::Options
pemCaPath	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^  folly::StringPiece pemCaPath;$/;"	m	struct:facebook::memcache::CertPaths	file:
pemCaPath	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^  std::string pemCaPath;$/;"	m	struct:facebook::memcache::ContextInfo	file:
pemCertPath	.\lib\network\AsyncMcServer.h	/^    std::string pemCertPath;$/;"	m	struct:facebook::memcache::AsyncMcServer::Options
pemCertPath	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^  folly::StringPiece pemCertPath;$/;"	m	struct:facebook::memcache::CertPaths	file:
pemCertPath	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^  std::string pemCertPath;$/;"	m	struct:facebook::memcache::ContextInfo	file:
pemKeyPath	.\lib\network\AsyncMcServer.h	/^    std::string pemKeyPath;$/;"	m	struct:facebook::memcache::AsyncMcServer::Options
pemKeyPath	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^  folly::StringPiece pemKeyPath;$/;"	m	struct:facebook::memcache::CertPaths	file:
pemKeyPath	.\lib\network\ThreadLocalSSLContextProvider.cpp	/^  std::string pemKeyPath;$/;"	m	struct:facebook::memcache::ContextInfo	file:
pendingReplyQueue_	.\lib\network\AsyncMcClientImpl.h	/^  ReqInfo::RequestQueue pendingReplyQueue_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
pendingRequests	.\lib\fibers\test\FibersTestApp.cpp	/^  std::queue<FiberPromise<int>> pendingRequests;$/;"	m	struct:Application	file:
pendingWrites_	.\lib\network\McServerSession.h	/^  std::deque<std::pair<McServerRequestContext, McReply>> pendingWrites_;$/;"	m	class:facebook::memcache::McServerSession
performOptionSubstitution	.\mcrouter_config.cpp	/^std::string performOptionSubstitution(std::string str) {$/;"	f	namespace:facebook::memcache::mcrouter
perform_write	.\awriter.h	/^  int (*perform_write)(awriter_entry_t*);$/;"	m	struct:facebook::memcache::mcrouter::awriter_callbacks_t
pick	.\lib\routes\HashRoute.h	/^  size_t pick(const Request& req) const {$/;"	f	class:facebook::memcache::HashRoute
pickInMainContext	.\lib\routes\HashRoute.h	/^  size_t pickInMainContext(const Request& req) const {$/;"	f	class:facebook::memcache::HashRoute
pid	.\_router.h	/^  pid_t pid;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
pid_	.\McrouterLogger.h	/^  pid_t pid_;$/;"	m	class:facebook::memcache::mcrouter::McrouterLogger
pid_	.\awriter.h	/^  const pid_t pid_;$/;"	m	class:facebook::memcache::mcrouter::AsyncWriter
pidfile_fd	.\main.cpp	/^static int pidfile_fd;$/;"	v	file:
ping_thread	.\lib\fbi\test\asox_sem_test.cpp	/^void ping_thread(test_arg_t* test_arg) {$/;"	f	namespace:__anon20
pointer	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  typedef typename std::allocator<T>::pointer pointer;$/;"	t	struct:TestAllocator	file:
pointer	.\stats.h	/^    void* pointer;$/;"	m	union:facebook::memcache::mcrouter::stat_t::__anon63
policies	.\routes\PrefixRouteSelector.h	/^  Trie<std::shared_ptr<McrouterRouteHandleIf>> policies;$/;"	m	class:facebook::memcache::mcrouter::PrefixRouteSelector
pool	.\ProxyClientCommon.h	/^  ProxyPool* pool;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientCommon
poolFactory_	.\ProxyConfig.h	/^  std::shared_ptr<PoolFactory> poolFactory_;$/;"	m	class:facebook::memcache::mcrouter::ProxyConfig
poolFactory_	.\ProxyConfigBuilder.h	/^  std::shared_ptr<PoolFactory> poolFactory_;$/;"	m	class:facebook::memcache::mcrouter::ProxyConfigBuilder
poolFactory_	.\routes\McRouteHandleProvider.h	/^  PoolFactoryIf& poolFactory_;$/;"	m	class:facebook::memcache::mcrouter::McRouteHandleProvider
poolHandles_	.\routes\McRouteHandleProvider.h	/^                     std::vector<McrouterRouteHandlePtr>> poolHandles_;$/;"	m	class:facebook::memcache::mcrouter::McRouteHandleProvider
poolNameToHandles_	.\routes\McRouteHandleProvider.h	/^  std::unordered_map<std::string, McrouterRouteHandlePtr> poolNameToHandles_;$/;"	m	class:facebook::memcache::mcrouter::McRouteHandleProvider
poolName_	.\routes\AsynclogRoute.h	/^  const std::string poolName_;$/;"	m	class:facebook::memcache::mcrouter::AsynclogRoute
pool_	.\Observable.h	/^  CallbackPool<const Data&, const Data&> pool_;$/;"	m	class:facebook::memcache::mcrouter::Observable
pool_failover_policy	.\proxy.h	/^  proxy_pool_failover_policy_t* pool_failover_policy;$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
pools	.\PoolFactory.cpp	/^PoolFactory::pools() const {$/;"	f	class:facebook::memcache::mcrouter::PoolFactory
poolsMap	.\ProxyConfig.h	/^  poolsMap() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyConfig
pools_	.\PoolFactory.h	/^  std::unordered_map<std::string, std::shared_ptr<ProxyGenericPool>> pools_;$/;"	m	class:facebook::memcache::mcrouter::PoolFactory
pop	.\lib\network\WriteBuffer.h	/^  void pop() {$/;"	f	class:facebook::memcache::WriteBufferQueue
popFront	.\lib\network\UniqueIntrusiveList.h	/^  std::unique_ptr<T, TDeleter> popFront() {$/;"	f	class:facebook::memcache::UniqueIntrusiveList
port	.\lib\mc\protocol.h	/^  nstring_t port;$/;"	m	struct:mc_accesspoint_s
port_	.\AccessPoint.h	/^  std::string port_;$/;"	m	struct:facebook::memcache::mcrouter::AccessPoint
port_	.\test\cpp_unit_tests\MemcacheLocal.h	/^  int port_; \/* port that was used to bind the server *\/$/;"	m	class:facebook::memcache::test::MemcacheLocal
ports	.\lib\network\AsyncMcServer.h	/^    std::vector<uint16_t> ports;$/;"	m	struct:facebook::memcache::AsyncMcServer::Options
post	.\lib\fibers\Baton.cpp	/^void Baton::post() {$/;"	f	class:facebook::memcache::Baton
postHelper	.\lib\fibers\Baton.cpp	/^void Baton::postHelper(intptr_t new_value) {$/;"	f	class:facebook::memcache::Baton
postThread	.\lib\fibers\Baton.cpp	/^void Baton::postThread() {$/;"	f	class:facebook::memcache::Baton
precheck_request	.\router.cpp	/^static int precheck_request(mcrouter_queue_entry_t *mcreq) {$/;"	f	namespace:facebook::memcache::mcrouter
preempt	.\lib\fibers\Fiber.cpp	/^intptr_t Fiber::preempt(State state) {$/;"	f	class:facebook::memcache::Fiber
prefix_	.\RoutingPrefix.cpp	/^    : prefix_(other.prefix_) {$/;"	f	namespace:facebook::memcache::mcrouter
prefix_	.\RoutingPrefix.h	/^  std::string prefix_;$/;"	m	class:facebook::memcache::mcrouter::RoutingPrefix
prep	.\lib\mc\umbrella.h	/^  entry_list_msg_preparer_t prep;$/;"	m	struct:um_parser_s
prep_	.\lib\config\ConfigPreprocessor.cpp	/^  const ConfigPreprocessor& prep_;$/;"	m	class:facebook::memcache::ConfigPreprocessor::Const	file:
prepare	.\lib\network\UmbrellaProtocol.cpp	/^bool UmbrellaSerializedReply::prepare(const McReply& reply,$/;"	f	class:facebook::memcache::UmbrellaSerializedReply
prepare	.\lib\network\WriteBuffer.cpp	/^bool AsciiSerializedReply::prepare(const McReply& reply,$/;"	f	class:facebook::memcache::AsciiSerializedReply
prepare	.\lib\network\WriteBuffer.cpp	/^bool WriteBuffer::prepare(McServerRequestContext&& ctx, McReply&& reply,$/;"	f	class:facebook::memcache::WriteBuffer
prepareRand	.\lib\fbi\cpp\test\TrieBenchmarks.cpp	/^static void prepareRand() {$/;"	f	file:
prepareRand	.\lib\fbi\cpp\test\TrieTests.cpp	/^static void prepareRand() {$/;"	f	file:
prepare_proxy_server_stats	.\_router.h	/^  void (*prepare_proxy_server_stats)(proxy_t*);$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
prepare_stats	.\stats.cpp	/^void prepare_stats(mcrouter_t* router, stat_t* stats) {$/;"	f	namespace:facebook::memcache::mcrouter
preprocessArgs	.\test\mcrouter_config.py	/^    def preprocessArgs(args):$/;"	m	class:McrouterGlobals
preprocessGetErrors	.\mcrouter_config.cpp	/^bool preprocessGetErrors(const McrouterOptions& opts, McReplyBase& reply) {$/;"	f	namespace:facebook::memcache::mcrouter
preprocessedConfig	.\ProxyConfigBuilder.cpp	/^folly::dynamic ProxyConfigBuilder::preprocessedConfig() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyConfigBuilder
preq	.\proxy.h	/^  proxy_request_t *preq;$/;"	m	struct:facebook::memcache::mcrouter::writelog_entry_t
preq_	.\ProxyRequestContext.h	/^  proxy_request_t* preq_;$/;"	m	class:facebook::memcache::mcrouter::ProxyRequestContext
prevfile	.\lib\fbi\queue.h	/^        char * prevfile;$/;"	m	struct:qm_trace
prevline	.\lib\fbi\queue.h	/^        int prevline;$/;"	m	struct:qm_trace
print_entry_list	.\lib\mc\umbrella.c	/^void print_entry_list(entry_list_t *elist) {$/;"	f
print_function	.\test\MCProcess.py	/^from __future__ import print_function$/;"	i
print_function	.\test\McrouterTestCase.py	/^from __future__ import print_function$/;"	i
print_function	.\test\mcrouter_config.py	/^from __future__ import print_function$/;"	i
print_function	.\test\mock_servers.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_ascii_error.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_async_files.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_bad_params.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_const_shard_hash.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_empty_pool.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_largeobj.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_logical_routing_policies.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_max_shadow_requests.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_mcrouter.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_mcrouter_basic.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_mcrouter_sanity.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_migrated_failover.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_miss_on_error_arith_ops.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_multiple_ports.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_noreply.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_probe_timeout.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_rates.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_reliable_pool_policy.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_routing_prefixes.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_send_to_all_hosts.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_server_stats.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_service_info.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_shadow.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_shadow_with_file.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_shard_splits.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_slow_box_tko.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_umbrella_server.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_validate_config.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_warmup.py	/^from __future__ import print_function$/;"	i
print_function	.\test\test_wch3.py	/^from __future__ import print_function$/;"	i
print_usage	.\main.cpp	70;"	d	file:
print_usage_and_die	.\main.cpp	/^static void print_usage_and_die(char* progname, int errorCode) {$/;"	f	file:
priority	.\lib\fbi\asox_queue.h	/^  int priority;$/;"	m	struct:asox_queue_entry_s
priority	.\lib\fbi\asox_semaphore.c	/^  int priority;$/;"	m	struct:asox_sem_s	file:
probe_req	.\ProxyDestination.h	/^  McMsgRef probe_req;$/;"	m	struct:facebook::memcache::mcrouter::ProxyDestination
proc	.\test\MCProcess.py	/^    proc = None$/;"	v	class:MCProcess
proc_stat_data_t	.\stats.cpp	/^struct proc_stat_data_t {$/;"	s	namespace:facebook::memcache::mcrouter	file:
process	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic process(ConfigPreprocessor* p,$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
processReply	.\lib\network\test\AsyncMcClientTest.cpp	/^  void processReply(McServerRequestContext&& context, McReply&& reply) {$/;"	f	class:__anon42::ServerOnRequest
processRequest	.\proxy.cpp	/^void proxy_t::processRequest(proxy_request_t* preq) {$/;"	f	class:facebook::memcache::mcrouter::proxy_t
processShutdown	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::processShutdown() {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
process_	.\test\cpp_unit_tests\MemcacheLocal.h	/^  std::unique_ptr<folly::Subprocess> process_;$/;"	m	class:facebook::memcache::test::MemcacheLocal
process_write_file	.\async.cpp	/^static int process_write_file(awriter_entry_t* awe) {$/;"	f	namespace:facebook::memcache::mcrouter
processing_	.\proxy.h	/^  bool processing_;$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t
produce	.\lib\fbi\test\sem_test.cpp	/^void produce(int id, int Y) {$/;"	f
promise	.\lib\fibers\AddTasks.h	/^    folly::Optional<FiberPromise<void>> promise;$/;"	m	struct:facebook::memcache::fiber::TaskIterator::Context
promise	.\routes\DestinationRoute.h	/^  folly::Optional<FiberPromise<void>> promise;$/;"	m	struct:facebook::memcache::mcrouter::DestinationRequestCtx
promise_	.\RecordingContext.h	/^  folly::Optional<FiberPromise<void>> promise_;$/;"	m	class:facebook::memcache::mcrouter::RecordingContext
promise_	.\lib\test\RouteHandleTestUtil.h	/^  folly::Optional<FiberPromise<void>> promise_;$/;"	m	struct:facebook::memcache::TestHandle
protocol	.\lib\mc\protocol.h	/^  mc_protocol_t protocol;$/;"	m	struct:mc_accesspoint_s
protocol	.\lib\network\McParser.h	/^  mc_protocol_t protocol() const {$/;"	f	class:facebook::memcache::McParser
protocol	.\proxy.h	/^  mc_protocol_t protocol;$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
protocol_	.\lib\network\McSerializedRequest.h	/^  mc_protocol_t protocol_;$/;"	m	class:facebook::memcache::McSerializedRequest
protocol_	.\lib\network\WriteBuffer.h	/^  const mc_protocol_t protocol_;$/;"	m	class:facebook::memcache::WriteBuffer
protocol_	.\lib\network\WriteBuffer.h	/^  mc_protocol_t protocol_;$/;"	m	class:facebook::memcache::WriteBufferQueue
provider	.\ConfigApi.h	/^    std::unique_ptr<FileDataProvider> provider;$/;"	m	struct:facebook::memcache::mcrouter::ConfigType::ConfigApi::FileInfo
provider_	.\lib\config\RouteHandleFactory.h	/^  RouteHandleProviderIf<RouteHandleIf>& provider_;$/;"	m	class:facebook::memcache::RouteHandleFactory
proxies_	.\_router.h	/^  std::vector<std::unique_ptr<proxy_t>> proxies_;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
proxy	.\ProxyThread.h	/^  proxy_t& proxy() { return *proxy_; }$/;"	f	class:facebook::memcache::mcrouter::ProxyThread
proxy	.\mcrouter_client.h	/^  proxy_t *proxy;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_t
proxy	.\proxy.h	/^  proxy_t* proxy; \/\/\/< For convenience$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t
proxy	.\router.cpp	/^  proxy_t *proxy;$/;"	m	struct:facebook::memcache::mcrouter::__anon56::mcrouter_queue_entry_t	file:
proxyRequest	.\ProxyRequestContext.h	/^  proxy_request_t& proxyRequest() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyRequestContext
proxyRoute	.\ProxyRequestContext.h	/^  ProxyRoute& proxyRoute() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyRequestContext
proxyRoute_	.\ProxyConfig.h	/^  std::shared_ptr<ProxyRoute> proxyRoute_;$/;"	m	class:facebook::memcache::mcrouter::ProxyConfig
proxyRoute_	.\ServiceInfo.cpp	/^  ProxyRoute& proxyRoute_;$/;"	m	struct:facebook::memcache::mcrouter::ServiceInfo::ServiceInfoImpl	file:
proxyThreadRun	.\ProxyThread.cpp	/^void ProxyThread::proxyThreadRun() {$/;"	f	class:facebook::memcache::mcrouter::ProxyThread
proxyThreadRunHandler	.\ProxyThread.cpp	/^void *ProxyThread::proxyThreadRunHandler(void *arg) {$/;"	f	class:facebook::memcache::mcrouter::ProxyThread
proxyThreads_	.\_router.h	/^  std::vector<std::unique_ptr<ProxyThread>> proxyThreads_;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
proxy_	.\DestinationClient.h	/^  proxy_t* proxy_;$/;"	m	class:facebook::memcache::mcrouter::DestinationClient
proxy_	.\ProxyDestinationMap.h	/^  proxy_t* proxy_;$/;"	m	class:facebook::memcache::mcrouter::ProxyDestinationMap
proxy_	.\ProxyRequestLogger.h	/^  proxy_t* proxy_;$/;"	m	class:facebook::memcache::mcrouter::ProxyRequestLogger
proxy_	.\ProxyThread.h	/^  std::unique_ptr<proxy_t> proxy_;$/;"	m	class:facebook::memcache::mcrouter::ProxyThread
proxy_	.\ServiceInfo.cpp	/^  proxy_t* proxy_;$/;"	m	struct:facebook::memcache::mcrouter::ServiceInfo::ServiceInfoImpl	file:
proxy_	.\routes\McRouteHandleProvider.h	/^  proxy_t* proxy_;$/;"	m	class:facebook::memcache::mcrouter::McRouteHandleProvider
proxy_	.\routes\ProxyRoute.h	/^  proxy_t* proxy_;$/;"	m	class:facebook::memcache::mcrouter::ProxyRoute
proxy_client_key	.\ProxyClientCommon.h	/^  std::string proxy_client_key;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientCommon
proxy_client_state_t	.\ProxyDestination.h	/^enum proxy_client_state_t {$/;"	g	namespace:facebook::memcache::mcrouter
proxy_config_swap	.\proxy.cpp	/^static void proxy_config_swap(proxy_t* proxy,$/;"	f	namespace:facebook::memcache::mcrouter
proxy_hash_ch2	.\proxy.h	/^  proxy_hash_ch2 = 1,$/;"	e	enum:facebook::memcache::mcrouter::proxy_hash_policy_t
proxy_hash_ch3	.\proxy.h	/^  proxy_hash_ch3 = 2,$/;"	e	enum:facebook::memcache::mcrouter::proxy_hash_policy_t
proxy_hash_const_shard	.\proxy.h	/^  proxy_hash_const_shard = 4,$/;"	e	enum:facebook::memcache::mcrouter::proxy_hash_policy_t
proxy_hash_crc32	.\proxy.h	/^  proxy_hash_crc32 = 0,$/;"	e	enum:facebook::memcache::mcrouter::proxy_hash_policy_t
proxy_hash_latest	.\proxy.h	/^  proxy_hash_latest = 3,$/;"	e	enum:facebook::memcache::mcrouter::proxy_hash_policy_t
proxy_hash_policy_t	.\proxy.h	/^enum proxy_hash_policy_t {$/;"	g	namespace:facebook::memcache::mcrouter
proxy_hash_unknown	.\proxy.h	/^  proxy_hash_unknown = 6,$/;"	e	enum:facebook::memcache::mcrouter::proxy_hash_policy_t
proxy_hash_wch3	.\proxy.h	/^  proxy_hash_wch3 = 5,$/;"	e	enum:facebook::memcache::mcrouter::proxy_hash_policy_t
proxy_on_continue_reply_error	.\proxy.cpp	/^void proxy_on_continue_reply_error(proxy_t* proxy, writelog_entry_t* e) {$/;"	f	namespace:facebook::memcache::mcrouter
proxy_pool_failover_policy_t	.\proxy.cpp	/^proxy_pool_failover_policy_t::proxy_pool_failover_policy_t() {$/;"	f	class:facebook::memcache::mcrouter::proxy_pool_failover_policy_t
proxy_pool_failover_policy_t	.\proxy.h	/^struct proxy_pool_failover_policy_t {$/;"	s	namespace:facebook::memcache::mcrouter
proxy_pool_failover_t	.\proxy.h	/^enum proxy_pool_failover_t {$/;"	g	namespace:facebook::memcache::mcrouter
proxy_pool_failover_type_t	.\proxy.h	/^enum proxy_pool_failover_type_t {$/;"	g	namespace:facebook::memcache::mcrouter
proxy_pool_shadowing_policy_t	.\proxy.cpp	/^proxy_pool_shadowing_policy_t::proxy_pool_shadowing_policy_t($/;"	f	class:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t
proxy_pool_shadowing_policy_t	.\proxy.h	/^struct proxy_pool_shadowing_policy_t {$/;"	s	namespace:facebook::memcache::mcrouter
proxy_pool_type_t	.\proxy.h	/^enum proxy_pool_type_t {$/;"	g	namespace:facebook::memcache::mcrouter
proxy_request_decref	.\proxy.cpp	/^void proxy_request_decref(proxy_request_t* preq) {$/;"	f	namespace:facebook::memcache::mcrouter
proxy_request_incref	.\proxy.cpp	/^proxy_request_t* proxy_request_incref(proxy_request_t* preq) {$/;"	f	namespace:facebook::memcache::mcrouter
proxy_request_queue_cb	.\proxy.cpp	/^static asox_queue_callbacks_t const proxy_request_queue_cb =  {$/;"	m	namespace:facebook::memcache::mcrouter	file:
proxy_request_t	.\proxy.cpp	/^proxy_request_t::proxy_request_t(proxy_t* p,$/;"	f	class:facebook::memcache::mcrouter::proxy_request_t
proxy_request_t	.\proxy.h	/^struct proxy_request_t {$/;"	s	namespace:facebook::memcache::mcrouter
proxy_send_stat_result_t	.\route.h	/^enum proxy_send_stat_result_t {$/;"	g	namespace:facebook::memcache::mcrouter
proxy_t	.\proxy.cpp	/^proxy_t::proxy_t(mcrouter_t *router_,$/;"	f	class:facebook::memcache::mcrouter::proxy_t
proxy_t	.\proxy.h	/^struct proxy_t {$/;"	s	namespace:facebook::memcache::mcrouter
ptr	.\lib\mc\umbrella.h	/^  const void *ptr;    \/\/ Where does the string actually live?$/;"	m	struct:extern_string_s
pump	.\proxy.cpp	/^void proxy_t::pump() {$/;"	f	class:facebook::memcache::mcrouter::proxy_t
push	.\lib\network\WriteBuffer.h	/^  WriteBuffer& push() {$/;"	f	class:facebook::memcache::WriteBufferQueue
push	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^  void push(std::pair<mc_msg_t*, McReply> &&msg) {$/;"	f	class:facebook::memcache::test::ResultsSet
pushBack	.\lib\network\UniqueIntrusiveList.h	/^  T& pushBack(std::unique_ptr<T, TDeleter> t) {$/;"	f	class:facebook::memcache::UniqueIntrusiveList
pushMessages	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::pushMessages() {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
q	.\lib\fbi\test\asox_queue_test.cpp	/^  asox_queue_t q;$/;"	m	struct:__anon19::Info	file:
q_opt_masks	.\lib\mc\umbrella_protocol.c	/^uint64_t const q_opt_masks[] = QMASKS;$/;"	v
q_req_masks	.\lib\mc\umbrella_protocol.c	/^uint64_t const q_req_masks[] = QMASKS;$/;"	v
qentry	.\proxy.h	/^  asox_queue_entry_t qentry;$/;"	m	struct:facebook::memcache::mcrouter::writelog_entry_t
qm_trace	.\lib\fbi\queue.h	/^struct qm_trace {$/;"	s
queue	.\lib\fbi\log_limit.c	/^static struct timeval *queue = NULL;$/;"	v	typeref:struct:timeval	file:
queueLock_	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^  SFRLock queueLock_;$/;"	m	class:facebook::memcache::test::ResultsSet	file:
queueWrite	.\lib\network\McServerSession.cpp	/^void McServerSession::queueWrite(McServerRequestContext&& ctx,$/;"	f	class:facebook::memcache::McServerSession
queue_	.\lib\network\WriteBuffer.h	/^  WriteBuffer::Queue queue_;$/;"	m	class:facebook::memcache::WriteBufferQueue
queue_callbacks	.\lib\fbi\test\asox_queue_test.cpp	/^asox_queue_callbacks_t queue_callbacks = {my_elem_ready, nullptr};$/;"	m	namespace:__anon16	file:
queue_on_signal	.\lib\fbi\asox_queue.c	/^static bool queue_on_signal(asox_sem_t sem, uint64_t n, void *arg) {$/;"	f	file:
queue_test_common	.\lib\fbi\test\asox_queue_test.cpp	/^void queue_test_common(int num_rounds, int increment, int mode) {$/;"	f	namespace:__anon16
queue_thread	.\lib\fbi\test\asox_queue_test.cpp	/^void queue_thread(thread_arg_t *thread_arg) {$/;"	f	namespace:__anon16
queue_value	.\lib\fbi\test\asox_queue_test.cpp	/^std::atomic<int> queue_value;$/;"	m	namespace:__anon16	file:
queues	.\lib\fbi\test\asox_queue_test.cpp	/^asox_queue_t queues[NUM_THREADS];$/;"	m	namespace:__anon16	file:
r_opt_masks	.\lib\mc\umbrella_protocol.c	/^uint64_t const r_opt_masks[] = RMASKS;$/;"	v
r_req_masks	.\lib\mc\umbrella_protocol.c	/^uint64_t const r_req_masks[] = RMASKS;$/;"	v
ragel_start_state	.\lib\mc\parser.h	/^  int ragel_start_state;$/;"	m	struct:parser_s
ragel_state	.\lib\mc\parser.h	/^  int ragel_state;$/;"	m	struct:parser_s
raise_fdlimit	.\main.cpp	/^static void raise_fdlimit() {$/;"	f	file:
randSuffix	.\routes\BigValueRoute-inl.h	/^uint32_t BigValueRoute<RouteHandleIf>::ChunksInfo::randSuffix() const {$/;"	f	class:facebook::memcache::BigValueRoute::ChunksInfo
randSuffix_	.\routes\BigValueRoute.h	/^    uint32_t randSuffix_;$/;"	m	class:facebook::memcache::BigValueRoute::ChunksInfo
randTrie	.\lib\fbi\cpp\test\TrieBenchmarks.cpp	/^static Trie<long> randTrie;$/;"	v	file:
randTrie	.\lib\fbi\cpp\test\TrieTests.cpp	/^static Trie<int> randTrie;$/;"	v	file:
rand_in_range	.\lib\fbi\test\hash_test.cpp	/^int rand_in_range(int low, int high) {$/;"	f	namespace:__anon22
random	.\test\MCProcess.py	/^import random$/;"	i
random	.\test\test_mcrouter_sanity.py	/^import random$/;"	i
randomGenerator	.\proxy.h	/^  std::mt19937 randomGenerator;$/;"	m	struct:facebook::memcache::mcrouter::proxy_t
randomInt64	.\lib\fbi\cpp\util.h	/^randomInt64(RNG& rng) {$/;"	f	namespace:facebook::memcache
randomString	.\lib\fbi\cpp\util.cpp	/^std::string randomString(size_t minLen, size_t maxLen,$/;"	f	namespace:facebook::memcache
random_	.\test\cpp_unit_tests\MemcacheLocal.h	/^  std::mt19937 random_;$/;"	m	class:facebook::memcache::test::MemcacheLocal
randstring	.\test\test_mcrouter_sanity.py	/^def randstring(n):$/;"	f
rangeMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic rangeMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
rateLimited	.\proxy.cpp	/^bool proxy_t::rateLimited(const proxy_request_t* preq) const {$/;"	f	class:facebook::memcache::mcrouter::proxy_t
rate_	.\AtomicTokenBucket.h	/^  const double rate_;$/;"	m	class:facebook::memcache::mcrouter::AtomicTokenBucket
rate_	.\TokenBucket.h	/^  double rate_;$/;"	m	class:facebook::memcache::mcrouter::TokenBucket
rate_limiter	.\proxy.h	/^  std::unique_ptr<RateLimiter> rate_limiter;$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
rate_stat_to_str	.\stats.cpp	/^static std::string rate_stat_to_str(proxy_t * proxy, int idx) {$/;"	f	namespace:facebook::memcache::mcrouter
rate_stats	.\stats.h	/^  rate_stats           =      0x100,$/;"	e	enum:facebook::memcache::mcrouter::stat_group_t
ratelimit	.\lib\fbi\debug.c	/^static int ratelimit(struct msg_info *info, timeval_t *now, int same_loc,$/;"	f	file:
re	.\test\MCProcess.py	/^import re$/;"	i
re	.\test\test_bad_params.py	/^import re$/;"	i
readBuffer_	.\lib\network\McParser.h	/^  folly::IOBuf readBuffer_;$/;"	m	class:facebook::memcache::McParser
readDataAvailable	.\lib\network\McParser.cpp	/^bool McParser::readDataAvailable(size_t len) {$/;"	f	class:facebook::memcache::McParser
readLock	.\lib\fbi\cpp\sfrlock.h	/^  SFRReadLock& readLock() {$/;"	f	class:SFRLock
readLock_	.\lib\fbi\cpp\sfrlock.h	/^  SFRReadLock readLock_;$/;"	m	class:SFRLock
readUmbrellaData	.\lib\network\McParser.cpp	/^bool McParser::readUmbrellaData() {$/;"	f	class:facebook::memcache::McParser
read_	.\lib\network\test\SessionTestHarness.h	/^  apache::thrift::async::TAsyncTransport::ReadCallback* read_;$/;"	m	class:facebook::memcache::SessionTestHarness
read_and_fill_from_standalone_flavor_file	.\flavor.cpp	/^bool read_and_fill_from_standalone_flavor_file($/;"	f	namespace:facebook::memcache::mcrouter
read_fd	.\lib\fbi\asox_semaphore.c	/^  int read_fd;$/;"	m	struct:asox_sem_s	file:
read_standalone_flavor	.\mcrouter_config.cpp	/^bool read_standalone_flavor($/;"	f	namespace:facebook::memcache::mcrouter
readyFibers_	.\lib\fibers\FiberManager.h	/^  FiberTailQHead readyFibers_;  \/**< queue of fibers ready to be executed *\/$/;"	m	class:facebook::memcache::FiberManager
readyFunc_	.\lib\fibers\Fiber.h	/^  std::function<void()> readyFunc_; \/**< function to be executed before jumping$/;"	m	class:facebook::memcache::Fiber
rec	.\lib\fbi\skiplist.h	/^  const void* rec;$/;"	m	struct:skiplist_node_s
recalculateBufferSize	.\lib\network\McParser.cpp	/^void McParser::recalculateBufferSize(size_t read) {$/;"	f	class:facebook::memcache::McParser
receive_reply_unknown_state	.\lib\mc\parser.h	/^  receive_reply_unknown_state = 0,$/;"	e	enum:_parser_state_e
receive_reply_vheader	.\lib\mc\parser.h	/^  receive_reply_vheader,$/;"	e	enum:_parser_state_e
receive_sync_reply_header	.\lib\mc\parser.h	/^  receive_sync_reply_header,$/;"	e	enum:_parser_state_e
reconnectTest	.\lib\network\test\AsyncMcClientTest.cpp	/^void reconnectTest(mc_protocol_t protocol) {$/;"	f
recordDestination	.\RecordingContext.cpp	/^void RecordingContext::recordDestination(const ProxyClientCommon& destination) {$/;"	f	class:facebook::memcache::mcrouter::RecordingContext
recordEnd	.\lib\network\MultiOpParent.cpp	/^void MultiOpParent::recordEnd(uint64_t reqid) {$/;"	f	class:facebook::memcache::MultiOpParent
recordHardFailure	.\TkoTracker.cpp	/^bool TkoTracker::recordHardFailure(ProxyDestination* pdstn) {$/;"	f	class:facebook::memcache::mcrouter::TkoTracker
recordRequest	.\lib\network\MultiOpParent.h	/^  void recordRequest() {$/;"	f	class:facebook::memcache::MultiOpParent
recordSoftFailure	.\TkoTracker.cpp	/^bool TkoTracker::recordSoftFailure(ProxyDestination* pdstn) {$/;"	f	class:facebook::memcache::mcrouter::TkoTracker
recordStackPosition	.\lib\fibers\Fiber.cpp	/^void Fiber::recordStackPosition() {$/;"	f	class:facebook::memcache::Fiber
recordSuccess	.\TkoTracker.cpp	/^void TkoTracker::recordSuccess(ProxyDestination* pdstn) {$/;"	f	class:facebook::memcache::mcrouter::TkoTracker
record_skip_key	.\lib\mc\parser.h	/^  bool record_skip_key;$/;"	m	struct:parser_s
redir	.\lib\fbi\test\log_tid_tests.cpp	/^static FILE* redir;$/;"	v	file:
reduce	.\lib\McReplyBase-inl.h	/^InputIterator McReplyBase::reduce(InputIterator begin, InputIterator end) {$/;"	f	class:facebook::memcache::McReplyBase
reduce	.\test\test_wch3.py	/^from functools import reduce$/;"	i
ref_	.\lib\McMsgRef.h	/^  : ref_(from.ref_) {$/;"	f	class:facebook::memcache::Ref
ref_	.\lib\McMsgRef.h	/^  T* ref_;$/;"	m	class:facebook::memcache::Ref
region	.\PoolFactory.h	/^    std::string region;$/;"	m	struct:facebook::memcache::mcrouter::PoolFactory::Options
region_	.\RoutingPrefix.h	/^  folly::StringPiece region_;$/;"	m	class:facebook::memcache::mcrouter::RoutingPrefix
registerOnUpdateCallback	.\proxy.cpp	/^void proxy_pool_shadowing_policy_t::registerOnUpdateCallback($/;"	f	class:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t
registerTimeout	.\lib\fibers\TimeoutController.cpp	/^void TimeoutController::registerTimeout(TimeoutHandle& th, Duration duration) {$/;"	f	class:facebook::memcache::TimeoutController
registered	.\lib\fbi\timer.h	/^  int registered;$/;"	m	struct:fb_timer_s
release	.\lib\McMsgRef.h	/^  T* release() {$/;"	f	class:facebook::memcache::Ref
release	.\lib\network\MultiOpParent.cpp	/^void MultiOpParent::release() {$/;"	f	class:facebook::memcache::MultiOpParent
releasedMsg	.\lib\McReplyBase.cpp	/^McMsgRef McReplyBase::releasedMsg(mc_op_t op) const {$/;"	f	class:facebook::memcache::McReplyBase
remoteReadyInsert	.\lib\fibers\FiberManager.cpp	/^void FiberManager::remoteReadyInsert(Fiber* fiber) {$/;"	f	class:facebook::memcache::FiberManager
remoteReadyQueue_	.\lib\fibers\FiberManager.h	/^  AtomicLinkedList<Fiber, &Fiber::nextRemoteReady_> remoteReadyQueue_;$/;"	m	class:facebook::memcache::FiberManager
remoteScheduleCalled	.\lib\fibers\SimpleLoopController.h	/^  int remoteScheduleCalled() const {$/;"	f	class:facebook::memcache::SimpleLoopController
remoteTaskQueue_	.\lib\fibers\FiberManager.h	/^  AtomicLinkedList<RemoteTask, &RemoteTask::nextRemoteTask> remoteTaskQueue_;$/;"	m	class:facebook::memcache::FiberManager
removeAllUnused	.\ProxyDestinationMap.cpp	/^void ProxyDestinationMap::removeAllUnused() {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestinationMap
repeat	.\lib\fbi\test\cwlock_test.cpp	/^const unsigned repeat = 1000000U;$/;"	v
repeat	.\lib\fbi\test\sfrlock_test.cpp	/^const unsigned repeat = 1000000U;$/;"	v
repeated	.\lib\fbi\debug.c	/^  int repeated;$/;"	m	struct:msg_info	file:
replace	.\lib\network\test\MockMc.cpp	/^bool MockMc::replace(folly::StringPiece key, Item item) {$/;"	f	class:facebook::memcache::MockMc
replace	.\test\MCProcess.py	/^    def replace(self, key, value, replicate=False, noreply=False):$/;"	m	class:MCProcess
replaceParams	.\lib\config\ConfigPreprocessor.cpp	/^dynamic ConfigPreprocessor::replaceParams(StringPiece str,$/;"	f	class:facebook::memcache::ConfigPreprocessor
replace_ports	.\test\MCProcess.py	/^def replace_ports(json, substitute_ports):$/;"	f
replace_strings	.\test\MCProcess.py	/^def replace_strings(json, replace_map):$/;"	f
replies_	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^  std::queue<std::pair<mc_msg_t*, McReply>> replies_;$/;"	m	class:facebook::memcache::test::ResultsSet	file:
reply	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::reply(ReqInfo::UniquePtr req, McReply mcReply) {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
reply	.\lib\network\McServerRequestContext.cpp	/^void McServerRequestContext::reply($/;"	f	class:facebook::memcache::McServerRequestContext
reply	.\lib\network\McServerSession.cpp	/^void McServerSession::reply(McServerRequestContext&& ctx, McReply&& reply) {$/;"	f	class:facebook::memcache::McServerSession
reply	.\lib\network\MultiOpParent.cpp	/^bool MultiOpParent::reply(McReply&& r) {$/;"	f	class:facebook::memcache::MultiOpParent
reply	.\lib\network\test\SessionTestHarness.h	/^    McReply reply;$/;"	m	struct:facebook::memcache::SessionTestHarness::Transaction
reply	.\proxy.h	/^  McReply reply; \/**< The reply that has been sent out for this request *\/$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t
reply	.\routes\DestinationRoute.h	/^  McReply reply;$/;"	m	struct:facebook::memcache::mcrouter::DestinationRequestCtx
replyCallback	.\lib\network\AsyncMcClientImpl.h	/^    std::function<void(McReply&&)> replyCallback;$/;"	m	class:facebook::memcache::AsyncMcClientImpl::ReqInfo
replyFor	.\lib\test\RouteHandleTestUtil.h	/^std::string replyFor(Rh& rh, const std::string& key) {$/;"	f	namespace:facebook::memcache
replyReady	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::replyReady(McReply mcReply, mc_op_t operation,$/;"	f	class:facebook::memcache::AsyncMcClientImpl
replyReadyHelper	.\lib\network\McParser.cpp	/^void McParser::replyReadyHelper(McReply reply,$/;"	f	class:facebook::memcache::McParser
replyReceived	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::replyReceived(uint64_t id, McReply mcReply) {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
reply_	.\lib\network\MultiOpParent.h	/^  folly::Optional<McReply> reply_;$/;"	m	class:facebook::memcache::MultiOpParent
reply_	.\lib\network\WriteBuffer.h	/^  folly::Optional<McReply> reply_;$/;"	m	class:facebook::memcache::WriteBuffer
reply_parser	.\lib\mc\parser.h	/^  reply_parser,$/;"	e	enum:__anon33
reply_received	.\lib\mc\parser.h	/^  reply_received,$/;"	e	enum:_parser_state_e
reply_state	.\proxy.h	/^  reply_state_t reply_state;$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t
reply_state_t	.\proxy.h	/^enum reply_state_t {$/;"	g	namespace:facebook::memcache::mcrouter
req	.\lib\network\test\SessionTestHarness.h	/^    McRequest req;$/;"	m	struct:facebook::memcache::SessionTestHarness::Transaction
req	.\router.h	/^  mc_msg_t* req;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_msg_t
reqComplete_	.\proxy.h	/^  void (*reqComplete_)(proxy_request_t* preq);$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t
reqContext	.\lib\network\AsyncMcClientImpl.h	/^    McSerializedRequest reqContext;$/;"	m	class:facebook::memcache::AsyncMcClientImpl::ReqInfo
reqid	.\lib\mc\umbrella_protocol.c	/^  uint64_t reqid;$/;"	m	struct:_parse_info_s	file:
reqid_	.\lib\network\McServerRequestContext.h	/^  uint64_t reqid_;$/;"	m	class:facebook::memcache::McServerRequestContext
request	.\router.cpp	/^  mc_msg_t* request;$/;"	m	struct:facebook::memcache::mcrouter::__anon56::mcrouter_queue_entry_t	file:
requestReady	.\lib\network\McServerRequestContext-inl.h	/^void McServerOnRequestWrapper<OnRequest>::requestReady($/;"	f	class:facebook::memcache::McServerOnRequestWrapper
requestReady	.\lib\network\McServerSession.cpp	/^void McServerSession::requestReady(McRequest&& req,$/;"	f	class:facebook::memcache::McServerSession
requestReadyHelper	.\lib\network\McParser.cpp	/^void McParser::requestReadyHelper(McRequest&& req,$/;"	f	class:facebook::memcache::McParser
request_entry_type_t	.\_router.h	/^enum request_entry_type_t {$/;"	g	namespace:facebook::memcache::mcrouter
request_parser	.\lib\mc\parser.h	/^  request_parser,$/;"	e	enum:__anon33
request_reply_parser	.\lib\mc\parser.h	/^  request_reply_parser, \/\/\/< Useful for network sniffing$/;"	e	enum:__anon33
request_type_continue_reply_error	.\_router.h	/^  request_type_continue_reply_error,$/;"	e	enum:facebook::memcache::mcrouter::request_entry_type_t
request_type_disconnect	.\_router.h	/^  request_type_disconnect,$/;"	e	enum:facebook::memcache::mcrouter::request_entry_type_t
request_type_old_config	.\_router.h	/^  request_type_old_config,$/;"	e	enum:facebook::memcache::mcrouter::request_entry_type_t
request_type_request	.\_router.h	/^  request_type_request,$/;"	e	enum:facebook::memcache::mcrouter::request_entry_type_t
request_type_router_shutdown	.\_router.h	/^  request_type_router_shutdown,$/;"	e	enum:facebook::memcache::mcrouter::request_entry_type_t
requestedName	.\options.h	/^  std::string requestedName;$/;"	m	struct:facebook::memcache::McrouterOptionError
requestedValue	.\options.h	/^  std::string requestedValue;$/;"	m	struct:facebook::memcache::McrouterOptionError
requester	.\proxy.h	/^  struct mcrouter_client_t *requester;$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t	typeref:struct:facebook::memcache::mcrouter::proxy_request_t::mcrouter_client_t
reset	.\test\cpp_unit_tests\awriter_test.cpp	/^  void reset() {$/;"	f	class:AtomicCounter
reset	.\test\cpp_unit_tests\awriter_test.cpp	/^  void reset() {$/;"	f	struct:counts
resetAllInactive	.\ProxyDestinationMap.cpp	/^void ProxyDestinationMap::resetAllInactive() {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestinationMap
resetInactive	.\DestinationClient.cpp	/^void DestinationClient::resetInactive() {$/;"	f	class:facebook::memcache::mcrouter::DestinationClient
resetInactive	.\ProxyDestination.cpp	/^void ProxyDestination::resetInactive() {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
resetTimer_	.\ProxyDestinationMap.h	/^  asox_timer_t resetTimer_;$/;"	m	class:facebook::memcache::mcrouter::ProxyDestinationMap
reset_fields	.\ProxyDestination.cpp	/^void ProxyDestination::reset_fields() {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
resid	.\lib\mc\parser.h	/^  size_t resid;$/;"	m	struct:parser_s
result	.\TkoLog.h	/^  mc_res_t result;$/;"	m	struct:facebook::memcache::mcrouter::TkoLog
result	.\lib\McReplyBase.h	/^  mc_res_t result() const {$/;"	f	class:facebook::memcache::McReplyBase
result	.\lib\mc\msg.h	/^  mc_res_t result;$/;"	m	struct:mc_msg_s
resultFunc_	.\lib\fibers\Fiber.h	/^  std::function<void()> resultFunc_;$/;"	m	class:facebook::memcache::Fiber
result_	.\lib\config\ConfigPreprocessor.cpp	/^  mutable dynamic result_;$/;"	m	class:facebook::memcache::ConfigPreprocessor::Const	file:
result_	.\lib\fibers\FiberManager-inl.h	/^    folly::Optional<folly::wangle::Try<Result>> result_;$/;"	m	class:facebook::memcache::FiberManager::AddTaskFinallyHelper::Finally
result_	.\lib\fibers\FiberManager-inl.h	/^    folly::Optional<folly::wangle::Try<Result>>& result_;$/;"	m	class:facebook::memcache::FiberManager::AddTaskFinallyHelper::Func
result_	.\lib\network\McSerializedRequest.h	/^  Result result_;$/;"	m	class:facebook::memcache::McSerializedRequest
result_	.\lib\test\RouteHandleTestUtil.h	/^  mc_res_t result_;$/;"	m	struct:facebook::memcache::DeleteRouteTestData
result_	.\lib\test\RouteHandleTestUtil.h	/^  mc_res_t result_;$/;"	m	struct:facebook::memcache::GetRouteTestData
result_	.\lib\test\RouteHandleTestUtil.h	/^  mc_res_t result_;$/;"	m	struct:facebook::memcache::UpdateRouteTestData
results	.\ProxyDestination.h	/^  uint64_t results[mc_nres] = {0};$/;"	m	struct:facebook::memcache::mcrouter::ProxyDestinationStats
results	.\lib\fibers\AddTasks.h	/^    std::queue<std::pair<size_t, folly::wangle::Try<T>>> results;$/;"	m	struct:facebook::memcache::fiber::TaskIterator::Context
results	.\stats.cpp	/^  uint64_t results[mc_nres] = {0};$/;"	m	struct:facebook::memcache::mcrouter::__anon62::ServerStat	file:
resume	.\lib\network\McServerSession.cpp	/^void McServerSession::resume(PauseReason reason) {$/;"	f	class:facebook::memcache::McServerSession
resume	.\lib\network\McServerSession.h	/^  void resume() {$/;"	f	class:facebook::memcache::McServerSession
resume	.\lib\network\test\SessionTestHarness.h	/^  void resume() {$/;"	f	class:facebook::memcache::SessionTestHarness
resume	.\lib\network\test\SessionTestHarness.h	/^  void resume(size_t n) {$/;"	f	class:facebook::memcache::SessionTestHarness
resume	.\test\MCProcess.py	/^    def resume(self):$/;"	m	class:MCProcess
reverse	.\lib\fbi\cpp\AtomicLinkedList.h	/^  static T* reverse(T* head) {$/;"	f	class:facebook::memcache::AtomicLinkedList
rh	.\lib\test\RouteHandleTestUtil.h	/^  std::shared_ptr<RecordingRouteHandle> rh;$/;"	m	struct:facebook::memcache::TestHandle
rhMap_	.\routes\RootRoute.h	/^  RouteHandleMap rhMap_;$/;"	m	class:facebook::memcache::mcrouter::RootRoute
rh_	.\lib\routes\HashRoute.h	/^  const std::vector<std::shared_ptr<RouteHandleIf>> rh_;$/;"	m	class:facebook::memcache::HashRoute
rh_	.\routes\AsynclogRoute.h	/^  const std::shared_ptr<RouteHandleIf> rh_;$/;"	m	class:facebook::memcache::mcrouter::AsynclogRoute
rh_	.\routes\ShardSplitRoute.h	/^  std::shared_ptr<RouteHandleIf> rh_;$/;"	m	class:facebook::memcache::mcrouter::ShardSplitRoute
rhs_	.\routes\ReliablePoolRoute.h	/^  const std::vector<std::shared_ptr<HashRoute<RouteHandleIf, HashFunc>>> rhs_;$/;"	m	class:facebook::memcache::mcrouter::ReliablePoolRoute
rl_	.\routes\RateLimitRoute.h	/^  RateLimiter rl_;$/;"	m	class:facebook::memcache::mcrouter::RateLimitRoute
root_	.\routes\ProxyRoute.h	/^  McrouterRouteHandlePtr root_;$/;"	m	class:facebook::memcache::mcrouter::ProxyRoute
round_up	.\lib\network\AsyncMcClientImpl.cpp	/^T round_up(std::chrono::duration<Rep, Period> d) {$/;"	f	namespace:facebook::memcache::__anon37
route	.\lib\RouteHandleIf.h	/^  route(const Request& req, typename OpList::template Item<op_id>::op) {$/;"	f	class:facebook::memcache::RouteHandle
route	.\lib\routes\AllAsyncRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::AllAsyncRoute
route	.\lib\routes\AllFastestRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::AllFastestRoute
route	.\lib\routes\AllInitialRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::AllInitialRoute
route	.\lib\routes\AllMajorityRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::AllMajorityRoute
route	.\lib\routes\AllSyncRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::AllSyncRoute
route	.\lib\routes\ErrorRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	struct:facebook::memcache::ErrorRoute
route	.\lib\routes\FailoverRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::FailoverRoute
route	.\lib\routes\HashRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::HashRoute
route	.\lib\routes\HostIdRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::HostIdRoute
route	.\lib\routes\LatestRoute.h	/^  typename ReplyType<Operation, Request>::type route(const Request& req,$/;"	f	class:facebook::memcache::LatestRoute
route	.\lib\routes\MigrateRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::MigrateRoute
route	.\lib\routes\MissFailoverRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::MissFailoverRoute
route	.\lib\routes\NullRoute.h	/^  static typename ReplyType<Operation, Request>::type route($/;"	f	struct:facebook::memcache::NullRoute
route	.\lib\routes\WarmUpRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::WarmUpRoute
route	.\lib\test\RouteHandleTestUtil.h	/^  typename ReplyType<McOperation<M>, Request>::type route($/;"	f	struct:facebook::memcache::RecordingRoute
route	.\routes\AsynclogRoute.h	/^  ProxyMcReply route($/;"	f	class:facebook::memcache::mcrouter::AsynclogRoute
route	.\routes\AsynclogRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::mcrouter::AsynclogRoute
route	.\routes\BigValueRoute-inl.h	/^BigValueRoute<RouteHandleIf>::route($/;"	f	class:facebook::memcache::BigValueRoute
route	.\routes\BigValueRoute-inl.h	/^BigValueRoute<RouteHandleIf>::route(const Request& req,$/;"	f	class:facebook::memcache::BigValueRoute
route	.\routes\DestinationRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::mcrouter::DestinationRoute
route	.\routes\DevNullRoute.h	/^  static ProxyMcReply route(const ProxyMcRequest& req, Operation) {$/;"	f	class:facebook::memcache::mcrouter::DevNullRoute
route	.\routes\DevNullRoute.h	/^  static typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::mcrouter::DevNullRoute
route	.\routes\FailoverWithExptimeRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::mcrouter::FailoverWithExptimeRoute
route	.\routes\PrefixPolicyRoute.h	/^  typename ReplyType<McOperation<M>, Request>::type route($/;"	f	class:facebook::memcache::mcrouter::PrefixPolicyRoute
route	.\routes\ProxyRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::mcrouter::ProxyRoute
route	.\routes\RateLimitRoute.h	/^  typename ReplyType<Operation, Request>::type route(const Request& req,$/;"	f	class:facebook::memcache::mcrouter::RateLimitRoute
route	.\routes\ReliablePoolRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::mcrouter::ReliablePoolRoute
route	.\routes\RootRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::mcrouter::RootRoute
route	.\routes\ShadowRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::mcrouter::ShadowRoute
route	.\routes\ShardSplitRoute.h	/^  typename ReplyType<Operation, Request>::type route($/;"	f	class:facebook::memcache::mcrouter::ShardSplitRoute
routeCommandHelper	.\ServiceInfo.cpp	/^void ServiceInfo::ServiceInfoImpl::routeCommandHelper($/;"	f	class:facebook::memcache::mcrouter::ServiceInfo::ServiceInfoImpl
routeHandlesCommandHelper	.\ServiceInfo.cpp	/^inline std::string routeHandlesCommandHelper($/;"	f	namespace:facebook::memcache::mcrouter
routeHandlesProcessRequest	.\proxy.cpp	/^void proxy_t::routeHandlesProcessRequest(proxy_request_t* preq) {$/;"	f	class:facebook::memcache::mcrouter::proxy_t
routeImpl	.\lib\routes\MissFailoverRoute.h	/^  typename ReplyType<Operation, Request>::type routeImpl($/;"	f	class:facebook::memcache::MissFailoverRoute
routeImpl	.\routes\DestinationRoute.h	/^  McReply routeImpl(const RecordingMcRequest& req, Operation) const {$/;"	f	class:facebook::memcache::mcrouter::DestinationRoute
routeImpl	.\routes\DestinationRoute.h	/^  ProxyMcReply routeImpl(const ProxyMcRequest& req, Operation) const {$/;"	f	class:facebook::memcache::mcrouter::DestinationRoute
routeImpl	.\routes\FailoverWithExptimeRoute.h	/^  ProxyMcReply routeImpl($/;"	f	class:facebook::memcache::mcrouter::FailoverWithExptimeRoute
routeImpl	.\routes\FailoverWithExptimeRoute.h	/^  typename ReplyType<Operation, Request>::type routeImpl($/;"	f	class:facebook::memcache::mcrouter::FailoverWithExptimeRoute
routeImpl	.\routes\RootRoute.h	/^  typename ReplyType<Operation, Request>::type routeImpl($/;"	f	class:facebook::memcache::mcrouter::RootRoute
routeMask	.\lib\routes\MigrateRoute.h	/^  int routeMask($/;"	f	class:facebook::memcache::MigrateRoute
routeName	.\lib\RouteHandleIf.h	/^  std::string routeName() const {$/;"	f	class:facebook::memcache::RouteHandle
routeName	.\lib\routes\AllAsyncRoute.h	/^  static std::string routeName() { return "all-async"; }$/;"	f	class:facebook::memcache::AllAsyncRoute
routeName	.\lib\routes\AllFastestRoute.h	/^  static std::string routeName() { return "all-fastest"; }$/;"	f	class:facebook::memcache::AllFastestRoute
routeName	.\lib\routes\AllInitialRoute.h	/^  static std::string routeName() { return "all-initial"; }$/;"	f	class:facebook::memcache::AllInitialRoute
routeName	.\lib\routes\AllMajorityRoute.h	/^  static std::string routeName() { return "all-majority"; }$/;"	f	class:facebook::memcache::AllMajorityRoute
routeName	.\lib\routes\AllSyncRoute.h	/^  static std::string routeName() { return "all-sync"; }$/;"	f	class:facebook::memcache::AllSyncRoute
routeName	.\lib\routes\ErrorRoute.h	/^  static std::string routeName() {$/;"	f	struct:facebook::memcache::ErrorRoute
routeName	.\lib\routes\FailoverRoute.h	/^  static std::string routeName() { return "failover"; }$/;"	f	class:facebook::memcache::FailoverRoute
routeName	.\lib\routes\HashRoute.h	/^  static std::string routeName() { return "hash"; }$/;"	f	class:facebook::memcache::HashRoute
routeName	.\lib\routes\HostIdRoute.h	/^  static std::string routeName() { return "hostid"; }$/;"	f	class:facebook::memcache::HostIdRoute
routeName	.\lib\routes\LatestRoute.h	/^  static std::string routeName() { return "latest"; }$/;"	f	class:facebook::memcache::LatestRoute
routeName	.\lib\routes\MigrateRoute.h	/^  static std::string routeName() { return "migrate"; }$/;"	f	class:facebook::memcache::MigrateRoute
routeName	.\lib\routes\MissFailoverRoute.h	/^  static std::string routeName() { return "miss-failover"; }$/;"	f	class:facebook::memcache::MissFailoverRoute
routeName	.\lib\routes\NullRoute.h	/^  static std::string routeName() {$/;"	f	struct:facebook::memcache::NullRoute
routeName	.\lib\routes\WarmUpRoute.h	/^  static std::string routeName() { return "warm-up"; }$/;"	f	class:facebook::memcache::WarmUpRoute
routeName	.\lib\test\RouteHandleTestUtil.h	/^  static std::string routeName() { return "test"; }$/;"	f	struct:facebook::memcache::RecordingRoute
routeName	.\routes\AsynclogRoute.h	/^  static std::string routeName() { return "asynclog"; }$/;"	f	class:facebook::memcache::mcrouter::AsynclogRoute
routeName	.\routes\BigValueRoute.h	/^  static std::string routeName() { return "big-value"; }$/;"	f	class:facebook::memcache::BigValueRoute
routeName	.\routes\DestinationRoute.h	/^  std::string routeName() const {$/;"	f	class:facebook::memcache::mcrouter::DestinationRoute
routeName	.\routes\DevNullRoute.h	/^  static std::string routeName() { return "devnull"; }$/;"	f	class:facebook::memcache::mcrouter::DevNullRoute
routeName	.\routes\FailoverWithExptimeRoute.h	/^  static std::string routeName() { return "failover-exptime"; }$/;"	f	class:facebook::memcache::mcrouter::FailoverWithExptimeRoute
routeName	.\routes\PrefixPolicyRoute.h	/^  static std::string routeName() { return "prefix-policy"; }$/;"	f	class:facebook::memcache::mcrouter::PrefixPolicyRoute
routeName	.\routes\ProxyRoute.h	/^  static std::string routeName() { return "proxy"; }$/;"	f	class:facebook::memcache::mcrouter::ProxyRoute
routeName	.\routes\RateLimitRoute.h	/^  static std::string routeName() { return "rate-limit"; }$/;"	f	class:facebook::memcache::mcrouter::RateLimitRoute
routeName	.\routes\ReliablePoolRoute.h	/^  static std::string routeName() { return "reliable-pool"; }$/;"	f	class:facebook::memcache::mcrouter::ReliablePoolRoute
routeName	.\routes\RootRoute.h	/^  static std::string routeName() { return "root"; }$/;"	f	class:facebook::memcache::mcrouter::RootRoute
routeName	.\routes\ShadowRoute.h	/^  static std::string routeName() { return "shadow"; }$/;"	f	class:facebook::memcache::mcrouter::ShadowRoute
routeName	.\routes\ShardSplitRoute.h	/^  static std::string routeName() { return "shard-split"; }$/;"	f	class:facebook::memcache::mcrouter::ShardSplitRoute
route_	.\lib\RouteHandleIf.h	/^  Route route_;$/;"	m	class:facebook::memcache::RouteHandle
route_	.\lib\routes\LatestRoute.h	/^  FailoverRoute<RouteHandleIf> route_;$/;"	m	class:facebook::memcache::LatestRoute
router	.\mcrouter_client.h	/^  mcrouter_t *router;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_t
routerName	.\router.cpp	/^std::string mcrouter_t::routerName() const {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
router_	.\McrouterLogger.h	/^  mcrouter_t* router_;$/;"	m	class:facebook::memcache::mcrouter::McrouterLogger
router_	.\test\cpp_unit_tests\mcrouter_test_client.h	/^  facebook::memcache::mcrouter::mcrouter_t *router_;$/;"	m	class:facebook::memcache::test::MCRouterTestClient
router_client	.\router.cpp	/^  mcrouter_client_t *router_client;$/;"	m	struct:facebook::memcache::mcrouter::__anon56::mcrouter_queue_entry_t	file:
router_client_on_reply	.\router.cpp	/^static inline void router_client_on_reply(mcrouter_client_t *client,$/;"	f	namespace:facebook::memcache::mcrouter
router_configure	.\proxy.cpp	/^int router_configure(mcrouter_t *router) {$/;"	f	namespace:facebook::memcache::mcrouter
router_configure	.\proxy.cpp	/^int router_configure(mcrouter_t* router, folly::StringPiece input) {$/;"	f	namespace:facebook::memcache::mcrouter
router_configure_from_string	.\mcrouter_config.cpp	/^int router_configure_from_string(mcrouter_t* router, folly::StringPiece input) {$/;"	f	namespace:facebook::memcache::mcrouter
router_entry_destroy	.\router.cpp	/^void router_entry_destroy(mcrouter_queue_entry_t *router_entry) {$/;"	f	namespace:facebook::memcache::mcrouter
router_on_reply	.\server.cpp	/^void router_on_reply(mcrouter_client_t *client,$/;"	f	namespace:facebook::memcache::mcrouter::__anon60
routingKey	.\lib\McRequestBase.h	/^    folly::StringPiece routingKey;$/;"	m	struct:facebook::memcache::McRequestBase::Keys
routingKey	.\lib\McRequestBase.h	/^  folly::StringPiece routingKey() const {$/;"	f	class:facebook::memcache::McRequestBase
routingKeyHash	.\lib\McRequestBase.h	/^    uint32_t routingKeyHash;$/;"	m	struct:facebook::memcache::McRequestBase::Keys
routingKeyHash	.\lib\McRequestBase.h	/^  uint32_t routingKeyHash() const {$/;"	f	class:facebook::memcache::McRequestBase
routingPrefix	.\lib\McRequestBase.h	/^    folly::StringPiece routingPrefix;$/;"	m	struct:facebook::memcache::McRequestBase::Keys
routingPrefix	.\lib\McRequestBase.h	/^  folly::StringPiece routingPrefix() const {$/;"	f	class:facebook::memcache::McRequestBase
routing_prefix	.\options.h	/^    routing_prefix,$/;"	m	class:facebook::memcache::McrouterOptionData::Type
rs_	.\test\cpp_unit_tests\mcrouter_test_client.h	/^  ResultsSet *rs_;$/;"	m	class:facebook::memcache::test::MCRouterTestClient
rss	.\stats.cpp	/^  unsigned long rss;$/;"	m	struct:facebook::memcache::mcrouter::proc_stat_data_t	file:
rtVarsData	.\_router.h	/^  ObservableRuntimeVars rtVarsData;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
run	.\async.cpp	/^bool AsyncWriter::run(std::function<void()> f) {$/;"	f	class:facebook::memcache::mcrouter::AsyncWriter
run	.\lib\network\test\AsyncMcClientTest.cpp	/^  bool run() {$/;"	f	class:__anon42::TestServer
run	.\lib\test\RouteHandleTestUtil.h	/^  void run(std::function<void()>&& fun) {$/;"	f	class:facebook::memcache::TestFiberManager
run	.\test\mock_servers.py	/^    def run(self):$/;"	m	class:MockServer
runAll	.\lib\test\RouteHandleTestUtil.h	/^  void runAll(std::vector<std::function<void()>>&& fs) {$/;"	f	class:facebook::memcache::TestFiberManager
runBenchmark	.\lib\fibers\test\FibersTest.cpp	/^void runBenchmark(size_t numAwaits, size_t toSend) {$/;"	f
runCase	.\lib\config\test\config_preprocessor_test.cpp	/^void runCase(const folly::dynamic& consts,$/;"	f
runInMainContext	.\lib\fibers\FiberManager-inl.h	/^FiberManager::runInMainContext(F&& func) {$/;"	f	class:facebook::memcache::FiberManager
runInMainContext	.\lib\fibers\FiberManager.h	/^inline runInMainContext(F&& func) {$/;"	f	class:facebook::memcache::fiber::std::result_of
runInMainContextHelper	.\lib\fibers\FiberManager-inl.h	/^FiberManager::runInMainContextHelper(F&& func) {$/;"	f	class:facebook::memcache::FiberManager
runLock_	.\awriter.h	/^  SFRLock runLock_;$/;"	m	class:facebook::memcache::mcrouter::AsyncWriter
runLoop	.\lib\fibers\EventBaseLoopController-inl.h	/^inline void EventBaseLoopController::runLoop() {$/;"	f	class:facebook::memcache::mcrouter::EventBaseLoopController
runReadyFiber	.\lib\fibers\FiberManager-inl.h	/^inline void FiberManager::runReadyFiber(Fiber* fiber) {$/;"	f	class:facebook::memcache::FiberManager
runServer	.\server.cpp	/^void runServer(const McrouterStandaloneOptions& standaloneOpts,$/;"	f	namespace:facebook::memcache::mcrouter
runServer	.\test\mock_servers.py	/^    def runServer(self, client_socket, client_address):$/;"	m	class:SleepServer
runServer	.\test\mock_servers.py	/^    def runServer(self, client_socket, client_address):$/;"	m	class:StoreServer
runServer	.\test\test_ascii_error.py	/^    def runServer(self, client_socket, client_address):$/;"	m	class:ErrorServer
runServer	.\test\test_max_shadow_requests.py	/^    def runServer(self, client_socket, client_address):$/;"	m	class:TimeoutServer
runServer	.\test\test_slow_box_tko.py	/^    def runServer(self, client_socket, client_address):$/;"	m	class:FailoverServer
runServer	.\test\test_slow_box_tko.py	/^    def runServer(self, client_socket, client_address):$/;"	m	class:TkoServer
runServer	.\test\test_wch3.py	/^    def runServer(self, client_socket, client_address):$/;"	m	class:EchoServer
runTest	.\lib\config\test\config_preprocessor_test.cpp	/^void runTest(const std::string& testName, const folly::dynamic& testObj) {$/;"	f
runTimeouts	.\lib\fibers\TimeoutController.cpp	/^void TimeoutController::runTimeouts(TimePoint time) {$/;"	f	class:facebook::memcache::TimeoutController
run_client	.\test\test_mcrouter_basic.py	/^        def run_client():$/;"	f	function:TestMcrouterBasic.test_stats_deadlock
run_test	.\lib\fbi\test\counter_test.cpp	/^static int run_test(int num_counters, int num_threads, int steps,$/;"	f	file:
run_test_body	.\lib\fbi\test\counter_test.cpp	/^static void* run_test_body(void *arg) {$/;"	f	file:
running	.\McrouterLogger.cpp	/^bool McrouterLogger::running() const {$/;"	f	class:facebook::memcache::mcrouter::McrouterLogger
rxpriority	.\ProxyClientCommon.h	/^  int rxpriority;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientCommon
sNumAwaits	.\lib\fibers\test\FibersTest.cpp	/^static size_t sNumAwaits;$/;"	v	file:
salt_	.\lib\routes\HashRoute.h	/^  std::string salt_;$/;"	m	class:facebook::memcache::HashRoute
sameMemoryRegion	.\lib\fbi\cpp\util.h	/^inline bool sameMemoryRegion(folly::StringPiece a, folly::StringPiece b) {$/;"	f	namespace:facebook::memcache
savedInputs_	.\lib\network\test\SessionTestHarness.h	/^  std::deque<std::string> savedInputs_;$/;"	m	class:facebook::memcache::SessionTestHarness
saved_request	.\proxy.h	/^  folly::Optional<McRequest> saved_request;$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t
saved_request	.\router.cpp	/^  folly::Optional<McRequest> saved_request;$/;"	m	struct:facebook::memcache::mcrouter::__anon56::mcrouter_queue_entry_t	file:
saved_request	.\router.h	/^  folly::Optional<McRequest> saved_request;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_msg_t
sawExptimes	.\lib\test\RouteHandleTestUtil.h	/^  std::vector<uint32_t> sawExptimes;$/;"	m	struct:facebook::memcache::TestHandle
sawOperations	.\lib\test\RouteHandleTestUtil.h	/^  std::vector<mc_op_t> sawOperations;$/;"	m	struct:facebook::memcache::TestHandle
sawValues	.\lib\test\RouteHandleTestUtil.h	/^  std::vector<std::string> sawValues;$/;"	m	struct:facebook::memcache::TestHandle
saw_keys	.\lib\test\RouteHandleTestUtil.h	/^  std::vector<std::string> saw_keys;$/;"	m	struct:facebook::memcache::TestHandle
schedule	.\lib\fibers\EventBaseLoopController-inl.h	/^inline void EventBaseLoopController::schedule() {$/;"	f	class:facebook::memcache::mcrouter::EventBaseLoopController
scheduleNextTimeout	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::scheduleNextTimeout() {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
scheduleNextWriterLoop	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::scheduleNextWriterLoop() {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
scheduleRun	.\lib\fibers\TimeoutController.cpp	/^void TimeoutController::scheduleRun() {$/;"	f	class:facebook::memcache::TimeoutController
scheduleTask	.\PeriodicTaskScheduler.cpp	/^void PeriodicTaskScheduler::scheduleTask($/;"	f	class:facebook::memcache::mcrouter::PeriodicTaskScheduler
scheduleThreadSafe	.\lib\fibers\EventBaseLoopController-inl.h	/^inline void EventBaseLoopController::scheduleThreadSafe() {$/;"	f	class:facebook::memcache::mcrouter::EventBaseLoopController
schedule_next_probe	.\ProxyDestination.cpp	/^void ProxyDestination::schedule_next_probe() {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
scheduledFuncs_	.\lib\fibers\SimpleLoopController.h	/^  std::vector<std::pair<TimePoint, std::function<void()>>> scheduledFuncs_;$/;"	m	class:facebook::memcache::SimpleLoopController
schedulerThreadRun	.\PeriodicTaskScheduler.cpp	/^void PeriodicTaskScheduler::schedulerThreadRun(TaskThread& task) {$/;"	f	class:facebook::memcache::mcrouter::PeriodicTaskScheduler
seen_	.\lib\config\RouteHandleFactory.h	/^                     std::vector<std::shared_ptr<RouteHandleIf>>> seen_;$/;"	m	class:facebook::memcache::RouteHandleFactory
select	.\test\MCProcess.py	/^import select$/;"	i
selectMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic selectMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
selfPtr_	.\ProxyDestination.h	/^  std::weak_ptr<ProxyDestination> selfPtr_;$/;"	m	struct:facebook::memcache::mcrouter::ProxyDestination
selfPtr_	.\lib\network\AsyncMcClientImpl.h	/^  std::weak_ptr<AsyncMcClientImpl> selfPtr_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
sem	.\lib\fbi\asox_queue.c	/^  asox_sem_t sem;$/;"	m	struct:asox_queue_s	file:
sem	.\lib\fbi\test\sem_test.cpp	/^static counting_sem_t sem;$/;"	v	file:
sem_test_common	.\lib\fbi\test\asox_sem_test.cpp	/^void sem_test_common(asox_sem_flags_t flags, int increment, int num_rounds) {$/;"	f	namespace:__anon20
sems	.\lib\fbi\test\asox_sem_test.cpp	/^asox_sem_t sems[NUM_THREADS];$/;"	m	namespace:__anon20	file:
send	.\DestinationClient.cpp	/^int DestinationClient::send(McMsgRef requestMsg, void* req_ctx,$/;"	f	class:facebook::memcache::mcrouter::DestinationClient
send	.\ProxyDestination.cpp	/^int ProxyDestination::send(McMsgRef request, void* req_ctx,$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
send	.\lib\network\AsyncMcClient-inl.h	/^void AsyncMcClient::send(const McRequest& request, Operation,$/;"	f	class:facebook::memcache::AsyncMcClient
send	.\lib\network\AsyncMcClientImpl-inl.h	/^void AsyncMcClientImpl::send(const McRequest& request, McOperation<Op>,$/;"	f	class:facebook::memcache::AsyncMcClientImpl
sendFakeReply	.\ProxyDestination.cpp	/^void ProxyDestination::sendFakeReply(const McMsgRef& request, void* req_ctx) {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
sendGet	.\lib\network\test\AsyncMcClientTest.cpp	/^  void sendGet(const char* key, mc_res_t expectedResult) {$/;"	f	class:__anon42::TestClient
sendInvalidRouteToDefault_	.\routes\RouteHandleMap.h	/^  bool sendInvalidRouteToDefault_;$/;"	m	class:facebook::memcache::mcrouter::RouteHandleMap
sendMessage	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^int MemcacheLocal::sendMessage(const int sockfd, const string& message) const {$/;"	f	class:facebook::memcache::test::MemcacheLocal
sendQueue_	.\lib\network\AsyncMcClientImpl.h	/^  ReqInfo::RequestQueue sendQueue_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
sendReply	.\proxy.cpp	/^void proxy_request_t::sendReply(McReply newReply) {$/;"	f	class:facebook::memcache::mcrouter::proxy_request_t
sendRequest	.\DestinationClient.cpp	/^void sendRequest($/;"	f	namespace:facebook::memcache::mcrouter::__anon2
sendSet	.\lib\network\test\AsyncMcClientTest.cpp	/^  void sendSet(const char* key, const char* value, mc_res_t expectedResult) {$/;"	f	class:__anon42::TestClient
sendWrites	.\lib\network\McServerSession.cpp	/^void McServerSession::sendWrites() {$/;"	f	class:facebook::memcache::McServerSession
sendWritesCallback_	.\lib\network\McServerSession.h	/^  SendWritesCallback sendWritesCallback_;$/;"	m	class:facebook::memcache::McServerSession
senderId	.\ProxyRequestContext.cpp	/^uint64_t ProxyRequestContext::senderId() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyRequestContext
sender_id	.\proxy.h	/^  uint64_t sender_id;$/;"	m	struct:facebook::memcache::mcrouter::proxy_request_t
sentAt	.\lib\network\AsyncMcClientImpl.h	/^    std::chrono::steady_clock::time_point sentAt;$/;"	m	class:facebook::memcache::AsyncMcClientImpl::ReqInfo
serializationResult	.\lib\network\McSerializedRequest.cpp	/^McSerializedRequest::Result McSerializedRequest::serializationResult() const {$/;"	f	class:facebook::memcache::McSerializedRequest
serializeMcMsgAscii	.\lib\network\McSerializedRequest.cpp	/^void McSerializedRequest::serializeMcMsgAscii(const McMsgRef& req) {$/;"	f	class:facebook::memcache::McSerializedRequest
serializeMcMsgUmbrella	.\lib\network\McSerializedRequest.cpp	/^void McSerializedRequest::serializeMcMsgUmbrella(const McMsgRef& req,$/;"	f	class:facebook::memcache::McSerializedRequest
serverLoop	.\lib\network\test\MockMcServer.cpp	/^void serverLoop(size_t threadId, folly::EventBase& evb,$/;"	f
serverLoop	.\server.cpp	/^void serverLoop($/;"	f	namespace:facebook::memcache::mcrouter::__anon60
serverParseCallback_	.\lib\network\McParser.h	/^    ServerParseCallback* serverParseCallback_;$/;"	m	union:facebook::memcache::McParser::__anon40
serverShutdownTest	.\lib\network\test\AsyncMcClientTest.cpp	/^void serverShutdownTest(bool useSsl = false) {$/;"	f
server_	.\lib\network\AsyncMcServer.cpp	/^  AsyncMcServer& server_;$/;"	m	class:facebook::memcache::McServerThread	file:
server_	.\lib\network\AsyncMcServer.cpp	/^  AsyncMcServer& server_;$/;"	m	class:facebook::memcache::ShutdownPipe	file:
server_	.\lib\network\test\AsyncMcClientTest.cpp	/^  std::unique_ptr<AsyncMcServer> server_;$/;"	m	class:__anon42::TestServer	file:
server_callbacks	.\server.cpp	/^mcrouter_client_callbacks_t const server_callbacks = {$/;"	m	namespace:facebook::memcache::mcrouter::__anon60	file:
server_stats	.\stats.h	/^  server_stats         =    0x10000,$/;"	e	enum:facebook::memcache::mcrouter::stat_group_t
server_timeout	.\ProxyClientCommon.h	/^  timeval_t server_timeout;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientCommon
serviceInfo	.\ProxyConfig.h	/^  std::shared_ptr<ServiceInfo> serviceInfo() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyConfig
serviceInfo_	.\ProxyConfig.h	/^  std::shared_ptr<ServiceInfo> serviceInfo_;$/;"	m	class:facebook::memcache::mcrouter::ProxyConfig
session	.\lib\network\McServerRequestContext.cpp	/^McServerSession& McServerRequestContext::session() {$/;"	f	class:facebook::memcache::McServerRequestContext
session_	.\lib\network\McServerRequestContext.h	/^  McServerSession* session_;$/;"	m	class:facebook::memcache::McServerRequestContext
session_	.\lib\network\McServerSession.h	/^    McServerSession& session_;$/;"	m	struct:facebook::memcache::McServerSession::SendWritesCallback
session_	.\lib\network\MultiOpParent.h	/^  McServerSession& session_;$/;"	m	class:facebook::memcache::MultiOpParent
session_	.\lib\network\test\SessionTestHarness.h	/^  McServerSession& session_;$/;"	m	class:facebook::memcache::SessionTestHarness
sessions_	.\lib\network\AsyncMcServerWorker.h	/^  McServerSession::Queue sessions_;$/;"	m	class:facebook::memcache::AsyncMcServerWorker
set	.\Observable-inl.h	/^void Observable<Data>::set(Data data) {$/;"	f	class:facebook::memcache::mcrouter::Observable
set	.\lib\fbi\cpp\AtomicSharedPtr.h	/^  void set(T data) {$/;"	f	class:facebook::memcache::AtomicWrapper
set	.\lib\network\test\MockMc.cpp	/^void MockMc::set(folly::StringPiece key, Item item) {$/;"	f	class:facebook::memcache::MockMc
set	.\test\MCProcess.py	/^    def set(self, key, value, replicate=False, noreply=False):$/;"	m	class:MCProcess
set	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^int MCRouterTestClient::set(const dynamic &kv_pairs,$/;"	f	class:MCRouterTestClient
setAppSpecificErrorCode	.\lib\McReplyBase.h	/^  void setAppSpecificErrorCode(uint32_t ecode) {$/;"	f	class:facebook::memcache::McReplyBase
setCas	.\lib\McReplyBase.h	/^  void setCas(uint64_t c) {$/;"	f	class:facebook::memcache::McReplyBase
setCas	.\lib\McRequestBase.h	/^  void setCas(uint64_t c) {$/;"	f	class:facebook::memcache::McRequestBase
setData	.\lib\fibers\Fiber.cpp	/^void Fiber::setData(intptr_t data) {$/;"	f	class:facebook::memcache::Fiber
setDelta	.\lib\McReplyBase.h	/^  void setDelta(uint64_t d) {$/;"	f	class:facebook::memcache::McReplyBase
setDelta	.\lib\McRequestBase.h	/^  void setDelta(uint64_t d) {$/;"	f	class:facebook::memcache::McRequestBase
setDestination	.\ProxyMcReply.cpp	/^void ProxyMcReply::setDestination($/;"	f	class:facebook::memcache::mcrouter::ProxyMcReply
setException	.\lib\fibers\FiberPromise-inl.h	/^void FiberPromise<T>::setException(std::exception_ptr e) {$/;"	f	class:facebook::memcache::FiberPromise
setExceptionCallback	.\lib\fibers\FiberManager.cpp	/^void FiberManager::setExceptionCallback(FiberManager::ExceptionCallback ec) {$/;"	f	class:facebook::memcache::FiberManager
setExptime	.\lib\McRequestBase.h	/^  void setExptime(uint32_t expt) {$/;"	f	class:facebook::memcache::McRequestBase
setFbtraceInfo	.\lib\McRequestBase.h	/^  void setFbtraceInfo(mc_fbtrace_info_s* info) {$/;"	f	class:facebook::memcache::McRequestBase
setFiberManager	.\lib\fibers\EventBaseLoopController-inl.h	/^inline void EventBaseLoopController::setFiberManager(FiberManager* fm) {$/;"	f	class:facebook::memcache::mcrouter::EventBaseLoopController
setFlags	.\lib\McReplyBase.h	/^  void setFlags(uint64_t fl) {$/;"	f	class:facebook::memcache::McReplyBase
setFlags	.\lib\McRequestBase.h	/^  void setFlags(uint64_t f) {$/;"	f	class:facebook::memcache::McRequestBase
setFunction	.\lib\fibers\Fiber-inl.h	/^void Fiber::setFunction(F&& func) {$/;"	f	class:facebook::memcache::Fiber
setFunctionFinally	.\lib\fibers\Fiber-inl.h	/^void Fiber::setFunctionFinally(F&& resultFunc,$/;"	f	class:facebook::memcache::Fiber
setKey	.\lib\McRequestBase.h	/^  void setKey(folly::IOBuf keyData) {$/;"	f	class:facebook::memcache::McRequestBase
setKey	.\lib\McRequestBase.h	/^  void setKey(folly::StringPiece k) {$/;"	f	class:facebook::memcache::McRequestBase
setKeyFrom	.\lib\McRequestBase.cpp	/^bool McRequestBase::setKeyFrom(const folly::IOBuf& source,$/;"	f	class:facebook::memcache::McRequestBase
setLeaseToken	.\lib\McReplyBase.h	/^  void setLeaseToken(uint64_t lt) {$/;"	f	class:facebook::memcache::McReplyBase
setLeaseToken	.\lib\McRequestBase.h	/^  void setLeaseToken(uint64_t lt) {$/;"	f	class:facebook::memcache::McRequestBase
setOnConnectionAccepted	.\lib\network\AsyncMcServerWorker.h	/^  void setOnConnectionAccepted(std::function<void()> cb) {$/;"	f	class:facebook::memcache::AsyncMcServerWorker
setOnConnectionClosed	.\lib\network\AsyncMcServerWorker.h	/^  void setOnConnectionClosed(std::function<void(McServerSession&)> cb) {$/;"	f	class:facebook::memcache::AsyncMcServerWorker
setOnRequest	.\lib\network\AsyncMcServerWorker.h	/^  void setOnRequest(OnRequest onRequest) {$/;"	f	class:facebook::memcache::AsyncMcServerWorker
setOnShutdownOperation	.\lib\network\AsyncMcServerWorker.h	/^  void setOnShutdownOperation(std::function<void()> cb) {$/;"	f	class:facebook::memcache::AsyncMcServerWorker
setOnWriteQuiescence	.\lib\network\AsyncMcServerWorker.h	/^  void setOnWriteQuiescence(std::function<void(McServerSession&)> cb) {$/;"	f	class:facebook::memcache::AsyncMcServerWorker
setReadCallback	.\lib\network\test\SessionTestHarness.h	/^  void setReadCallback($/;"	f	class:facebook::memcache::SessionTestHarness
setReadyFunction	.\lib\fibers\Fiber-inl.h	/^void Fiber::setReadyFunction(G&& func) {$/;"	f	class:facebook::memcache::Fiber
setRequestClass	.\ProxyMcRequest.h	/^  void setRequestClass(RequestClass type) {$/;"	f	class:facebook::memcache::mcrouter::ProxyMcRequest
setResetTimer	.\ProxyDestinationMap.cpp	/^void ProxyDestinationMap::setResetTimer(std::chrono::milliseconds interval) {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestinationMap
setResult	.\lib\McReplyBase.cpp	/^void McReplyBase::setResult(mc_res_t res) {$/;"	f	class:facebook::memcache::McReplyBase
setServiceContext	.\lib\fbi\cpp\LogFailure.cpp	/^void setServiceContext(folly::StringPiece service, std::string context) {$/;"	f	namespace:facebook::memcache::failure
setStatusCallbacks	.\lib\network\AsyncMcClient-inl.h	/^inline void AsyncMcClient::setStatusCallbacks($/;"	f	class:facebook::memcache::AsyncMcClient
setStatusCallbacks	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::setStatusCallbacks($/;"	f	class:facebook::memcache::AsyncMcClientImpl
setSumFailures	.\TkoTracker.cpp	/^bool TkoTracker::setSumFailures(uintptr_t value) {$/;"	f	class:facebook::memcache::mcrouter::TkoTracker
setThrottle	.\lib\network\AsyncMcClient-inl.h	/^inline void AsyncMcClient::setThrottle(size_t maxInflight, size_t maxPending) {$/;"	f	class:facebook::memcache::AsyncMcClient
setThrottle	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::setThrottle(size_t maxInflight, size_t maxPending) {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
setThrottle	.\lib\network\test\AsyncMcClientTest.cpp	/^  void setThrottle(size_t maxInflight, size_t maxOutstanding) {$/;"	f	class:__anon42::TestClient
setTko	.\lib\test\RouteHandleTestUtil.h	/^  void setTko() {$/;"	f	struct:facebook::memcache::TestHandle
setUp	.\test\test_ascii_error.py	/^    def setUp(self):$/;"	m	class:TestAsciiError
setUp	.\test\test_async_files.py	/^    def setUp(self):$/;"	m	class:TestAsyncFiles
setUp	.\test\test_bad_params.py	/^    def setUp(self):$/;"	m	class:OutputCheckerTestCase
setUp	.\test\test_largeobj.py	/^    def setUp(self):$/;"	m	class:TestLargeObj
setUp	.\test\test_logical_routing_policies.py	/^    def setUp(self):$/;"	m	class:TestLogicalRoutingPolicies
setUp	.\test\test_max_shadow_requests.py	/^    def setUp(self):$/;"	m	class:TestServerStatsOutstandingRequests
setUp	.\test\test_mcrouter.py	/^    def setUp(self):$/;"	m	class:TestDevNull
setUp	.\test\test_mcrouter.py	/^    def setUp(self):$/;"	m	class:TestDuplicateServers
setUp	.\test\test_mcrouter.py	/^    def setUp(self):$/;"	m	class:TestDuplicateServersDiffTimeouts
setUp	.\test\test_mcrouter.py	/^    def setUp(self):$/;"	m	class:TestGetFailover
setUp	.\test\test_mcrouter.py	/^    def setUp(self):$/;"	m	class:TestLeaseGetFailover
setUp	.\test\test_mcrouter.py	/^    def setUp(self):$/;"	m	class:TestMetaGetFailover
setUp	.\test\test_mcrouter.py	/^    def setUp(self):$/;"	m	class:TestMigratedPools
setUp	.\test\test_mcrouter.py	/^    def setUp(self):$/;"	m	class:TestMigratedPoolsFailover
setUp	.\test\test_mcrouter.py	/^    def setUp(self):$/;"	m	class:TestSamePoolFailover
setUp	.\test\test_mcrouter.py	/^    def setUp(self):$/;"	m	class:TestServerListFromAnotherPool
setUp	.\test\test_mcrouter_basic.py	/^    def setUp(self):$/;"	m	class:TestBasicAllFirst
setUp	.\test\test_mcrouter_basic.py	/^    def setUp(self):$/;"	m	class:TestBasicAllMajority
setUp	.\test\test_mcrouter_basic.py	/^    def setUp(self):$/;"	m	class:TestBasicAllSync
setUp	.\test\test_mcrouter_basic.py	/^    def setUp(self):$/;"	m	class:TestBasicFailover
setUp	.\test\test_mcrouter_basic.py	/^    def setUp(self):$/;"	m	class:TestBasicFailoverOverride
setUp	.\test\test_mcrouter_basic.py	/^    def setUp(self):$/;"	m	class:TestMcrouterBasic
setUp	.\test\test_mcrouter_basic.py	/^    def setUp(self):$/;"	m	class:TestMcrouterBasic2
setUp	.\test\test_mcrouter_basic.py	/^    def setUp(self):$/;"	m	class:TestMcrouterBasicL1L2
setUp	.\test\test_mcrouter_basic.py	/^    def setUp(self):$/;"	m	class:TestMcrouterInvalidRoute
setUp	.\test\test_mcrouter_sanity.py	/^    def setUp(self):$/;"	m	class:TestMcrouterSanity
setUp	.\test\test_miss_on_error_arith_ops.py	/^    def setUp(self):$/;"	m	class:TestMissOnErrorArithOps
setUp	.\test\test_noreply.py	/^    def setUp(self):$/;"	m	class:TestNoreply
setUp	.\test\test_probe_timeout.py	/^    def setUp(self):$/;"	m	class:TestProbeTimeout
setUp	.\test\test_rates.py	/^    def setUp(self):$/;"	m	class:TestRates
setUp	.\test\test_reliable_pool_policy.py	/^    def setUp(self):$/;"	m	class:TestReliablePoolPolicy
setUp	.\test\test_routing_prefixes.py	/^    def setUp(self):$/;"	m	class:TestMcrouterRoutingPrefixAscii
setUp	.\test\test_send_to_all_hosts.py	/^    def setUp(self):$/;"	m	class:TestSendToAllHosts
setUp	.\test\test_server_stats.py	/^    def setUp(self):$/;"	m	class:TestServerStatsOutstandingRequests
setUp	.\test\test_shadow.py	/^    def setUp(self):$/;"	m	class:TestShadow
setUp	.\test\test_shadow_with_file.py	/^    def setUp(self):$/;"	m	class:TestShadowWithFile
setUp	.\test\test_shard_splits.py	/^    def setUp(self):$/;"	m	class:TestShardSplits
setUp	.\test\test_slow_box_tko.py	/^    def setUp(self):$/;"	m	class:TestSlowBoxTko
setUp	.\test\test_umbrella_server.py	/^    def setUp(self):$/;"	m	class:TestUmbrellaServer
setUp	.\test\test_warmup.py	/^    def setUp(self):$/;"	m	class:TestWarmup
setUp	.\test\test_wch3.py	/^    def setUp(self):$/;"	m	class:TestWCH3
setValue	.\lib\McReplyBase.cpp	/^void McReplyBase::setValue(folly::IOBuf valueData) {$/;"	f	class:facebook::memcache::McReplyBase
setValue	.\lib\McReplyBase.cpp	/^void McReplyBase::setValue(folly::StringPiece str) {$/;"	f	class:facebook::memcache::McReplyBase
setValue	.\lib\McRequestBase.h	/^  void setValue(folly::IOBuf valueData) {$/;"	f	class:facebook::memcache::McRequestBase
setValue	.\lib\fibers\FiberPromise-inl.h	/^void FiberPromise<T>::setValue() {$/;"	f	class:facebook::memcache::FiberPromise
setValue	.\lib\fibers\FiberPromise-inl.h	/^void FiberPromise<T>::setValue(M&& v) {$/;"	f	class:facebook::memcache::FiberPromise
setValueFrom	.\lib\McRequestBase.cpp	/^bool McRequestBase::setValueFrom(const folly::IOBuf& source,$/;"	f	class:facebook::memcache::McRequestBase
set_fd_limit	.\lib\fbi\unix.h	/^static inline int set_fd_limit(int n) {$/;"	f
set_log_limit	.\lib\fbi\log_limit.c	/^int set_log_limit(int max_log_num, int cycle_sec) {$/;"	f
setsTb_	.\routes\RateLimiter.h	/^  folly::Optional<TokenBucket> setsTb_;$/;"	m	class:facebook::memcache::mcrouter::RateLimiter
settings_	.\routes\FailoverWithExptimeRoute.h	/^  FailoverWithExptimeSettings settings_;$/;"	m	class:facebook::memcache::mcrouter::FailoverWithExptimeRoute
setup_stderr_redir	.\lib\fbi\test\log_tid_tests.cpp	/^static void setup_stderr_redir(int* saved_stderr) {$/;"	f	file:
sfrlock_init	.\lib\fbi\sfrlock.c	/^void sfrlock_init(sfrlock_t *l) {$/;"	f
sfrlock_rdlock	.\lib\fbi\sfrlock.h	/^static inline void sfrlock_rdlock(sfrlock_t *lock) {$/;"	f
sfrlock_rdlock_contended	.\lib\fbi\sfrlock.c	/^void sfrlock_rdlock_contended(sfrlock_t *l) {$/;"	f
sfrlock_rdunlock	.\lib\fbi\sfrlock.h	/^static inline void sfrlock_rdunlock(sfrlock_t *lock) {$/;"	f
sfrlock_read_test	.\lib\fbi\test\sfrlock_test.cpp	/^void sfrlock_read_test(void) {$/;"	f
sfrlock_t	.\lib\fbi\sfrlock.h	/^} sfrlock_t;$/;"	t	typeref:struct:__anon14
sfrlock_wake_waiters	.\lib\fbi\sfrlock.c	/^void sfrlock_wake_waiters(sfrlock_t *l) {$/;"	f
sfrlock_write_test	.\lib\fbi\test\sfrlock_test.cpp	/^void sfrlock_write_test(void) {$/;"	f
sfrlock_wrlock	.\lib\fbi\sfrlock.h	/^static inline void sfrlock_wrlock(sfrlock_t *lock) {$/;"	f
sfrlock_wrlock_contended	.\lib\fbi\sfrlock.c	/^void sfrlock_wrlock_contended(sfrlock_t *l) {$/;"	f
sfrlock_wrunlock	.\lib\fbi\sfrlock.h	/^static inline void sfrlock_wrunlock(sfrlock_t *lock) {$/;"	f
shadowData_	.\routes\ShadowRoute.h	/^  ShadowData<RouteHandleIf> shadowData_;$/;"	m	class:facebook::memcache::mcrouter::ShadowRoute
shadowPolicy_	.\routes\ShadowRoute.h	/^  ShadowPolicy shadowPolicy_;$/;"	m	class:facebook::memcache::mcrouter::ShadowRoute
shadow_policy_t	.\proxy.h	/^enum shadow_policy_t {$/;"	g	namespace:facebook::memcache::mcrouter
shadow_pool	.\proxy.h	/^    ProxyPool* shadow_pool;$/;"	m	struct:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t::Data
shadow_type	.\proxy.h	/^    shadow_policy_t shadow_type;$/;"	m	struct:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t::Data
shadowing_policies	.\proxy.h	/^      shadowing_policies;$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
shardLookup	.\routes\ShardHashFunc.cpp	/^bool ConstShardHashFunc::shardLookup(folly::StringPiece key,$/;"	f	class:facebook::memcache::mcrouter::ConstShardHashFunc
shardSplits_	.\routes\ShardSplitter.h	/^  StringKeyedUnorderedMap<size_t> shardSplits_;$/;"	m	class:facebook::memcache::mcrouter::ShardSplitter
shardSplitter	.\proxy.h	/^  std::unique_ptr<ShardSplitter> shardSplitter;$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
shardSplitter_	.\routes\ShardSplitRoute.h	/^  const ShardSplitter shardSplitter_;$/;"	m	class:facebook::memcache::mcrouter::ShardSplitRoute
shared	.\ProxyDestination.h	/^  std::shared_ptr<ProxyClientShared> shared;$/;"	m	struct:facebook::memcache::mcrouter::ProxyDestination
shift_nstring_inplace	.\proxy.cpp	/^inline void shift_nstring_inplace(nstring_t* nstr, int pos) {$/;"	f	namespace:facebook::memcache::mcrouter::__anon50
short_option	.\options.h	/^  char short_option;$/;"	m	struct:facebook::memcache::McrouterOptionData
shouldDelayShadow	.\routes\DefaultShadowPolicy.h	/^  static bool shouldDelayShadow(const Request& req, Operation) {$/;"	f	class:facebook::memcache::mcrouter::DefaultShadowPolicy
shouldFailover	.\routes\FailoverWithExptimeRouteIf.h	/^    bool shouldFailover(Operation,$/;"	f	struct:facebook::memcache::mcrouter::FailoverWithExptimeSettings::OperationSettings
shouldShadow	.\routes\ShadowRoute.h	/^  bool shouldShadow(const Request& req,$/;"	f	class:facebook::memcache::mcrouter::ShadowRoute
shrinkBuffers	.\lib\network\McParser.cpp	/^void McParser::shrinkBuffers() {$/;"	f	class:facebook::memcache::McParser
shuffleMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic shuffleMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
shutdown	.\lib\network\AsyncMcServer.cpp	/^  void shutdown() {$/;"	f	class:facebook::memcache::McServerThread
shutdown	.\lib\network\AsyncMcServer.cpp	/^void AsyncMcServer::shutdown() {$/;"	f	class:facebook::memcache::AsyncMcServer
shutdown	.\lib\network\AsyncMcServerWorker.cpp	/^void AsyncMcServerWorker::shutdown() {$/;"	f	class:facebook::memcache::AsyncMcServerWorker
shutdownAllTasks	.\PeriodicTaskScheduler.cpp	/^void PeriodicTaskScheduler::shutdownAllTasks() {$/;"	f	class:facebook::memcache::mcrouter::PeriodicTaskScheduler
shutdownAndJoinAuxiliaryThreads	.\router.cpp	/^void mcrouter_t::shutdownAndJoinAuxiliaryThreads() {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
shutdownFromSignalHandler	.\lib\network\AsyncMcServer.cpp	/^  void shutdownFromSignalHandler() {$/;"	f	class:facebook::memcache::McServerThread
shutdownFromSignalHandler	.\lib\network\AsyncMcServer.cpp	/^  void shutdownFromSignalHandler() {$/;"	f	class:facebook::memcache::ShutdownPipe
shutdownFromSignalHandler	.\lib\network\AsyncMcServer.cpp	/^void AsyncMcServer::shutdownFromSignalHandler() {$/;"	f	class:facebook::memcache::AsyncMcServer
shutdownLock	.\router.cpp	/^ShutdownLock& mcrouter_t::shutdownLock() {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
shutdownLock_	.\_router.h	/^  ShutdownLock shutdownLock_;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
shutdownLock_	.\lib\network\AsyncMcServer.h	/^  std::mutex shutdownLock_;$/;"	m	class:facebook::memcache::AsyncMcServer
shutdownOnce	.\lib\fbi\cpp\ShutdownLock.h	/^  bool shutdownOnce(F&& func) {$/;"	f	class:facebook::memcache::ShutdownLock
shutdownPipe_	.\lib\network\AsyncMcServer.cpp	/^  std::unique_ptr<ShutdownPipe> shutdownPipe_;$/;"	m	class:facebook::memcache::McServerThread	file:
shutdownStarted	.\lib\fbi\cpp\ShutdownLock.h	/^  bool shutdownStarted() {$/;"	f	class:facebook::memcache::ShutdownLock
shutdownStarted	.\router.cpp	/^bool mcrouter_t::shutdownStarted() {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
shutdownStarted_	.\lib\fbi\cpp\ShutdownLock.h	/^  std::atomic<bool> shutdownStarted_;$/;"	m	class:facebook::memcache::ShutdownLock
shutdown_	.\PeriodicTaskScheduler.h	/^  std::atomic_bool shutdown_;$/;"	m	class:facebook::memcache::mcrouter::PeriodicTaskScheduler
shutdown_	.\lib\network\test\AsyncMcClientTest.cpp	/^  bool& shutdown_;$/;"	m	class:__anon42::ServerOnRequest	file:
shutdown_started_exception	.\lib\fbi\cpp\ShutdownLock.h	/^  shutdown_started_exception()$/;"	f	struct:facebook::memcache::shutdown_started_exception
shutdown_started_exception	.\lib\fbi\cpp\ShutdownLock.h	/^struct shutdown_started_exception : std::runtime_error {$/;"	s	namespace:facebook::memcache
shutil	.\test\MCProcess.py	/^import shutil$/;"	i
shutil	.\test\test_async_files.py	/^import shutil$/;"	i
shutil	.\test\test_probe_timeout.py	/^import shutil$/;"	i
signal	.\test\MCProcess.py	/^import signal$/;"	i
signal	.\test\test_bad_params.py	/^import signal$/;"	i
signal_event	.\lib\fbi\asox_semaphore.c	/^  event_t signal_event;$/;"	m	struct:asox_sem_s	file:
sigterm_handler	.\main.cpp	/^static void sigterm_handler(int signum) {$/;"	f	file:
simpleAsciiTimeoutTest	.\lib\network\test\AsyncMcClientTest.cpp	/^void simpleAsciiTimeoutTest(bool useSsl = false) {$/;"	f
simpleHandshakeCallback	.\lib\network\AsyncMcServerWorker.cpp	/^SimpleHandshakeCallback simpleHandshakeCallback;$/;"	m	namespace:facebook::memcache::__anon39	file:
simpleUmbrellaTimeoutTest	.\lib\network\test\AsyncMcClientTest.cpp	/^void simpleUmbrellaTimeoutTest(bool useSsl = false) {$/;"	f
singlethreaded_test	.\lib\fbi\test\counter_test.cpp	/^static int singlethreaded_test(void (*adder)(counter_t *,int64_t),$/;"	f	file:
size	.\lib\network\UniqueIntrusiveList.h	/^  size_t size() const { return list_.size(); }$/;"	f	class:facebook::memcache::UniqueIntrusiveList
sizeMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic sizeMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
size_type	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  typedef typename std::allocator<T>::size_type size_type;$/;"	t	struct:TestAllocator	file:
skiplist_alloc	.\lib\fbi\skiplist.h	18;"	d
skiplist_del	.\lib\fbi\skiplist.c	/^void skiplist_del(skiplist_t* list) {$/;"	f
skiplist_delete	.\lib\fbi\skiplist.c	/^skiplist_status_t skiplist_delete(skiplist_t* list, uint32_t key) {$/;"	f
skiplist_find	.\lib\fbi\skiplist.c	/^skiplist_status_t skiplist_find(const skiplist_t* list,$/;"	f
skiplist_findnextlargest	.\lib\fbi\skiplist.c	/^skiplist_status_t skiplist_findnextlargest(const skiplist_t* list,$/;"	f
skiplist_free	.\lib\fbi\skiplist.h	19;"	d
skiplist_insert	.\lib\fbi\skiplist.c	/^skiplist_status_t skiplist_insert(skiplist_t* list,$/;"	f
skiplist_new	.\lib\fbi\skiplist.c	/^skiplist_t* skiplist_new() {$/;"	f
skiplist_node_s	.\lib\fbi\skiplist.h	/^typedef struct skiplist_node_s {$/;"	s
skiplist_node_t	.\lib\fbi\skiplist.h	/^} skiplist_node_t;$/;"	t	typeref:struct:skiplist_node_s
skiplist_s	.\lib\fbi\skiplist.h	/^typedef struct skiplist_s {$/;"	s
skiplist_status_t	.\lib\fbi\skiplist.h	/^} skiplist_status_t;$/;"	t	typeref:enum:__anon15
skiplist_t	.\lib\fbi\skiplist.h	/^} skiplist_t;$/;"	t	typeref:struct:skiplist_s
sleepThread	.\PeriodicTaskScheduler.cpp	/^bool PeriodicTaskScheduler::sleepThread(int32_t tmoMs) {$/;"	f	class:facebook::memcache::mcrouter::PeriodicTaskScheduler
sliceMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic sliceMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
slot_seed	.\lib\fbi\counter.c	/^static volatile int slot_seed = 0;$/;"	v	file:
sockaddrlen	.\lib\fbi\network.h	/^  uint16_t sockaddrlen;$/;"	m	struct:__anon13
socket	.\test\MCProcess.py	/^import socket$/;"	i
socket	.\test\mock_servers.py	/^import socket$/;"	i
socket	.\test\test_bad_params.py	/^import socket$/;"	i
socket	.\test\test_multiple_ports.py	/^import socket$/;"	i
socket	.\test\test_validate_config.py	/^import socket$/;"	i
socketFd_	.\lib\network\test\AsyncMcClientTest.cpp	/^  int socketFd_;$/;"	m	class:__anon42::TestServer	file:
socket_	.\lib\network\AsyncMcClientImpl.h	/^  apache::thrift::async::TAsyncSocket::UniquePtr socket_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
socket_	.\lib\network\AsyncMcServer.cpp	/^  apache::thrift::async::TAsyncServerSocket::UniquePtr socket_;$/;"	m	class:facebook::memcache::McServerThread	file:
source	.\lib\fbi\error.h	/^  const char* source; \/\/!< Source file name$/;"	m	struct:fbi_err_s
spawn	.\ProxyThread.cpp	/^int ProxyThread::spawn() {$/;"	f	class:facebook::memcache::mcrouter::ProxyThread
spawn	.\lib\network\AsyncMcServer.cpp	/^  void spawn(AsyncMcServer::LoopFn fn, size_t threadId) {$/;"	f	class:facebook::memcache::McServerThread
spawn	.\lib\network\AsyncMcServer.cpp	/^void AsyncMcServer::spawn(LoopFn fn) {$/;"	f	class:facebook::memcache::AsyncMcServer
spawn	.\test\test_bad_params.py	/^    def spawn(self, cmd):$/;"	m	class:OutputCheckerTestCase
spawnAuxiliaryThreads	.\router.cpp	/^void mcrouter_t::spawnAuxiliaryThreads() {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
spawnException_	.\lib\network\AsyncMcServer.cpp	/^  std::exception_ptr spawnException_;$/;"	m	class:facebook::memcache::McServerThread	file:
spawnStatLoggerThread	.\router.cpp	/^void mcrouter_t::spawnStatLoggerThread() {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
spawnStatUpdaterThread	.\router.cpp	/^void mcrouter_t::spawnStatUpdaterThread() {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
spawn_thread	.\router.cpp	/^int spawn_thread(pthread_t *thread_handle, void **stack,$/;"	f	namespace:facebook::memcache::mcrouter
spinWaitForEarlyPost	.\lib\fibers\Baton.cpp	/^bool Baton::spinWaitForEarlyPost() {$/;"	f	class:facebook::memcache::Baton
splitReq	.\routes\ShardSplitRoute.h	/^  Request splitReq(const Request& req, size_t offset,$/;"	f	class:facebook::memcache::mcrouter::ShardSplitRoute
sslAcceptCallback_	.\lib\network\AsyncMcServer.cpp	/^  AcceptCallback sslAcceptCallback_;$/;"	m	class:facebook::memcache::McServerThread	file:
sslContextProvider	.\lib\network\ConnectionOptions.h	/^    sslContextProvider;$/;"	m	struct:facebook::memcache::ConnectionOptions
sslPorts	.\lib\network\AsyncMcServer.h	/^    std::vector<uint16_t> sslPorts;$/;"	m	struct:facebook::memcache::AsyncMcServer::Options
sslSocket_	.\lib\network\AsyncMcServer.cpp	/^  apache::thrift::async::TAsyncServerSocket::UniquePtr sslSocket_;$/;"	m	class:facebook::memcache::McServerThread	file:
stack	.\lib\fbi\asox_queue.c	/^  asox_queue_entry_t * volatile stack;$/;"	m	struct:asox_queue_s	file:
stackAllocator_	.\lib\fibers\FiberManager.h	/^  GuardPageAllocator stackAllocator_;$/;"	m	class:facebook::memcache::FiberManager
stackAllocator_	.\lib\fibers\FiberManager.h	/^  std::allocator<unsigned char> stackAllocator_;$/;"	m	class:facebook::memcache::FiberManager
stackBase	.\lib\fibers\BoostContextCompatibility.h	/^  void* stackBase() const {$/;"	f	struct:facebook::memcache::FContext
stackBase_	.\lib\fibers\BoostContextCompatibility.h	/^  void* stackBase_;$/;"	m	struct:facebook::memcache::FContext
stackHighWatermark	.\lib\fibers\FiberManager.cpp	/^size_t FiberManager::stackHighWatermark() const {$/;"	f	class:facebook::memcache::FiberManager
stackLimit	.\lib\fibers\BoostContextCompatibility.h	/^  void* stackLimit() const {$/;"	f	struct:facebook::memcache::FContext
stackLimit_	.\lib\fibers\BoostContextCompatibility.h	/^  void* stackLimit_;$/;"	m	struct:facebook::memcache::FContext
standaloneInit	.\mcrouter_config.cpp	/^bool standaloneInit(const McrouterOptions& opts) {$/;"	f	namespace:facebook::memcache::mcrouter
standaloneOpts	.\main.cpp	/^static McrouterStandaloneOptions standaloneOpts;$/;"	v	file:
start	.\McrouterLogger.cpp	/^bool McrouterLogger::start() {$/;"	f	class:facebook::memcache::mcrouter::McrouterLogger
start	.\async.cpp	/^bool AsyncWriter::start(folly::StringPiece threadName) {$/;"	f	class:facebook::memcache::mcrouter::AsyncWriter
startAccepting	.\lib\network\AsyncMcServer.cpp	/^  void startAccepting() {$/;"	f	class:facebook::memcache::McServerThread	file:
startAwriterThreads	.\router.cpp	/^void mcrouter_t::startAwriterThreads() {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
startMemcachedOnPort	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^int MemcacheLocal::startMemcachedOnPort(const string& path,$/;"	f	class:facebook::memcache::test::MemcacheLocal
startMemcachedServer	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^int MemcacheLocal::startMemcachedServer(const int start_port,$/;"	f	class:facebook::memcache::test::MemcacheLocal
startObserving	.\ConfigApi.cpp	/^void ConfigApi::startObserving() {$/;"	f	class:facebook::memcache::mcrouter::ConfigApi
startObserving	.\FileObserver.cpp	/^bool FileObserver::startObserving(const std::string& filePath,$/;"	f	class:facebook::memcache::mcrouter::FileObserver
startObservingRuntimeVarsFile	.\router.cpp	/^void mcrouter_t::startObservingRuntimeVarsFile() {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
startShutdown	.\router.cpp	/^void mcrouter_t::startShutdown() {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
startTimeSec_	.\lib\routes\MigrateRoute.h	/^  time_t startTimeSec_;$/;"	m	class:facebook::memcache::MigrateRoute
start_index	.\proxy.h	/^    size_t start_index;$/;"	m	struct:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t::Data
start_key_fraction	.\proxy.h	/^    double start_key_fraction;$/;"	m	struct:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t::Data
start_sending_probes	.\ProxyDestination.cpp	/^void ProxyDestination::start_sending_probes() {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
start_time	.\_router.h	/^  uint64_t start_time;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
start_time	.\lib\fbi\timer.h	/^  uint64_t start_time;$/;"	m	struct:fb_timer_s
startupLock	.\_router.h	/^  StartupLock startupLock;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
statUpdaterCv	.\_router.h	/^  std::condition_variable statUpdaterCv;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
statUpdaterCvMutex	.\_router.h	/^  std::mutex statUpdaterCvMutex;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
stat_decr	.\stats.cpp	/^void stat_decr(stat_t* stats, stat_name_t stat_num, int64_t amount) {$/;"	f	namespace:facebook::memcache::mcrouter
stat_decr_safe	.\stats.cpp	/^void stat_decr_safe(stat_t* stats, stat_name_t stat_name) {$/;"	f	namespace:facebook::memcache::mcrouter
stat_double	.\stats.h	/^  stat_double,$/;"	e	enum:facebook::memcache::mcrouter::stat_type_t
stat_get_config_age	.\stats.cpp	/^uint64_t stat_get_config_age(const stat_t* stats, uint64_t now) {$/;"	f	namespace:facebook::memcache::mcrouter
stat_get_rusage	.\stats.cpp	/^static std::string stat_get_rusage(void* ptr) {$/;"	f	namespace:facebook::memcache::mcrouter
stat_get_uint64	.\stats.cpp	/^uint64_t stat_get_uint64(stat_t* stats, stat_name_t stat_num) {$/;"	f	namespace:facebook::memcache::mcrouter
stat_group_t	.\stats.h	/^enum stat_group_t {$/;"	g	namespace:facebook::memcache::mcrouter
stat_incr	.\stats.cpp	/^void stat_incr(stat_t* stats, stat_name_t stat_num, int64_t amount) {$/;"	f	namespace:facebook::memcache::mcrouter
stat_incr_safe	.\stats.cpp	/^void stat_incr_safe(stat_t* stats, stat_name_t stat_name) {$/;"	f	namespace:facebook::memcache::mcrouter
stat_int64	.\stats.h	/^  stat_int64,$/;"	e	enum:facebook::memcache::mcrouter::stat_type_t
stat_name_t	.\stats.h	/^enum stat_name_t {$/;"	g	namespace:facebook::memcache::mcrouter
stat_parse_group_str	.\stats.cpp	/^static stat_group_t stat_parse_group_str(folly::StringPiece str) {$/;"	f	namespace:facebook::memcache::mcrouter
stat_set_uint64	.\stats.cpp	/^void stat_set_uint64(stat_t* stats,$/;"	f	namespace:facebook::memcache::mcrouter
stat_string	.\stats.h	/^  stat_string,$/;"	e	enum:facebook::memcache::mcrouter::stat_type_t
stat_string_fn	.\stats.h	/^  stat_string_fn,$/;"	e	enum:facebook::memcache::mcrouter::stat_type_t
stat_t	.\stats.h	/^struct stat_t {$/;"	s	namespace:facebook::memcache::mcrouter
stat_to_str	.\stats.cpp	/^static std::string stat_to_str(const stat_t* stat, void *ptr) {$/;"	f	namespace:facebook::memcache::mcrouter
stat_type_t	.\stats.h	/^enum stat_type_t {$/;"	g	namespace:facebook::memcache::mcrouter
stat_uint64	.\stats.h	/^  stat_uint64,$/;"	e	enum:facebook::memcache::mcrouter::stat_type_t
stat_updater_thread_handle	.\_router.h	/^  pthread_t stat_updater_thread_handle;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
stat_updater_thread_run	.\router.cpp	/^static void *stat_updater_thread_run(void *arg) {$/;"	f	namespace:facebook::memcache::mcrouter
stat_updater_thread_stack	.\_router.h	/^  void* stat_updater_thread_stack;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
state	.\ProxyDestination.cpp	/^proxy_client_state_t ProxyDestination::state() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
state	.\lib\fbi\asox_timer.c	/^  timer_state_t state;$/;"	m	struct:_asox_timer_s	file:
stateListHook_	.\ProxyDestination.h	/^  folly::IntrusiveListHook stateListHook_;$/;"	m	struct:facebook::memcache::mcrouter::ProxyDestination
states	.\stats.cpp	/^  size_t states[PROXY_CLIENT_NUM_STATES] = {0};$/;"	m	struct:facebook::memcache::mcrouter::__anon62::ServerStat	file:
stats	.\ProxyDestination.cpp	/^const ProxyDestinationStats& ProxyDestination::stats() const {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
stats	.\lib\mc\ascii_response.h	/^  char* stats;$/;"	m	struct:mc_ascii_response_buf_s
stats	.\lib\mc\msg.h	/^  nstring_t* stats; \/\/\/< array of 2*number nstrings for stats. freed for stats replies.$/;"	m	struct:mc_msg_s
stats	.\mcrouter_client.h	/^  mcrouter_client_stats_t stats;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_client_t
stats	.\proxy.h	/^  stat_t stats[num_stats];$/;"	m	struct:facebook::memcache::mcrouter::proxy_t
stats	.\test\MCProcess.py	/^    def stats(self, spec=None):$/;"	m	class:MCProcess
statsContainer	.\proxy.h	/^  std::unique_ptr<ProxyStatsContainer> statsContainer;$/;"	m	struct:facebook::memcache::mcrouter::proxy_t
stats_	.\ProxyDestination.h	/^  ProxyDestinationStats stats_;$/;"	m	struct:facebook::memcache::mcrouter::ProxyDestination
stats_	.\lib\StatsReply.h	/^  std::vector<std::pair<std::string, std::string>> stats_;$/;"	m	class:facebook::memcache::StatsReply
stats_	.\lib\network\test\AsyncMcClientTest.cpp	/^  CommonStats stats_;$/;"	m	class:__anon42::TestServer	file:
stats_aggregate_rate_value	.\stats.cpp	/^double stats_aggregate_rate_value(const mcrouter_t* router, int idx) {$/;"	f	namespace:facebook::memcache::mcrouter
stats_bin	.\proxy.h	/^  uint64_t stats_bin[num_stats][MOVING_AVERAGE_WINDOW_SIZE_IN_SECOND \/$/;"	m	struct:facebook::memcache::mcrouter::proxy_t
stats_count	.\lib\mc\umbrella_protocol.c	/^  int stats_count;$/;"	m	struct:_parse_info_s	file:
stats_dir	.\test\test_async_files.py	/^    stats_dir = ''$/;"	v	class:TestAsyncFiles
stats_file_path	.\McrouterLogger.cpp	/^std::string stats_file_path(const McrouterOptions& opts,$/;"	f	namespace:facebook::memcache::mcrouter::__anon46
stats_lock	.\proxy.h	/^  std::mutex stats_lock;$/;"	m	struct:facebook::memcache::mcrouter::proxy_t
stats_log_writer	.\_router.h	/^  std::unique_ptr<AsyncWriter> stats_log_writer;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
stats_num_within_window	.\proxy.h	/^  uint64_t stats_num_within_window[num_stats];$/;"	m	struct:facebook::memcache::mcrouter::proxy_t
stats_rate_value	.\stats.cpp	/^double stats_rate_value(proxy_t* proxy, int idx) {$/;"	f	namespace:facebook::memcache::mcrouter::__anon62
stats_reply	.\stats.cpp	/^McReply stats_reply(proxy_t* proxy, folly::StringPiece group_str) {$/;"	f	namespace:facebook::memcache::mcrouter
stats_reply_to_string	.\lib\mc\ascii_response.c	/^static char* stats_reply_to_string(nstring_t *stats,$/;"	f	file:
status	.\lib\fbi\timer.h	/^  fb_timer_status_t status;$/;"	m	struct:fb_timer_s
statusCallbacks_	.\lib\network\AsyncMcClientImpl.h	/^  ConnectionStatusCallbacks statusCallbacks_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
steps	.\lib\fbi\test\counter_test.cpp	/^  int steps;$/;"	m	struct:test_params_s	file:
stop	.\McrouterLogger.cpp	/^void McrouterLogger::stop() {$/;"	f	class:facebook::memcache::mcrouter::McrouterLogger
stop	.\async.cpp	/^void AsyncWriter::stop() {$/;"	f	class:facebook::memcache::mcrouter::AsyncWriter
stop	.\lib\fibers\SimpleLoopController.h	/^  void stop() {$/;"	f	class:facebook::memcache::SimpleLoopController
stopAndJoin	.\ProxyThread.cpp	/^void ProxyThread::stopAndJoin() {$/;"	f	class:facebook::memcache::mcrouter::ProxyThread
stopAwriterThreads	.\router.cpp	/^void mcrouter_t::stopAwriterThreads() {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
stopMemcachedServer	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^void MemcacheLocal::stopMemcachedServer(const int port) const {$/;"	f	class:facebook::memcache::test::MemcacheLocal
stopObserving	.\ConfigApi.cpp	/^void ConfigApi::stopObserving(pid_t pid) {$/;"	f	class:facebook::memcache::mcrouter::ConfigApi
stopRequested_	.\lib\fibers\SimpleLoopController.h	/^  bool stopRequested_;$/;"	m	class:facebook::memcache::SimpleLoopController
stop_sending_probes	.\ProxyDestination.cpp	/^void ProxyDestination::stop_sending_probes() {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
store_req	.\lib\mc\umbrella_protocol.c	58;"	d	file:
store_rsp	.\lib\mc\umbrella_protocol.c	92;"	d	file:
str	.\RoutingPrefix.h	/^  const std::string& str() const { return prefix_; }$/;"	f	class:facebook::memcache::mcrouter::RoutingPrefix
str	.\lib\fbi\examples\thread-errs.c	/^  char* str;$/;"	m	struct:blob_s	file:
str	.\lib\fbi\nstring.h	/^  char* str;$/;"	m	struct:nstring_s
str	.\lib\mc\umbrella.h	/^    } str;$/;"	m	union:um_elist_entry_s::__anon34	typeref:struct:um_elist_entry_s::__anon34::__anon35
strMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic strMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
string	.\options.h	/^    string,$/;"	m	class:facebook::memcache::McrouterOptionData::Type
string	.\stats.h	/^    char* string;$/;"	m	union:facebook::memcache::mcrouter::stat_t::__anon63
string_fn	.\stats.h	/^    string_fn_t string_fn;$/;"	m	union:facebook::memcache::mcrouter::stat_t::__anon63
string_fn_t	.\stats.h	/^typedef std::string(*string_fn_t)(void*);$/;"	t	class:facebook::memcache::mcrouter::std
strings_	.\lib\network\UmbrellaProtocol.h	/^  folly::StringPiece strings_[kInlineStrings];$/;"	m	class:facebook::memcache::UmbrellaSerializedReply
strmaxlen	.\lib\fbi\network.h	/^  uint16_t strmaxlen;$/;"	m	struct:__anon13
subMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic subMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
sub_port	.\test\MCProcess.py	/^def sub_port(s, substitute_ports, port_map):$/;"	f
subprocess	.\test\MCProcess.py	/^import subprocess$/;"	i
subprocess	.\test\test_bad_params.py	/^import subprocess$/;"	i
subscribe	.\CallbackPool-inl.h	/^CallbackPool<Args...>::subscribe(OnUpdateFunc callback) {$/;"	f	class:facebook::memcache::mcrouter::CallbackPool
subscribe	.\ConfigApi.cpp	/^ConfigApi::CallbackHandle ConfigApi::subscribe(Callback callback) {$/;"	f	class:facebook::memcache::mcrouter::ConfigApi
subscribe	.\Observable-inl.h	/^Observable<Data>::subscribe(OnUpdateOldNew callback) {$/;"	f	class:facebook::memcache::mcrouter::Observable
subscribeAndCall	.\Observable-inl.h	/^Observable<Data>::subscribeAndCall(OnUpdateOldNew callback) {$/;"	f	class:facebook::memcache::mcrouter::Observable
subscribeToConfigUpdate	.\router.cpp	/^void mcrouter_t::subscribeToConfigUpdate() {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
subscribeToTrackedSources	.\ConfigApi.cpp	/^void ConfigApi::subscribeToTrackedSources() {$/;"	f	class:facebook::memcache::mcrouter::ConfigApi
substituteTemplates	.\options.cpp	/^McrouterOptions substituteTemplates(McrouterOptions opts) {$/;"	f	namespace:facebook::memcache::options
substituteTemplates	.\options.cpp	/^std::string substituteTemplates(std::string str) {$/;"	f	namespace:facebook::memcache::options
substituteTemplates	.\standalone_options.cpp	/^McrouterStandaloneOptions substituteTemplates(McrouterStandaloneOptions opts) {$/;"	f	namespace:facebook::memcache::mcrouter::options
success	.\test\cpp_unit_tests\awriter_test.cpp	/^  int success;$/;"	m	struct:counts	file:
suppressed	.\lib\fbi\debug.c	/^  int suppressed;$/;"	m	struct:msg_info	file:
suspect_server_stats	.\stats.h	/^  suspect_server_stats =    0x40000,$/;"	e	enum:facebook::memcache::mcrouter::stat_group_t
swap	.\lib\fbi\cpp\AtomicSharedPtr.h	/^  void swap(T& data) {$/;"	f	class:facebook::memcache::AtomicWrapper
swapConfig	.\proxy.cpp	/^std::shared_ptr<ProxyConfigIf> proxy_t::swapConfig($/;"	f	class:facebook::memcache::mcrouter::proxy_t
sweep	.\lib\fbi\cpp\AtomicLinkedList.h	/^  void sweep(F&& func) {$/;"	f	class:facebook::memcache::AtomicLinkedList
sys	.\test\MCProcess.py	/^import sys$/;"	i
sys	.\test\test_bad_params.py	/^import sys$/;"	i
system_time_sec	.\stats.cpp	/^  double system_time_sec;$/;"	m	struct:facebook::memcache::mcrouter::proc_stat_data_t	file:
t	.\PeriodicTaskScheduler.h	/^    std::thread t;$/;"	m	struct:facebook::memcache::mcrouter::PeriodicTaskScheduler::TaskThread
t_	.\lib\fbi\cpp\Trie-inl.h	/^  T* t_;$/;"	m	class:facebook::memcache::Trie::iterator_base
tag	.\lib\mc\umbrella.h	/^  uint16_t tag;         \/\/ Application-specific tag for this entry$/;"	m	struct:um_elist_entry_s
tail	.\lib\fbi\log_limit.c	/^static int head = 0, tail = 0, count = 0;$/;"	v	file:
target_	.\lib\routes\HostIdRoute.h	/^  std::shared_ptr<RouteHandleIf> target_;$/;"	m	class:facebook::memcache::HostIdRoute
target_	.\routes\RateLimitRoute.h	/^  std::shared_ptr<RouteHandleIf> target_;$/;"	m	class:facebook::memcache::mcrouter::RateLimitRoute
targets_	.\lib\routes\FailoverRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> targets_;$/;"	m	class:facebook::memcache::FailoverRoute
targets_	.\lib\routes\MissFailoverRoute.h	/^  std::vector<std::shared_ptr<RouteHandleIf>> targets_;$/;"	m	class:facebook::memcache::MissFailoverRoute
taskScheduler_	.\_router.h	/^  PeriodicTaskScheduler taskScheduler_;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
tasks_	.\PeriodicTaskScheduler.h	/^  std::vector<std::unique_ptr<TaskThread>> tasks_;$/;"	m	class:facebook::memcache::mcrouter::PeriodicTaskScheduler
tbuf	.\lib\mc\parser.h	/^  char *tbuf; \/\/\/< token buffer$/;"	m	struct:parser_s
tbuf_len	.\lib\mc\parser.h	/^  size_t tbuf_len; \/\/\/< token buffer length$/;"	m	struct:parser_s
te	.\lib\mc\parser.h	/^  char* te; \/\/\/< token end$/;"	m	struct:parser_s
tearDown	.\test\McrouterTestCase.py	/^    def tearDown(self):$/;"	m	class:McrouterTestCase
tearDown	.\test\test_async_files.py	/^    def tearDown(self):$/;"	m	class:TestAsyncFiles
tearDown	.\test\test_bad_params.py	/^    def tearDown(self):$/;"	m	class:OutputCheckerTestCase
tempfile	.\test\MCProcess.py	/^import tempfile$/;"	i
tempfile	.\test\test_async_files.py	/^import tempfile$/;"	i
terminate	.\test\MCProcess.py	/^    def terminate(self):$/;"	m	class:MCProcess
terminate	.\test\mock_servers.py	/^    def terminate(self):$/;"	m	class:MockServer
test	.\routes\test\RateLimitRouteTest.cpp	/^void test(Data data, Operation,$/;"	f	namespace:__anon59
test	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^namespace facebook { namespace memcache { namespace test {$/;"	n	namespace:facebook::memcache	file:
test	.\test\cpp_unit_tests\MemcacheLocal.h	/^namespace facebook { namespace memcache { namespace test {$/;"	n	namespace:facebook::memcache
test	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^namespace facebook { namespace memcache { namespace test {$/;"	n	namespace:facebook::memcache	file:
test	.\test\cpp_unit_tests\mcrouter_test_client.h	/^namespace test {$/;"	n	namespace:facebook::memcache
testDeletes	.\routes\test\RateLimitRouteTest.cpp	/^void testDeletes(bool burst = false) {$/;"	f	namespace:__anon59
testFailoverDelete	.\routes\test\FailoverWithExptimeRouteTest.cpp	/^void testFailoverDelete(mc_res_t res) {$/;"	f
testFailoverGet	.\routes\test\FailoverWithExptimeRouteTest.cpp	/^void testFailoverGet(mc_res_t res) {$/;"	f
testFailoverUpdate	.\routes\test\FailoverWithExptimeRouteTest.cpp	/^void testFailoverUpdate(mc_res_t res) {$/;"	f
testGets	.\routes\test\RateLimitRouteTest.cpp	/^void testGets(bool burst = false) {$/;"	f	namespace:__anon59
testSets	.\routes\test\RateLimitRouteTest.cpp	/^void testSets(bool burst = false) {$/;"	f	namespace:__anon59
test_add_replace_noreply	.\test\test_noreply.py	/^    def test_add_replace_noreply(self):$/;"	m	class:TestNoreply
test_arg_t	.\lib\fbi\test\asox_sem_test.cpp	/^struct test_arg_t {$/;"	s	namespace:__anon20	file:
test_arith_noreply	.\test\test_noreply.py	/^    def test_arith_noreply(self):$/;"	m	class:TestNoreply
test_ascii_error	.\test\test_ascii_error.py	/^    def test_ascii_error(self):$/;"	m	class:TestAsciiError
test_assign	.\lib\test\RequestReplyTest.cpp	/^static void test_assign(mc_msg_t* a, mc_msg_t* b) {$/;"	f	file:
test_async_files	.\test\test_async_files.py	/^    def test_async_files(self):$/;"	m	class:TestAsyncFiles
test_bad_commands	.\test\test_mcrouter_sanity.py	/^    def test_bad_commands(self):$/;"	m	class:TestMcrouterSanity
test_bad_config	.\test\test_bad_params.py	/^    def test_bad_config(self):$/;"	m	class:TestBadParams
test_bad_key	.\test\test_mcrouter_sanity.py	/^    def test_bad_key(self):$/;"	m	class:TestMcrouterSanity
test_bad_stats	.\test\test_mcrouter_sanity.py	/^    def test_bad_stats(self):$/;"	m	class:TestMcrouterSanity
test_bad_tko_param	.\test\test_bad_params.py	/^    def test_bad_tko_param(self):$/;"	m	class:TestBadParams
test_basic	.\test\test_mcrouter_sanity.py	/^    def test_basic(self):$/;"	m	class:TestMcrouterSanity
test_basic	.\test\test_rates.py	/^    def test_basic(self):$/;"	m	class:TestRates
test_basic_all_first	.\test\test_mcrouter_basic.py	/^    def test_basic_all_first(self):$/;"	m	class:TestBasicAllFirst
test_basic_all_majority	.\test\test_mcrouter_basic.py	/^    def test_basic_all_majority(self):$/;"	m	class:TestBasicAllMajority
test_basic_all_sync	.\test\test_mcrouter_basic.py	/^    def test_basic_all_sync(self):$/;"	m	class:TestBasicAllSync
test_basic_invalid_route	.\test\test_mcrouter_basic.py	/^    def test_basic_invalid_route(self):$/;"	m	class:TestMcrouterInvalidRoute
test_basic_lease	.\test\test_mcrouter_basic.py	/^    def test_basic_lease(self):$/;"	m	class:TestMcrouterBasic
test_behaviour	.\test\test_miss_on_error_arith_ops.py	/^    def test_behaviour(self):$/;"	m	class:TestMissOnErrorArithOps
test_burst	.\test\test_rates.py	/^    def test_burst(self):$/;"	m	class:TestRates
test_callbacks	.\test\cpp_unit_tests\awriter_test.cpp	/^static const awriter_callbacks_t test_callbacks = {$/;"	v	file:
test_const_shard_hash	.\test\test_const_shard_hash.py	/^    def test_const_shard_hash(self):$/;"	m	class:TestConstShardHash
test_copy_ctor	.\lib\test\RequestReplyTest.cpp	/^static void test_copy_ctor(mc_msg_t* a) {$/;"	f	file:
test_delete	.\test\test_mcrouter_basic.py	/^    def test_delete(self):$/;"	m	class:TestMcrouterBasic2
test_delete	.\test\test_send_to_all_hosts.py	/^    def test_delete(self):$/;"	m	class:TestSendToAllHosts
test_delete_noreply	.\test\test_noreply.py	/^    def test_delete_noreply(self):$/;"	m	class:TestNoreply
test_dev_null	.\test\test_mcrouter.py	/^    def test_dev_null(self):$/;"	m	class:TestDevNull
test_different_cluster	.\test\test_logical_routing_policies.py	/^    def test_different_cluster(self):$/;"	m	class:TestLogicalRoutingPolicies
test_different_region_cluster	.\test\test_logical_routing_policies.py	/^    def test_different_region_cluster(self):$/;"	m	class:TestLogicalRoutingPolicies
test_down	.\test\test_mcrouter_sanity.py	/^    def test_down(self):$/;"	m	class:TestMcrouterSanity
test_duplicate_servers	.\test\test_mcrouter.py	/^    def test_duplicate_servers(self):$/;"	m	class:TestDuplicateServers
test_duplicate_servers_difftimeouts	.\test\test_mcrouter.py	/^    def test_duplicate_servers_difftimeouts(self):$/;"	m	class:TestDuplicateServersDiffTimeouts
test_empty_pool	.\test\test_empty_pool.py	/^    def test_empty_pool(self):$/;"	m	class:TestEmptyPool
test_entry_writer	.\test\cpp_unit_tests\awriter_test.cpp	/^static int test_entry_writer(awriter_entry_t* e) {$/;"	f	file:
test_expiration	.\test\test_warmup.py	/^    def test_expiration(self):$/;"	m	class:TestWarmup
test_failover	.\test\test_mcrouter_basic.py	/^    def test_failover(self):$/;"	m	class:TestBasicFailover
test_failover	.\test\test_mcrouter_sanity.py	/^    def test_failover(self):$/;"	m	class:TestMcrouterSanity
test_failover_override	.\test\test_mcrouter_basic.py	/^    def test_failover_override(self):$/;"	m	class:TestBasicFailoverOverride
test_get_failover	.\test\test_mcrouter.py	/^    def test_get_failover(self):$/;"	m	class:TestGetFailover
test_get_failover	.\test\test_mcrouter.py	/^    def test_get_failover(self):$/;"	m	class:TestGetFailoverWithFailoverTag
test_getset	.\test\test_mcrouter_sanity.py	/^    def test_getset(self):$/;"	m	class:TestMcrouterSanity
test_hostid	.\test\test_service_info.py	/^    def test_hostid(self):$/;"	m	class:TestServiceInfo
test_invalid_config	.\test\test_validate_config.py	/^    def test_invalid_config(self):$/;"	m	class:TestValidateConfig
test_invalid_key	.\test\test_mcrouter_basic.py	/^    def test_invalid_key(self):$/;"	m	class:TestMcrouterBasic
test_l1_l2_get	.\test\test_mcrouter_basic.py	/^    def test_l1_l2_get(self):$/;"	m	class:TestMcrouterBasicL1L2
test_l1_l2_get_l1_down	.\test\test_mcrouter_basic.py	/^    def test_l1_l2_get_l1_down(self):$/;"	m	class:TestMcrouterBasicL1L2
test_l1_l2_get_l2_down	.\test\test_mcrouter_basic.py	/^    def test_l1_l2_get_l2_down(self):$/;"	m	class:TestMcrouterBasicL1L2
test_largeobj	.\test\test_largeobj.py	/^    def test_largeobj(self):$/;"	m	class:TestLargeObj
test_lease_get_failover	.\test\test_mcrouter.py	/^    def test_lease_get_failover(self):$/;"	m	class:TestLeaseGetFailover
test_malformed_umbrella_length	.\test\test_mcrouter_basic.py	/^    def test_malformed_umbrella_length(self):$/;"	m	class:TestMcrouterBasic2
test_max_shadow_requests	.\test\test_max_shadow_requests.py	/^    def test_max_shadow_requests(self):$/;"	m	class:TestServerStatsOutstandingRequests
test_metaconfig	.\test\test_mcrouter_sanity.py	/^    def test_metaconfig(self):$/;"	m	class:TestMcrouterSanity
test_metaget_failover	.\test\test_mcrouter.py	/^    def test_metaget_failover(self):$/;"	m	class:TestMetaGetFailover
test_metaroute	.\test\test_mcrouter_sanity.py	/^    def test_metaroute(self):$/;"	m	class:TestMcrouterSanity
test_migrated_failover	.\test\test_migrated_failover.py	/^    def test_migrated_failover(self):$/;"	m	class:TestMigratedFailover
test_migrated_new_shadow	.\test\test_shadow.py	/^    def test_migrated_new_shadow(self):$/;"	m	class:TestShadow
test_migrated_old_shadow	.\test\test_shadow.py	/^    def test_migrated_old_shadow(self):$/;"	m	class:TestShadow
test_migrated_pools	.\test\test_mcrouter.py	/^    def test_migrated_pools(self):$/;"	m	class:TestMigratedPools
test_migrated_pools_failover	.\test\test_mcrouter.py	/^    def test_migrated_pools_failover(self):$/;"	m	class:TestMigratedPoolsFailover
test_migrated_shadow	.\test\test_shadow.py	/^    def test_migrated_shadow(self):$/;"	m	class:TestShadow
test_move	.\lib\test\RequestReplyTest.cpp	/^static void test_move(mc_msg_t* a, mc_msg_t* b) {$/;"	f	file:
test_move_ctor	.\lib\test\RequestReplyTest.cpp	/^static void test_move_ctor(mc_msg_t* a) {$/;"	f	file:
test_move_ctor_mc_msg	.\lib\test\RequestReplyTest.cpp	/^static void test_move_ctor_mc_msg(mc_msg_t* a) {$/;"	f	file:
test_move_mc_msg	.\lib\test\RequestReplyTest.cpp	/^static void test_move_mc_msg(mc_msg_t* a) {$/;"	f	file:
test_multiple_ports	.\test\test_multiple_ports.py	/^    def test_multiple_ports(self):$/;"	m	class:TestMultiplePorts
test_no_big_value	.\test\test_mcrouter_basic.py	/^    def test_no_big_value(self):$/;"	m	class:TestMcrouterBasic2
test_normal_shadow	.\test\test_shadow.py	/^    def test_normal_shadow(self):$/;"	m	class:TestShadow
test_ops	.\test\test_mcrouter_sanity.py	/^    def test_ops(self):$/;"	m	class:TestMcrouterSanity
test_params_s	.\lib\fbi\test\counter_test.cpp	/^typedef struct test_params_s {$/;"	s	file:
test_params_t	.\lib\fbi\test\counter_test.cpp	/^} test_params_t;$/;"	t	typeref:struct:test_params_s	file:
test_prefix_routing	.\test\test_mcrouter_basic.py	/^    def test_prefix_routing(self):$/;"	m	class:TestMcrouterBasic2
test_probe_timeout	.\test\test_probe_timeout.py	/^    def test_probe_timeout(self):$/;"	m	class:TestProbeTimeout
test_regional_shadow	.\test\test_shadow.py	/^    def test_regional_shadow(self):$/;"	m	class:TestShadow
test_regular_request	.\test\test_send_to_all_hosts.py	/^    def test_regular_request(self):$/;"	m	class:TestSendToAllHosts
test_reject_policy	.\test\test_mcrouter_sanity.py	/^    def test_reject_policy(self):$/;"	m	class:TestMcrouterSanity
test_reliable_pool_failover	.\test\test_reliable_pool_policy.py	/^    def test_reliable_pool_failover(self):$/;"	m	class:TestReliablePoolPolicy
test_reliable_pool_no_failover	.\test\test_reliable_pool_policy.py	/^    def test_reliable_pool_no_failover(self):$/;"	m	class:TestReliablePoolPolicy
test_route_format	.\test\test_service_info.py	/^    def test_route_format(self):$/;"	m	class:TestServiceInfo
test_routing_prefix	.\test\test_routing_prefixes.py	/^    def test_routing_prefix(self):$/;"	m	class:TestMcrouterRoutingPrefixAscii
test_runtime_variables_override_key_fraction	.\test\test_shadow.py	/^    def test_runtime_variables_override_key_fraction(self):$/;"	m	class:TestShadow
test_runtime_variables_override_range	.\test\test_shadow.py	/^    def test_runtime_variables_override_range(self):$/;"	m	class:TestShadow
test_same_pool_failover	.\test\test_mcrouter.py	/^    def test_same_pool_failover(self):$/;"	m	class:TestSamePoolFailover
test_sanity	.\test\test_warmup.py	/^    def test_sanity(self):$/;"	m	class:TestWarmup
test_server_error_message	.\test\test_mcrouter_sanity.py	/^    def test_server_error_message(self):$/;"	m	class:TestMcrouterSanity
test_server_list_from_another_pool	.\test\test_mcrouter.py	/^    def test_server_list_from_another_pool(self):$/;"	m	class:TestServerListFromAnotherPool
test_server_stats	.\test\test_mcrouter_sanity.py	/^    def test_server_stats(self):$/;"	m	class:TestMcrouterSanity
test_server_stats	.\test\test_server_stats.py	/^    def test_server_stats(self):$/;"	m	class:TestServerStatsOutstandingRequests
test_set	.\test\test_send_to_all_hosts.py	/^    def test_set(self):$/;"	m	class:TestSendToAllHosts
test_set_noreply	.\test\test_noreply.py	/^    def test_set_noreply(self):$/;"	m	class:TestNoreply
test_shadow_with_file	.\test\test_shadow_with_file.py	/^    def test_shadow_with_file(self):$/;"	m	class:TestShadowWithFile
test_shard_splits_basic	.\test\test_shard_splits.py	/^    def test_shard_splits_basic(self):$/;"	m	class:TestShardSplits
test_shard_splits_update	.\test\test_shard_splits.py	/^    def test_shard_splits_update(self):$/;"	m	class:TestShardSplits
test_stats_deadlock	.\test\test_mcrouter_basic.py	/^    def test_stats_deadlock(self):$/;"	m	class:TestMcrouterBasic
test_tko	.\test\test_slow_box_tko.py	/^    def test_tko(self):$/;"	m	class:TestSlowBoxTko
test_umbrella_server	.\test\test_umbrella_server.py	/^    def test_umbrella_server(self):$/;"	m	class:TestUmbrellaServer
test_use_big_value	.\test\test_mcrouter_basic.py	/^    def test_use_big_value(self):$/;"	m	class:TestMcrouterBasic2
test_valid_config	.\test\test_validate_config.py	/^    def test_valid_config(self):$/;"	m	class:TestValidateConfig
test_version	.\test\test_mcrouter_sanity.py	/^    def test_version(self):$/;"	m	class:TestMcrouterSanity
test_wch3	.\test\test_wch3.py	/^    def test_wch3(self):$/;"	m	class:TestWCH3
testing_context_t	.\test\cpp_unit_tests\awriter_test.cpp	/^struct testing_context_t {$/;"	s	file:
thread	.\lib\fbi\test\asox_queue_test.cpp	/^  std::thread thread;$/;"	m	struct:__anon19::Info	file:
thread_	.\awriter.h	/^  std::thread thread_;$/;"	m	class:facebook::memcache::mcrouter::AsyncWriter
thread_	.\lib\network\AsyncMcServer.cpp	/^  std::thread thread_;$/;"	m	class:facebook::memcache::McServerThread	file:
thread_arg_t	.\lib\fbi\test\asox_queue_test.cpp	/^struct thread_arg_t {$/;"	s	file:
thread_handle	.\ProxyThread.h	/^  pthread_t thread_handle;$/;"	m	class:facebook::memcache::mcrouter::ProxyThread
thread_stack	.\ProxyThread.h	/^  void *thread_stack;$/;"	m	class:facebook::memcache::mcrouter::ProxyThread
threading	.\test\mock_servers.py	/^import threading$/;"	i
threading	.\test\test_mcrouter_basic.py	/^import threading$/;"	i
threading	.\test\test_routing_prefixes.py	/^import threading$/;"	i
threads_	.\lib\network\AsyncMcServer.h	/^  std::vector<std::unique_ptr<McServerThread>> threads_;$/;"	m	class:facebook::memcache::AsyncMcServer
threshold	.\routes\test\BigValueRouteTest.cpp	/^static const int threshold = 128;$/;"	v	file:
threshold_	.\routes\BigValueRouteIf.h	/^  const size_t threshold_;$/;"	m	struct:facebook::memcache::BigValueRouteOptions
throwErrorImpl	.\lib\fbi\cpp\LogFailure.cpp	/^void throwErrorImpl(folly::StringPiece service,$/;"	f	namespace:facebook::memcache::failure::__anon9
throwIfFulfilled	.\lib\fibers\FiberPromise-inl.h	/^void FiberPromise<T>::throwIfFulfilled() const {$/;"	f	class:facebook::memcache::FiberPromise
throwLogicError	.\lib\fbi\cpp\LogFailure.cpp	/^std::pair<std::string, HandlerFunc> throwLogicError() {$/;"	f	namespace:facebook::memcache::failure::handlers
time	.\lib\fbi\asox_timer.c	/^  struct timeval time;$/;"	m	struct:_asox_timer_s	typeref:struct:_asox_timer_s::timeval	file:
time	.\test\MCProcess.py	/^import time$/;"	i
time	.\test\mock_servers.py	/^import time$/;"	i
time	.\test\test_async_files.py	/^import time$/;"	i
time	.\test\test_bad_params.py	/^import time$/;"	i
time	.\test\test_max_shadow_requests.py	/^import time$/;"	i
time	.\test\test_mcrouter.py	/^import time$/;"	i
time	.\test\test_mcrouter_sanity.py	/^import time$/;"	i
time	.\test\test_multiple_ports.py	/^import time$/;"	i
time	.\test\test_probe_timeout.py	/^import time$/;"	i
time	.\test\test_rates.py	/^import time$/;"	i
time	.\test\test_routing_prefixes.py	/^import time$/;"	i
time	.\test\test_shadow.py	/^import time$/;"	i
time	.\test\test_shard_splits.py	/^import time$/;"	i
time	.\test\test_slow_box_tko.py	/^import time$/;"	i
time	.\test\test_validate_config.py	/^import time$/;"	i
time	.\test\test_warmup.py	/^import time$/;"	i
time_enqueued	.\lib\fbi\asox_queue.h	/^  uint64_t time_enqueued;$/;"	m	struct:asox_queue_entry_s
timedSchedule	.\lib\fibers\EventBaseLoopController-inl.h	/^inline void EventBaseLoopController::timedSchedule(std::function<void()> func,$/;"	f	class:facebook::memcache::mcrouter::EventBaseLoopController
timedWaitThread	.\lib\fibers\Baton.cpp	/^bool Baton::timedWaitThread(TimeoutController::Duration timeout) {$/;"	f	class:facebook::memcache::Baton
timed_wait	.\lib\fibers\Baton-inl.h	/^bool Baton::timed_wait(TimeoutController::Duration timeout,$/;"	f	class:facebook::memcache::Baton
timed_wait	.\lib\fibers\Baton-inl.h	/^bool Baton::timed_wait(const std::chrono::time_point<C,D>& timeout) {$/;"	f	class:facebook::memcache::Baton
timed_wait	.\lib\fibers\Baton.cpp	/^bool Baton::timed_wait(TimeoutController::Duration timeout) {$/;"	f	class:facebook::memcache::Baton
timeout	.\proxy.h	/^  timeval_t timeout;$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
timeoutCallback_	.\lib\network\AsyncMcClientImpl.h	/^  std::unique_ptr<TimeoutCallback> timeoutCallback_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
timeoutExpired	.\lib\network\AsyncMcClientImpl.cpp	/^void AsyncMcClientImpl::timeoutExpired() {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
timeoutFunc_	.\lib\fibers\TimeoutController.h	/^  std::function<void()> timeoutFunc_;$/;"	m	class:facebook::memcache::TimeoutHandle
timeoutHandleBuckets_	.\lib\fibers\TimeoutController.h	/^  std::vector<std::pair<Duration, TimeoutHandleList>> timeoutHandleBuckets_;$/;"	m	class:facebook::memcache::TimeoutController
timeoutManager_	.\lib\fibers\FiberManager.h	/^  TimeoutController timeoutManager_;$/;"	m	class:facebook::memcache::FiberManager
timeout_	.\lib\fibers\TimeoutController.h	/^  TimePoint timeout_;$/;"	m	class:facebook::memcache::TimeoutHandle
timeout_handler	.\test\test_bad_params.py	/^        def timeout_handler(signum, frame):$/;"	f	function:OutputCheckerTestCase.check_for_message
timer_off	.\lib\fbi\asox_timer.c	/^  timer_off = 2,$/;"	e	enum:timer_state_e	file:
timer_on	.\lib\fbi\asox_timer.c	/^  timer_on = 1,$/;"	e	enum:timer_state_e	file:
timer_output_names	.\lib\fbi\timer.c	/^static nstring_t timer_output_names[] = {$/;"	v	file:
timer_state_e	.\lib\fbi\asox_timer.c	/^typedef enum timer_state_e {$/;"	g	file:
timer_state_t	.\lib\fbi\asox_timer.c	/^} timer_state_t;$/;"	t	typeref:enum:timer_state_e	file:
timer_state_to_string	.\lib\fbi\asox_timer.c	/^static inline const char* timer_state_to_string(const timer_state_t state) {$/;"	f	file:
timer_stats	.\stats.h	/^  timer_stats          =       0x80,$/;"	e	enum:facebook::memcache::mcrouter::stat_group_t
timer_stopped	.\lib\fbi\asox_timer.c	/^  timer_stopped = 4,$/;"	e	enum:timer_state_e	file:
timer_stopping	.\lib\fbi\asox_timer.c	/^  timer_stopping = 3,$/;"	e	enum:timer_state_e	file:
timer_unknown_state	.\lib\fbi\asox_timer.c	/^  timer_unknown_state = 0,$/;"	e	enum:timer_state_e	file:
timestamp	.\lib\fbi\error.h	/^  timeval_t timestamp;$/;"	m	struct:fbi_err_s
timeval_add	.\lib\fbi\time.h	/^static inline void timeval_add(timeval_t* a, const timeval_t* b) {$/;"	f
timeval_cmp	.\lib\fbi\time.h	/^static inline int timeval_cmp(const timeval_t* a, const timeval_t* b) {$/;"	f
timeval_eq	.\lib\fbi\time.h	/^static inline int timeval_eq(const timeval_t* a, const timeval_t* b) {$/;"	f
timeval_ge	.\lib\fbi\time.h	/^static inline int timeval_ge(const timeval_t* a, const timeval_t* b) {$/;"	f
timeval_gt	.\lib\fbi\time.h	/^static inline int timeval_gt(const timeval_t* a, const timeval_t* b) {$/;"	f
timeval_le	.\lib\fbi\time.h	/^static inline int timeval_le(const timeval_t* a, const timeval_t* b) {$/;"	f
timeval_lt	.\lib\fbi\time.h	/^static inline int timeval_lt(const timeval_t* a, const timeval_t* b) {$/;"	f
timeval_min	.\lib\fbi\time.h	/^static inline const timeval_t* timeval_min(const timeval_t* a,$/;"	f
timeval_ms	.\lib\fbi\time.h	/^static inline uint32_t timeval_ms(const timeval_t* t) {$/;"	f
timeval_sub	.\lib\fbi\time.h	/^static inline void timeval_sub(timeval_t* a, const timeval_t* b) {$/;"	f
timeval_t	.\lib\fbi\time.h	/^typedef struct timeval timeval_t;$/;"	t	typeref:struct:timeval
timeval_us	.\lib\fbi\time.h	/^static inline uint64_t timeval_us(const timeval_t* t) {$/;"	f
tko	.\pclient.h	/^  TkoTracker tko;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientShared
tko	.\routes\FailoverWithExptimeRouteIf.h	/^  OperationSettings tko;$/;"	m	struct:facebook::memcache::mcrouter::FailoverWithExptimeSettings
tkoCounters	.\_router.h	/^  TkoCounters tkoCounters;$/;"	m	struct:facebook::memcache::mcrouter::mcrouter_t
tkoThreshold_	.\TkoTracker.h	/^  const size_t tkoThreshold_;$/;"	m	class:facebook::memcache::mcrouter::TkoTracker
tmoMs	.\PeriodicTaskScheduler.h	/^    int32_t tmoMs;$/;"	m	struct:facebook::memcache::mcrouter::PeriodicTaskScheduler::TaskThread
to	.\lib\fbi\cpp\util.h	/^inline folly::StringPiece to<folly::StringPiece>(const nstring_t& ns) {$/;"	f	namespace:facebook::memcache
to	.\lib\fbi\cpp\util.h	/^inline nstring_t to<nstring_t>(const folly::StringPiece& sp) {$/;"	f	namespace:facebook::memcache
to	.\lib\fbi\cpp\util.h	/^inline nstring_t to<nstring_t>(const std::string& s) {$/;"	f	namespace:facebook::memcache
to	.\lib\fbi\cpp\util.h	/^inline std::string to<std::string>(const nstring_t& ns) {$/;"	f	namespace:facebook::memcache
to	.\lib\fbi\cpp\util.h	/^inline std::string to<std::string>(nstring_t* const& ns) {$/;"	f	namespace:facebook::memcache
to	.\lib\fbi\cpp\util.h	/^inline timeval_t to<timeval_t>(const unsigned int& ms) {$/;"	f	namespace:facebook::memcache
to	.\lib\fbi\cpp\util.h	/^to<std::chrono::milliseconds>(const timeval_t& t) {$/;"	f	namespace:facebook::memcache
to	.\options.cpp	/^to(const Src& value) {$/;"	f	namespace:folly
to	.\options.cpp	/^to(const facebook::memcache::mcrouter::RoutingPrefix& prefix) {$/;"	f	namespace:folly
to	.\options.cpp	/^to(const std::string& value) {$/;"	f	namespace:folly
to	.\options.cpp	/^to(const string& str) {$/;"	f	namespace:folly
toDict	.\options.cpp	/^unordered_map<string, string> McrouterOptionsBase::toDict() const {$/;"	f	class:facebook::memcache::McrouterOptionsBase
toEdge	.\lib\fbi\cpp\Trie-inl.h	/^int Trie<Value, MinChar, MaxChar>::toEdge(char c) {$/;"	f	class:facebook::memcache::Trie
toHostPortString	.\AccessPoint.cpp	/^std::string AccessPoint::toHostPortString() const {$/;"	f	class:facebook::memcache::mcrouter::AccessPoint
toSend	.\lib\fibers\test\FibersTestApp.cpp	/^  size_t toSend;$/;"	m	struct:Application	file:
toString	.\AccessPoint.cpp	/^std::string AccessPoint::toString() const {$/;"	f	class:facebook::memcache::mcrouter::AccessPoint
toString	.\lib\test\RouteHandleTestUtil.h	/^inline std::string toString(const folly::IOBuf& buf) {$/;"	f	namespace:facebook::memcache
toString	.\options.cpp	/^std::string toString(const boost::any& value) {$/;"	f	namespace:facebook::memcache::__anon48
toString	.\stats.cpp	/^  std::string toString() const {$/;"	f	struct:facebook::memcache::mcrouter::__anon62::ServerStat
toStringType	.\routes\BigValueRoute-inl.h	/^BigValueRoute<RouteHandleIf>::ChunksInfo::toStringType() const {$/;"	f	class:facebook::memcache::BigValueRoute::ChunksInfo
to_	.\lib\routes\MigrateRoute.h	/^  std::shared_ptr<RouteHandleIf> to_;$/;"	m	class:facebook::memcache::MigrateRoute
to_pool	.\proxy.h	/^  ProxyPool* to_pool;$/;"	m	class:facebook::memcache::mcrouter::ProxyMigratedPool
to_timeval	.\lib\fbi\test\log_coalesce_test.cpp	/^void to_timeval(uint64_t usec, struct timeval *t)$/;"	f	namespace:__anon23
to_usec	.\lib\fbi\test\log_coalesce_test.cpp	/^uint64_t to_usec(struct timeval *t)$/;"	f	namespace:__anon23
toggle	.\options.h	/^    toggle,$/;"	m	class:facebook::memcache::McrouterOptionData::Type
tokenBucket_	.\AtomicTokenBucket.h	/^  DynamicAtomicTokenBucket tokenBucket_;$/;"	m	class:facebook::memcache::mcrouter::AtomicTokenBucket
tokens_	.\TokenBucket.h	/^  double tokens_;$/;"	m	class:facebook::memcache::mcrouter::TokenBucket
totalTko	.\TkoCounters.h	/^  size_t totalTko() const {$/;"	f	struct:facebook::memcache::mcrouter::TkoCounters
total_eiov_len	.\lib\mc\umbrella.h	/^  uint32_t total_eiov_len; \/\/ sum of the lengths of all iovs$/;"	m	struct:entry_list_s
total_estrings_len	.\lib\mc\umbrella.h	/^  uint32_t total_estrings_len; \/\/ total length of external strings$/;"	m	struct:entry_list_s
total_inflations	.\lib\fbi\counter.c	/^static volatile int total_inflations = 0;$/;"	v	file:
total_size	.\lib\mc\umbrella.h	/^  uint32_t total_size; \/\/ MUST be first! (for length-prefixed-ness)$/;"	m	struct:entry_list_msg_s
total_time	.\lib\fbi\timer.h	/^  uint64_t total_time;$/;"	m	struct:fb_timer_s
touchFile	.\lib\fbi\cpp\util.cpp	/^bool touchFile(const std::string& path) {$/;"	f	namespace:facebook::memcache
touchStatsFilepaths_	.\McrouterLogger.h	/^  std::vector<std::string> touchStatsFilepaths_;$/;"	m	class:facebook::memcache::mcrouter::McrouterLogger
tp_	.\lib\routes\MigrateRoute.h	/^  const TimeProvider tp_;$/;"	m	class:facebook::memcache::MigrateRoute
trackConfigSources	.\ConfigApi.cpp	/^void ConfigApi::trackConfigSources() {$/;"	f	class:facebook::memcache::mcrouter::ConfigApi
trackedFiles_	.\ConfigApi.h	/^  std::unordered_map<std::string, FileInfo> trackedFiles_;$/;"	m	class:facebook::memcache::mcrouter::ConfigType::ConfigApi
tracking_	.\ConfigApi.h	/^  std::atomic<bool> tracking_;$/;"	m	class:facebook::memcache::mcrouter::ConfigType::ConfigApi
transactions_	.\lib\network\test\SessionTestHarness.h	/^  std::deque<Transaction> transactions_;$/;"	m	class:facebook::memcache::SessionTestHarness
transform	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic transform(ConfigPreprocessor* p,$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
transport	.\lib\mc\protocol.h	/^  mc_transport_t transport;$/;"	m	struct:mc_accesspoint_s
transport	.\proxy.h	/^  mc_transport_t transport;$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
transport_	.\lib\network\McServerSession.h	/^  apache::thrift::async::TAsyncTransport::UniquePtr transport_;$/;"	m	class:facebook::memcache::McServerSession
truncate_pidfile	.\main.cpp	/^void truncate_pidfile(int fd) {$/;"	f
tryCancel	.\lib\fibers\TimeoutController.cpp	/^bool TimeoutHandle::tryCancel() {$/;"	f	class:facebook::memcache::TimeoutHandle
tryFromString	.\options.cpp	/^bool tryFromString(const std::string& str, const boost::any& value) {$/;"	f	namespace:facebook::memcache::__anon48
tryGet	.\lib\config\ConfigPreprocessor.cpp	/^const Value& tryGet(const std::unordered_map<string, Value>& map,$/;"	f	namespace:facebook::memcache::__anon4
tryGet	.\lib\config\ConfigPreprocessor.cpp	/^const dynamic& tryGet(const dynamic& obj, const dynamic& key,$/;"	f	namespace:facebook::memcache::__anon4
tryGet	.\lib\fbi\cpp\util.h	/^inline typename Map::mapped_type tryGet($/;"	f	namespace:facebook::memcache
tryToString	.\options.cpp	/^bool tryToString(const boost::any& value, std::string& res) {$/;"	f	namespace:facebook::memcache::__anon48
try_mcrouter	.\test\test_validate_config.py	/^    def try_mcrouter(self, config):$/;"	m	class:TestValidateConfig
try_pop	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^  bool try_pop(std::pair<mc_msg_t*, McReply> &msg) {$/;"	f	class:facebook::memcache::test::ResultsSet
try_wait	.\lib\fibers\Baton.cpp	/^bool Baton::try_wait() {$/;"	f	class:facebook::memcache::Baton
txpriority	.\ProxyClientCommon.h	/^  int txpriority;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientCommon
type	.\ProxyMcRequest.h	/^  typedef mcrouter::ProxyMcReply type;$/;"	t	struct:facebook::memcache::ReplyType
type	.\RecordingContext.h	/^  typedef McReply type;$/;"	t	struct:facebook::memcache::ReplyType
type	.\lib\Ch3HashFunc.h	/^  static std::string type() {$/;"	f	class:facebook::memcache::Ch3HashFunc
type	.\lib\Crc32HashFunc.h	/^  static std::string type() {$/;"	f	class:facebook::memcache::Crc32HashFunc
type	.\lib\McOperation.h	/^  typedef class McReply type;$/;"	t	struct:facebook::memcache::ReplyType	typeref:class:facebook::memcache::ReplyType::McReply
type	.\lib\OperationTraits.h	/^  typedef T<Args...> type;$/;"	t	struct:facebook::memcache::detail::Join
type	.\lib\WeightedCh3HashFunc.h	/^  static std::string type() {$/;"	f	class:facebook::memcache::WeightedCh3HashFunc
type	.\lib\fbi\asox_queue.h	/^  int type;$/;"	m	struct:asox_queue_entry_s
type	.\lib\fbi\cpp\TypeList.h	/^    type;$/;"	t	struct:facebook::memcache::ConcatLists
type	.\lib\fbi\cpp\TypeList.h	/^  typedef List<Operations1...> type;$/;"	t	struct:facebook::memcache::ConcatLists
type	.\lib\fbi\cpp\traits.h	/^    decltype(&F::operator())>::type type;$/;"	t	struct:facebook::memcache::FirstArgOf
type	.\lib\fbi\cpp\traits.h	/^    typename std::remove_pointer<F>::type>::arg1_type type;$/;"	t	struct:facebook::memcache::FirstArgOf
type	.\lib\fbi\cpp\traits.h	/^  typedef First type;$/;"	t	struct:facebook::memcache::detail::ExtractFirstMemfn
type	.\lib\fbi\debug.c	/^  const char *type;$/;"	m	struct:msg_info	file:
type	.\lib\fbi\error.h	/^  fbi_errtype_t type; \/\/!< Type of error record$/;"	m	struct:fbi_err_s
type	.\lib\mc\umbrella.h	/^  uint16_t type;        \/\/ What's the type of this entry?$/;"	m	struct:um_elist_entry_s
type	.\lib\test\TestRequest.h	/^  typedef class McReply type;$/;"	t	struct:facebook::memcache::ReplyType	typeref:class:facebook::memcache::ReplyType::McReply
type	.\options.h	/^  Type type;$/;"	m	struct:facebook::memcache::McrouterOptionData
type	.\routes\BigValueRoute.h	/^  typedef Request type;$/;"	t	struct:facebook::memcache::ChunkGetRequest
type	.\routes\BigValueRoute.h	/^  typedef Request type;$/;"	t	struct:facebook::memcache::ChunkUpdateRequest
type	.\routes\ShardHashFunc.h	/^  static std::string type() { return "ConstShard"; }$/;"	f	class:facebook::memcache::mcrouter::ConstShardHashFunc
type	.\stats.h	/^  stat_type_t type;$/;"	m	struct:facebook::memcache::mcrouter::stat_t
type_	.\lib\network\McParser.h	/^  ParserType type_;$/;"	m	class:facebook::memcache::McParser
u64fmt	.\lib\fbi\debug.h	27;"	d
uint64	.\stats.h	/^    uint64_t uint64;$/;"	m	union:facebook::memcache::mcrouter::stat_t::__anon63
umBackingMsg_	.\lib\network\McSerializedRequest.h	/^  um_backing_msg_t umBackingMsg_;$/;"	m	class:facebook::memcache::McSerializedRequest
umBodyBuffer_	.\lib\network\McParser.h	/^  std::unique_ptr<folly::IOBuf> umBodyBuffer_;$/;"	m	class:facebook::memcache::McParser
umMessageReady	.\lib\network\McParser.cpp	/^bool McParser::umMessageReady($/;"	f	class:facebook::memcache::McParser
um_backing_msg_cleanup	.\lib\mc\umbrella_protocol.c	/^void um_backing_msg_cleanup(um_backing_msg_t* bmsg) {$/;"	f
um_backing_msg_init	.\lib\mc\umbrella_protocol.c	/^int um_backing_msg_init(um_backing_msg_t* bmsg) {$/;"	f
um_backing_msg_s	.\lib\mc\umbrella.h	/^struct um_backing_msg_s {$/;"	s
um_backing_msg_t	.\lib\mc\umbrella_protocol.h	/^typedef struct um_backing_msg_s um_backing_msg_t;$/;"	t	typeref:struct:um_backing_msg_s
um_consume_buffer	.\lib\mc\umbrella_protocol.c	/^int um_consume_buffer(um_parser_t* um_parser,$/;"	f
um_consume_no_copy	.\lib\mc\umbrella_protocol.c	/^um_status_t um_consume_no_copy(const uint8_t* header, size_t nheader,$/;"	f
um_consume_one_message	.\lib\mc\umbrella_protocol.c	/^ssize_t um_consume_one_message(um_parser_t* um_parser,$/;"	f
um_elist_entry_s	.\lib\mc\umbrella.h	/^typedef struct um_elist_entry_s {$/;"	s
um_elist_entry_t	.\lib\mc\umbrella.h	/^} __attribute__((__packed__)) um_elist_entry_t;$/;"	t	typeref:struct:um_elist_entry_s
um_emit_iovs	.\lib\mc\umbrella_protocol.h	/^int um_emit_iovs(um_backing_msg_t* bmsg,$/;"	f
um_emit_iovs_extended	.\lib\mc\umbrella_protocol.c	/^int um_emit_iovs_extended(um_backing_msg_t* bmsg,$/;"	f
um_header_parse_error	.\lib\mc\umbrella_protocol.h	/^  um_header_parse_error,$/;"	e	enum:um_status_e
um_invalid_range	.\lib\mc\umbrella_protocol.h	/^  um_invalid_range,$/;"	e	enum:um_status_e
um_is_umbrella_stream	.\lib\mc\umbrella_protocol.h	/^static inline int um_is_umbrella_stream(const char first_byte) {$/;"	f
um_message_info_s	.\lib\mc\umbrella_protocol.h	/^typedef struct um_message_info_s {$/;"	s
um_message_info_t	.\lib\mc\umbrella_protocol.h	/^} um_message_info_t;$/;"	t	typeref:struct:um_message_info_s
um_message_parse_error	.\lib\mc\umbrella_protocol.h	/^  um_message_parse_error,$/;"	e	enum:um_status_e
um_not_enough_data	.\lib\mc\umbrella_protocol.h	/^  um_not_enough_data,$/;"	e	enum:um_status_e
um_not_umbrella_message	.\lib\mc\umbrella_protocol.h	/^  um_not_umbrella_message,$/;"	e	enum:um_status_e
um_ok	.\lib\mc\umbrella_protocol.h	/^  um_ok,$/;"	e	enum:um_status_e
um_parse_header	.\lib\mc\umbrella_protocol.c	/^um_status_t um_parse_header(const uint8_t* buf, size_t nbuf,$/;"	f
um_parser	.\lib\mc\parser.h	/^  um_parser_t um_parser;$/;"	m	struct:parser_s
um_parser_init	.\lib\mc\umbrella_protocol.c	/^int um_parser_init(um_parser_t* um_parser) {$/;"	f
um_parser_reset	.\lib\mc\umbrella_protocol.c	/^int um_parser_reset(um_parser_t* um_parser) {$/;"	f
um_parser_s	.\lib\mc\umbrella.h	/^struct um_parser_s {$/;"	s
um_parser_t	.\lib\mc\umbrella_protocol.h	/^typedef struct um_parser_s um_parser_t;$/;"	t	typeref:struct:um_parser_s
um_status_e	.\lib\mc\umbrella_protocol.h	/^typedef enum um_status_e {$/;"	g
um_status_t	.\lib\mc\umbrella_protocol.h	/^} um_status_t;$/;"	t	typeref:enum:um_status_e
um_write_iovs	.\lib\mc\umbrella_protocol.h	/^ssize_t um_write_iovs(um_backing_msg_t* bmsg,$/;"	f
um_write_iovs_extended	.\lib\mc\umbrella_protocol.c	/^ssize_t um_write_iovs_extended(um_backing_msg_t* bmsg,$/;"	f
umbrellaParseRequest	.\lib\network\UmbrellaProtocol.cpp	/^McRequest umbrellaParseRequest(const folly::IOBuf& source,$/;"	f	namespace:facebook::memcache
umbrellaReply_	.\lib\network\WriteBuffer.h	/^    UmbrellaSerializedReply umbrellaReply_;$/;"	m	union:facebook::memcache::WriteBuffer::__anon43
umbrellaTest	.\lib\network\test\AsyncMcClientTest.cpp	/^void umbrellaTest(bool useSsl = false) {$/;"	f
umbrella_op_from_mc	.\lib\mc\umbrella_protocol.c	/^uint32_t const umbrella_op_from_mc[UM_NOPS] = {$/;"	v
umbrella_op_to_mc	.\lib\mc\umbrella_protocol.c	/^uint32_t const umbrella_op_to_mc[UM_NOPS] = {$/;"	v
umbrella_res_from_mc	.\lib\mc\umbrella_protocol.c	/^uint32_t const umbrella_res_from_mc[mc_nres] = {$/;"	v
umbrella_res_to_mc	.\lib\mc\umbrella_protocol.c	/^uint32_t const umbrella_res_to_mc[mc_nres] = {$/;"	v
unescapeInto	.\lib\config\ConfigPreprocessor.cpp	/^void unescapeInto(StringPiece from, string& to) {$/;"	f	namespace:facebook::memcache::__anon4
unicode_literals	.\test\MCProcess.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\McrouterTestCase.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\mcrouter_config.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\mock_servers.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_ascii_error.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_async_files.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_bad_params.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_const_shard_hash.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_empty_pool.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_largeobj.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_logical_routing_policies.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_max_shadow_requests.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_mcrouter.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_mcrouter_basic.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_mcrouter_sanity.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_migrated_failover.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_miss_on_error_arith_ops.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_multiple_ports.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_noreply.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_probe_timeout.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_rates.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_reliable_pool_policy.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_routing_prefixes.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_send_to_all_hosts.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_server_stats.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_service_info.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_shadow.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_shadow_with_file.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_shard_splits.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_slow_box_tko.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_umbrella_server.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_validate_config.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_warmup.py	/^from __future__ import unicode_literals$/;"	i
unicode_literals	.\test\test_wch3.py	/^from __future__ import unicode_literals$/;"	i
unimplemented	.\main.cpp	/^void unimplemented(char ch, struct option long_options[], int long_index) {$/;"	f
unittest	.\test\MCProcess.py	/^import unittest$/;"	i
unittest	.\test\McrouterTestCase.py	/^import unittest$/;"	i
unittest	.\test\test_bad_params.py	/^import unittest$/;"	i
unittest	.\test\test_mcrouter_basic.py	/^import unittest$/;"	i
unittest	.\test\test_multiple_ports.py	/^import unittest$/;"	i
unittest	.\test\test_routing_prefixes.py	/^import unittest$/;"	i
unittest	.\test\test_validate_config.py	/^import unittest$/;"	i
unknown_stats	.\stats.h	/^  unknown_stats        = 0x10000000,$/;"	e	enum:facebook::memcache::mcrouter::stat_group_t
unlock	.\lib\fbi\cpp\ShutdownLock.h	/^  void unlock() {$/;"	f	class:facebook::memcache::ShutdownLock
unlock	.\lib\fbi\cpp\sfrlock.h	/^  void unlock() {$/;"	f	class:SFRReadLock
unlock	.\lib\fbi\cpp\sfrlock.h	/^  void unlock() {$/;"	f	class:SFRWriteLock
unmark_tko	.\ProxyDestination.cpp	/^void ProxyDestination::unmark_tko() {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
unpause	.\lib\test\RouteHandleTestUtil.h	/^  void unpause() {$/;"	f	struct:facebook::memcache::TestHandle
unpause	.\test\MCProcess.py	/^    def unpause(self):$/;"	m	class:MCProcess
unsetTko	.\lib\test\RouteHandleTestUtil.h	/^  void unsetTko() {$/;"	f	struct:facebook::memcache::TestHandle
unsubscribeFromConfigUpdate	.\router.cpp	/^void mcrouter_t::unsubscribeFromConfigUpdate() {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
update	.\lib\McRequestBase.cpp	/^void McRequestBase::Keys::update(folly::StringPiece key) {$/;"	f	class:facebook::memcache::McRequestBase::Keys
updateColdNcache	.\lib\routes\WarmUpRoute.h	/^  void updateColdNcache(const Request& req, Operation) {$/;"	f	class:facebook::memcache::WarmUpRoute
updateFromDict	.\options.cpp	/^vector<McrouterOptionError> McrouterOptionsBase::updateFromDict($/;"	f	class:facebook::memcache::McrouterOptionsBase
updateInotifyWatch	.\FileDataProvider.cpp	/^void FileDataProvider::updateInotifyWatch() {$/;"	f	class:facebook::memcache::mcrouter::FileDataProvider
updateProxyClientShared	.\pclient.cpp	/^void ProxyClientOwner::updateProxyClientShared($/;"	f	class:facebook::memcache::mcrouter::ProxyClientOwner
updateRequestForShadowing	.\routes\DefaultShadowPolicy.h	/^  static Request updateRequestForShadowing(const Request& req, Operation) {$/;"	f	class:facebook::memcache::mcrouter::DefaultShadowPolicy
updateToken	.\lib\network\test\MockMc.cpp	/^void MockMc::CacheItem::updateToken() {$/;"	f	class:facebook::memcache::MockMc::CacheItem
update_send_stats	.\route.cpp	/^void update_send_stats(proxy_t *proxy, const McMsgRef& req,$/;"	f	namespace:facebook::memcache::mcrouter
usage	.\lib\network\test\MockMcServer.cpp	/^void usage(char** argv) {$/;"	f
useSsl	.\ProxyClientCommon.h	/^  bool useSsl;$/;"	m	struct:facebook::memcache::mcrouter::ProxyClientCommon
use_count	.\lib\fbi\asox_queue.c	/^  waitable_counter_t use_count;$/;"	m	struct:asox_queue_s	file:
usec	.\lib\fbi\debug.c	210;"	d	file:
usec	.\lib\fbi\debug.c	238;"	d	file:
userBuffer_	.\lib\fibers\Fiber.h	/^  std::aligned_storage<kUserBufferSize>::type userBuffer_;$/;"	m	class:facebook::memcache::Fiber
userContext	.\lib\network\McServerSession.h	/^  void* userContext() {$/;"	f	class:facebook::memcache::McServerSession
user_time_sec	.\stats.cpp	/^  double user_time_sec;$/;"	m	struct:facebook::memcache::mcrouter::proc_stat_data_t	file:
ut_	.\routes\RoutePolicyMap.h	/^  Trie<std::vector<McrouterRouteHandlePtr>> ut_;$/;"	m	class:facebook::memcache::mcrouter::RoutePolicyMap
val	.\lib\mc\umbrella.h	/^    uint64_t val;       \/\/ If it's an int, just throw it into a uint64_t$/;"	m	union:um_elist_entry_s::__anon34
valid	.\routes\BigValueRoute-inl.h	/^bool BigValueRoute<RouteHandleIf>::ChunksInfo::valid() const {$/;"	f	class:facebook::memcache::BigValueRoute::ChunksInfo
valid_	.\routes\BigValueRoute.h	/^    bool valid_;$/;"	m	class:facebook::memcache::BigValueRoute::ChunksInfo
valid_config	.\test\test_validate_config.py	/^    valid_config = 'mcrouter\/test\/test_ascii.json'$/;"	v	class:TestValidateConfig
valid_msg	.\lib\mc\umbrella_protocol.c	/^static inline int valid_msg(mc_op_t op, uint64_t field_mask) {$/;"	f	file:
validate_options	.\main.cpp	/^static int validate_options() {$/;"	f	file:
validate_replies	.\proxy.h	/^    bool validate_replies;$/;"	m	struct:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t::Data
value	.\ExponentialSmoothData.h	/^  double value() const {$/;"	f	class:facebook::memcache::mcrouter::ExponentialSmoothData
value	.\lib\McOperationTraits.h	/^  static const bool value = true;$/;"	m	struct:facebook::memcache::ArithmeticLike
value	.\lib\McOperationTraits.h	/^  static const bool value = true;$/;"	m	struct:facebook::memcache::DeleteLike
value	.\lib\McOperationTraits.h	/^  static const bool value = true;$/;"	m	struct:facebook::memcache::GetLike
value	.\lib\McOperationTraits.h	/^  static const bool value = true;$/;"	m	struct:facebook::memcache::UpdateLike
value	.\lib\McReplyBase.h	/^  const folly::IOBuf& value() const {$/;"	f	class:facebook::memcache::McReplyBase
value	.\lib\McRequestBase.h	/^  const folly::IOBuf& value() const {$/;"	f	class:facebook::memcache::McRequestBase
value	.\lib\OperationTraits.h	/^  static const bool value = !ArithmeticLike<Operation>::value;$/;"	m	struct:facebook::memcache::OtherThan
value	.\lib\OperationTraits.h	/^  static const bool value = !DeleteLike<Operation>::value;$/;"	m	struct:facebook::memcache::OtherThan
value	.\lib\OperationTraits.h	/^  static const bool value = !GetLike<Operation>::value;$/;"	m	struct:facebook::memcache::OtherThan
value	.\lib\OperationTraits.h	/^  static const bool value = !UpdateLike<Operation>::value;$/;"	m	struct:facebook::memcache::OtherThan
value	.\lib\OperationTraits.h	/^  static const bool value = false;$/;"	m	struct:facebook::memcache::ArithmeticLike
value	.\lib\OperationTraits.h	/^  static const bool value = false;$/;"	m	struct:facebook::memcache::DeleteLike
value	.\lib\OperationTraits.h	/^  static const bool value = false;$/;"	m	struct:facebook::memcache::GetLike
value	.\lib\OperationTraits.h	/^  static const bool value = false;$/;"	m	struct:facebook::memcache::UpdateLike
value	.\lib\OperationTraits.h	/^  static const bool value =$/;"	m	struct:facebook::memcache::OtherThan
value	.\lib\fbi\cwlock.h	/^  uint32_t value;$/;"	m	struct:__anon11
value	.\lib\fbi\nstring.h	/^  const void* value;$/;"	m	struct:nstring_map_entry_s
value	.\lib\fbi\sfrlock.h	/^  uint32_t value;$/;"	m	struct:__anon14
value	.\lib\fbi\test\asox_sem_test.cpp	/^int value = 0;$/;"	m	namespace:__anon20	file:
value	.\lib\fibers\FiberManager-inl.h	/^struct IsRvalueRefTry { static const bool value = false; };$/;"	m	struct:facebook::memcache::IsRvalueRefTry
value	.\lib\fibers\FiberManager-inl.h	/^struct IsRvalueRefTry<folly::wangle::Try<T>&&> { static const bool value = true; };$/;"	m	struct:facebook::memcache::IsRvalueRefTry
value	.\lib\mc\msg.h	/^  nstring_t value; \/\/\/< storage value$/;"	m	struct:mc_msg_s
value	.\lib\network\test\MockMc.h	/^    std::unique_ptr<folly::IOBuf> value;$/;"	m	struct:facebook::memcache::MockMc::Item
valueData_	.\lib\McReplyBase.h	/^  mutable folly::Optional<folly::IOBuf> valueData_;$/;"	m	class:facebook::memcache::McReplyBase
valueData_	.\lib\McRequestBase.h	/^  folly::IOBuf valueData_;$/;"	m	class:facebook::memcache::McRequestBase
valueRangeSlow	.\lib\McReplyBase.h	/^  folly::StringPiece valueRangeSlow() const {$/;"	f	class:facebook::memcache::McReplyBase
valueToSet_	.\lib\routes\ErrorRoute.h	/^  std::string valueToSet_;$/;"	m	struct:facebook::memcache::ErrorRoute
value_	.\lib\fbi\cpp\Trie.h	/^  folly::Optional<value_type> value_;$/;"	m	class:facebook::memcache::Trie
value_	.\lib\fibers\FiberPromise.h	/^  folly::wangle::Try<T>* value_;$/;"	m	class:facebook::memcache::FiberPromise
value_	.\lib\test\RouteHandleTestUtil.h	/^  std::string value_;$/;"	m	struct:facebook::memcache::GetRouteTestData
value_idx	.\lib\mc\umbrella_protocol.c	/^  int value_idx;$/;"	m	struct:_parse_info_s	file:
value_size	.\test\test_largeobj.py	/^    value_size = 1024 * 1024 * 2 + 1$/;"	v	class:TestLargeObj
value_type	.\lib\fbi\cpp\Trie.h	/^  typedef std::pair<const std::string, Value> value_type;$/;"	t	class:facebook::memcache::Trie
value_type	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  typedef typename std::allocator<T>::value_type value_type;$/;"	t	struct:TestAllocator	file:
value_type	.\lib\fibers\AddTasks.h	/^  typedef T value_type;$/;"	t	class:facebook::memcache::fiber::TaskIterator
value_type	.\lib\fibers\FiberPromise.h	/^  typedef T value_type;$/;"	t	class:facebook::memcache::FiberPromise
valuesMacro	.\lib\config\ConfigPreprocessor.cpp	/^  static dynamic valuesMacro(const Context& ctx) {$/;"	f	class:facebook::memcache::ConfigPreprocessor::BuiltIns
verifySerializedValue	.\lib\mc\test\UmbrellaTest.cpp	/^void verifySerializedValue(const std::string& serializedVal,$/;"	f
version	.\lib\mc\umbrella.h	/^  uint8_t version;$/;"	m	struct:entry_list_hdr_s
version	.\routes\test\BigValueRouteTest.cpp	/^static const int version = 1;$/;"	v	file:
version	.\test\MCProcess.py	/^    def version(self):$/;"	m	class:MCProcess
vsize	.\stats.cpp	/^  unsigned long vsize;$/;"	m	struct:facebook::memcache::mcrouter::proc_stat_data_t	file:
wait	.\lib\fbi\cpp\StartupLock.h	/^  void wait() {$/;"	f	class:facebook::memcache::StartupLock
wait	.\lib\fibers\Baton-inl.h	/^void Baton::wait(F&& mainContextFunc) {$/;"	f	class:facebook::memcache::Baton
wait	.\lib\fibers\Baton.cpp	/^void Baton::wait() {$/;"	f	class:facebook::memcache::Baton
wait	.\lib\test\RouteHandleTestUtil.h	/^  void wait() {$/;"	f	struct:facebook::memcache::TestHandle
wait	.\test\cpp_unit_tests\awriter_test.cpp	/^  void wait(std::function<bool(int)> f) {$/;"	f	class:AtomicCounter
wait	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^  void wait() {$/;"	f	class:facebook::memcache::test::ResultsSet
waitForAcceptor	.\lib\network\AsyncMcServer.cpp	/^  void waitForAcceptor() {$/;"	f	class:facebook::memcache::McServerThread
waitForRecorded	.\RecordingContext.cpp	/^void RecordingContext::waitForRecorded($/;"	f	class:facebook::memcache::mcrouter::RecordingContext
waitForReplies	.\lib\network\test\AsyncMcClientTest.cpp	/^  void waitForReplies(size_t remaining = 0) {$/;"	f	class:__anon42::TestClient
waitThread	.\lib\fibers\Baton.cpp	/^void Baton::waitThread() {$/;"	f	class:facebook::memcache::Baton
wait_until_stopped	.\test\mock_servers.py	/^    def wait_until_stopped(self):$/;"	m	class:MockServer
waitable_counter	.\lib\fbi\waitable_count.h	/^typedef struct waitable_counter {$/;"	s
waitable_counter_count	.\lib\fbi\waitable_count.c	/^unsigned waitable_counter_count(waitable_counter_t *wc) {$/;"	f
waitable_counter_dec	.\lib\fbi\waitable_count.c	/^void waitable_counter_dec(waitable_counter_t *wc, unsigned v) {$/;"	f
waitable_counter_inc	.\lib\fbi\waitable_count.c	/^bool waitable_counter_inc(waitable_counter_t *wc, unsigned v) {$/;"	f
waitable_counter_init	.\lib\fbi\waitable_count.c	/^void waitable_counter_init(waitable_counter_t *wc, unsigned max) {$/;"	f
waitable_counter_is_stopped	.\lib\fbi\waitable_count.c	/^bool waitable_counter_is_stopped(waitable_counter_t *wc) {$/;"	f
waitable_counter_stop	.\lib\fbi\waitable_count.c	/^void waitable_counter_stop(waitable_counter_t *wc) {$/;"	f
waitable_counter_t	.\lib\fbi\waitable_count.h	/^} waitable_counter_t;$/;"	t	typeref:struct:waitable_counter
waitable_counter_wait	.\lib\fbi\waitable_count.c	/^bool waitable_counter_wait(waitable_counter_t *wc, int timeout) {$/;"	f
waiters	.\lib\fbi\sfrlock.h	/^  uint32_t waiters;$/;"	m	struct:__anon14
waitingFiber_	.\lib\fibers\Baton.h	/^    std::atomic<intptr_t> waitingFiber_;$/;"	m	union:facebook::memcache::Baton::__anon27
waitingReplies_	.\lib\network\test\AsyncMcClientTest.cpp	/^  std::vector<std::pair<McServerRequestContext, McReply>> waitingReplies_;$/;"	m	class:__anon42::ServerOnRequest	file:
waitingRequests_	.\proxy.h	/^  RequestTailqHead waitingRequests_;$/;"	m	struct:facebook::memcache::mcrouter::proxy_t
wantRealtimeThreads	.\router.cpp	/^bool mcrouter_t::wantRealtimeThreads() const {$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
warm_	.\lib\routes\WarmUpRoute.h	/^  std::shared_ptr<RouteHandleIf> warm_;$/;"	m	class:facebook::memcache::WarmUpRoute
warming_up	.\proxy.h	/^  bool warming_up;$/;"	m	class:facebook::memcache::mcrouter::ProxyMigratedPool
warmup_exptime	.\proxy.h	/^  uint32_t warmup_exptime;$/;"	m	class:facebook::memcache::mcrouter::ProxyMigratedPool
wch3_func	.\proxy.h	/^  std::unique_ptr<WeightedCh3HashFunc> wch3_func;$/;"	m	class:facebook::memcache::mcrouter::ProxyPool
weights	.\lib\WeightedCh3HashFunc.h	/^  const std::vector<double>& weights() const {$/;"	f	class:facebook::memcache::WeightedCh3HashFunc
weights_	.\lib\WeightedCh3HashFunc.h	/^  std::vector<double> weights_;$/;"	m	class:facebook::memcache::WeightedCh3HashFunc
whenAll	.\lib\fibers\WhenN-inl.h	/^inline whenAll(InputIterator first, InputIterator last) {$/;"	f	class:facebook::memcache::fiber::std
whenAll	.\lib\fibers\WhenN-inl.h	/^inline whenAll(InputIterator first, InputIterator last) {$/;"	f	class:facebook::memcache::fiber::std::enable_if
whenAny	.\lib\fibers\WhenN-inl.h	/^inline whenAny(InputIterator first, InputIterator last) {$/;"	f	class:facebook::memcache::fiber::std::enable_if
whenN	.\lib\fibers\WhenN-inl.h	/^whenN(InputIterator first, InputIterator last, size_t n) {$/;"	f	namespace:facebook::memcache::fiber
wildcard	.\routes\PrefixRouteSelector.h	/^  std::shared_ptr<McrouterRouteHandleIf> wildcard;$/;"	m	class:facebook::memcache::mcrouter::PrefixRouteSelector
worker	.\lib\network\AsyncMcServer.h	/^    AsyncMcServerWorkerOptions worker;$/;"	m	struct:facebook::memcache::AsyncMcServer::Options
worker_	.\lib\network\AsyncMcServer.cpp	/^  AsyncMcServerWorker worker_;$/;"	m	class:facebook::memcache::McServerThread	file:
worseThan	.\lib\McReplyBase.cpp	/^bool McReplyBase::worseThan(const McReplyBase& other) const {$/;"	f	class:facebook::memcache::McReplyBase
write	.\lib\network\test\SessionTestHarness.h	/^  void write(folly::StringPiece out) {$/;"	f	class:facebook::memcache::SessionTestHarness
writeBatches_	.\lib\network\McServerSession.h	/^  std::deque<size_t> writeBatches_;$/;"	m	class:facebook::memcache::McServerSession
writeBufs_	.\lib\network\McServerSession.h	/^  folly::Optional<WriteBufferQueue> writeBufs_;$/;"	m	class:facebook::memcache::McServerSession
writeLock	.\lib\fbi\cpp\sfrlock.h	/^  SFRWriteLock& writeLock() {$/;"	f	class:SFRLock
writeLock_	.\lib\fbi\cpp\sfrlock.h	/^  SFRWriteLock writeLock_;$/;"	m	class:SFRLock
writeQueue_	.\lib\network\AsyncMcClientImpl.h	/^  ReqInfo::RequestQueue writeQueue_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
writeStringToFile	.\lib\fbi\cpp\util.cpp	/^bool writeStringToFile(folly::StringPiece contents, const std::string& path) {$/;"	f	namespace:facebook::memcache
writeToFile	.\lib\fbi\cpp\util.cpp	/^bool writeToFile(folly::StringPiece contents, const std::string& path,$/;"	f	namespace:facebook::memcache::__anon10
write_config_sources_info_to_disk	.\McrouterLogger.cpp	/^void write_config_sources_info_to_disk(const mcrouter_t* router) {$/;"	f	namespace:facebook::memcache::mcrouter::__anon46
write_fd	.\lib\fbi\asox_semaphore.c	/^  int write_fd;$/;"	m	struct:asox_sem_s	file:
write_file	.\McrouterLogger.cpp	/^void write_file(const McrouterOptions& opts,$/;"	f	namespace:facebook::memcache::mcrouter::__anon46
write_file_completed	.\async.cpp	/^static void write_file_completed(awriter_entry_t* awe, int result) {$/;"	f	namespace:facebook::memcache::mcrouter
write_file_entry_t	.\async.cpp	/^struct write_file_entry_t {$/;"	s	namespace:facebook::memcache::mcrouter::__anon1	file:
write_pidfile	.\main.cpp	/^void write_pidfile(FILE* pidfile) {$/;"	f
write_result	.\proxy.h	/^  int write_result;$/;"	m	struct:facebook::memcache::mcrouter::writelog_entry_t
write_stats_file	.\McrouterLogger.cpp	/^void write_stats_file(const McrouterOptions& opts,$/;"	f	namespace:facebook::memcache::mcrouter::__anon46
write_stats_to_disk	.\McrouterLogger.cpp	/^void write_stats_to_disk(const McrouterOptions& opts,$/;"	f	namespace:facebook::memcache::mcrouter::__anon46
writelog_entry_free	.\async.cpp	/^void writelog_entry_free(writelog_entry_t *e) {$/;"	f	namespace:facebook::memcache::mcrouter
writelog_entry_new	.\async.cpp	/^static writelog_entry_t* writelog_entry_new(proxy_request_t *preq,$/;"	f	namespace:facebook::memcache::mcrouter
writelog_entry_t	.\proxy.h	/^struct writelog_entry_t {$/;"	s	namespace:facebook::memcache::mcrouter
writer_	.\lib\network\AsyncMcClientImpl.h	/^  std::unique_ptr<WriterLoop> writer_;$/;"	m	class:facebook::memcache::AsyncMcClientImpl
writesPending	.\lib\network\AsyncMcServerWorker.cpp	/^bool AsyncMcServerWorker::writesPending() const {$/;"	f	class:facebook::memcache::AsyncMcServerWorker
writesPending	.\lib\network\McServerSession.h	/^  bool writesPending() const {$/;"	f	class:facebook::memcache::McServerSession
x	.\lib\fbi\cpp\test\TrieBenchmarks.cpp	/^static long x = 0;$/;"	v	file:
x	.\test\cpp_unit_tests\observable_test.cpp	/^  int x;$/;"	m	struct:NoCopy	file:
xchg32_barrier	.\lib\fbi\util.h	/^static inline uint32_t xchg32_barrier(volatile uint32_t *ptr, uint32_t value) {$/;"	f
~AdditionalLoggerIf	.\McrouterLogger.h	/^  virtual ~AdditionalLoggerIf() {}$/;"	f	class:facebook::memcache::mcrouter::AdditionalLoggerIf
~AsciiSerializedReply	.\lib\network\WriteBuffer.cpp	/^AsciiSerializedReply::~AsciiSerializedReply() {$/;"	f	class:facebook::memcache::AsciiSerializedReply
~AsyncMcClientImpl	.\lib\network\AsyncMcClientImpl.cpp	/^AsyncMcClientImpl::~AsyncMcClientImpl() {$/;"	f	class:facebook::memcache::AsyncMcClientImpl
~AsyncMcServer	.\lib\network\AsyncMcServer.cpp	/^AsyncMcServer::~AsyncMcServer() {$/;"	f	class:facebook::memcache::AsyncMcServer
~AsyncWriter	.\async.cpp	/^AsyncWriter::~AsyncWriter() {$/;"	f	class:facebook::memcache::mcrouter::AsyncWriter
~AtomicCounter	.\test\cpp_unit_tests\awriter_test.cpp	/^  ~AtomicCounter() {$/;"	f	class:AtomicCounter
~AtomicLinkedList	.\lib\fbi\cpp\AtomicLinkedList.h	/^  ~AtomicLinkedList() {$/;"	f	class:facebook::memcache::AtomicLinkedList
~Baton	.\lib\fibers\Baton.h	/^  ~Baton() {}$/;"	f	class:facebook::memcache::Baton
~CallbackHandleImpl	.\CallbackPool-inl.h	/^  ~CallbackHandleImpl() {$/;"	f	struct:facebook::memcache::mcrouter::CallbackPool::CallbackHandleImpl
~ClientParseCallback	.\lib\network\McParser.h	/^    virtual ~ClientParseCallback() {}$/;"	f	class:facebook::memcache::McParser::ClientParseCallback
~ConfigApi	.\ConfigApi.cpp	/^ConfigApi::~ConfigApi() {$/;"	f	class:facebook::memcache::mcrouter::ConfigApi
~Context	.\lib\test\TestRequest.h	/^  ~Context() { onDestroyed(); }$/;"	f	struct:facebook::memcache::Context
~DebugLockGuard	.\lib\fbi\test\log_tid_tests.cpp	/^  ~DebugLockGuard() {$/;"	f	struct:DebugLockGuard
~DestinationClient	.\DestinationClient.cpp	/^DestinationClient::~DestinationClient() {$/;"	f	class:facebook::memcache::mcrouter::DestinationClient
~EventBaseLoopController	.\lib\fibers\EventBaseLoopController-inl.h	/^inline EventBaseLoopController::~EventBaseLoopController() {$/;"	f	class:facebook::memcache::mcrouter::EventBaseLoopController
~ExtraRouteHandleProviderIf	.\routes\ExtraRouteHandleProviderIf.h	/^  virtual ~ExtraRouteHandleProviderIf() {}$/;"	f	class:facebook::memcache::mcrouter::ExtraRouteHandleProviderIf
~Fiber	.\lib\fibers\Fiber.cpp	/^Fiber::~Fiber() {$/;"	f	class:facebook::memcache::Fiber
~FiberManager	.\lib\fibers\FiberManager.cpp	/^FiberManager::~FiberManager() {$/;"	f	class:facebook::memcache::FiberManager
~FiberPromise	.\lib\fibers\FiberPromise-inl.h	/^FiberPromise<T>::~FiberPromise() {$/;"	f	class:facebook::memcache::FiberPromise
~ImportResolverIf	.\lib\config\ImportResolverIf.h	/^  virtual ~ImportResolverIf() {}$/;"	f	class:facebook::memcache::ImportResolverIf
~Info	.\lib\fbi\test\asox_queue_test.cpp	/^  ~Info() {$/;"	f	struct:__anon19::Info
~LoopController	.\lib\fibers\LoopController.h	/^  virtual ~LoopController() {}$/;"	f	class:facebook::memcache::LoopController
~MCRouterTestClient	.\test\cpp_unit_tests\mcrouter_test_client.cpp	/^MCRouterTestClient::~MCRouterTestClient() {$/;"	f	class:MCRouterTestClient
~McExtraRouteHandleProvider	.\routes\McExtraRouteHandleProvider.h	/^  virtual ~McExtraRouteHandleProvider() {}$/;"	f	class:facebook::memcache::mcrouter::McExtraRouteHandleProvider
~McParser	.\lib\network\McParser.cpp	/^McParser::~McParser() {$/;"	f	class:facebook::memcache::McParser
~McReplyBase	.\lib\McReplyBase.h	/^  ~McReplyBase() {};$/;"	f	class:facebook::memcache::McReplyBase
~McRequestBase	.\lib\McRequestBase.cpp	/^McRequestBase::~McRequestBase() {$/;"	f	class:facebook::memcache::McRequestBase
~McRouteHandleProvider	.\routes\McRouteHandleProvider.cpp	/^McRouteHandleProvider::~McRouteHandleProvider() {$/;"	f	class:facebook::memcache::mcrouter::McRouteHandleProvider
~McSerializedRequest	.\lib\network\McSerializedRequest.cpp	/^McSerializedRequest::~McSerializedRequest() {$/;"	f	class:facebook::memcache::McSerializedRequest
~McServerOnRequest	.\lib\network\McServerRequestContext.h	/^  virtual ~McServerOnRequest() {}$/;"	f	class:facebook::memcache::McServerOnRequest
~McServerRequestContext	.\lib\network\McServerRequestContext.cpp	/^McServerRequestContext::~McServerRequestContext() {$/;"	f	class:facebook::memcache::McServerRequestContext
~McrouterLogger	.\McrouterLogger.cpp	/^McrouterLogger::~McrouterLogger() {$/;"	f	class:facebook::memcache::mcrouter::McrouterLogger
~McrouterManager	.\router.cpp	/^  ~McrouterManager() {$/;"	f	class:facebook::memcache::mcrouter::__anon56::McrouterManager
~McrouterOptionsBase	.\options.h	/^  virtual ~McrouterOptionsBase() {}$/;"	f	class:facebook::memcache::McrouterOptionsBase
~MemcacheLocal	.\test\cpp_unit_tests\MemcacheLocal.cpp	/^MemcacheLocal::~MemcacheLocal() {$/;"	f	class:facebook::memcache::test::MemcacheLocal
~NestedLimitGuard	.\lib\config\ConfigPreprocessor.cpp	/^  ~NestedLimitGuard() {$/;"	f	class:facebook::memcache::__anon4::NestedLimitGuard
~ObjectPool	.\lib\fbi\cpp\ObjectPool.h	/^  ~ObjectPool() {$/;"	f	class:facebook::memcache::ObjectPool
~OnEventBaseDestructionCallback	.\lib\network\AsyncMcClientImpl.cpp	/^  ~OnEventBaseDestructionCallback() {}$/;"	f	class:facebook::memcache::detail::OnEventBaseDestructionCallback
~PoolFactoryIf	.\PoolFactoryIf.h	/^  virtual ~PoolFactoryIf() { }$/;"	f	class:facebook::memcache::mcrouter::PoolFactoryIf
~ProxyClientShared	.\pclient.cpp	/^ProxyClientShared::~ProxyClientShared() {$/;"	f	class:facebook::memcache::mcrouter::ProxyClientShared
~ProxyConfigIf	.\ProxyConfigIf.h	/^  virtual ~ProxyConfigIf() {}$/;"	f	class:facebook::memcache::mcrouter::ProxyConfigIf
~ProxyDestination	.\ProxyDestination.cpp	/^ProxyDestination::~ProxyDestination() {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestination
~ProxyDestinationMap	.\ProxyDestinationMap.cpp	/^ProxyDestinationMap::~ProxyDestinationMap() {$/;"	f	class:facebook::memcache::mcrouter::ProxyDestinationMap
~ProxyGenericPool	.\proxy.h	/^  virtual ~ProxyGenericPool() {$/;"	f	class:facebook::memcache::mcrouter::ProxyGenericPool
~ProxyPool	.\proxy.cpp	/^ProxyPool::~ProxyPool() {$/;"	f	class:facebook::memcache::mcrouter::ProxyPool
~ProxyRequestContext	.\ProxyRequestContext.cpp	/^ProxyRequestContext::~ProxyRequestContext() {$/;"	f	class:facebook::memcache::mcrouter::ProxyRequestContext
~RecordingContext	.\RecordingContext.cpp	/^RecordingContext::~RecordingContext() {$/;"	f	class:facebook::memcache::mcrouter::RecordingContext
~RouteHandleIf	.\lib\RouteHandleIf.h	/^  virtual ~RouteHandleIf() {}$/;"	f	class:facebook::memcache::RouteHandleIf
~RouteHandleProvider	.\lib\config\RouteHandleProvider.h	/^  virtual ~RouteHandleProvider() {};$/;"	f	class:facebook::memcache::RouteHandleProvider
~RouteHandleProviderIf	.\lib\config\RouteHandleProviderIf.h	/^  virtual ~RouteHandleProviderIf() {};$/;"	f	class:facebook::memcache::RouteHandleProviderIf
~ServerParseCallback	.\lib\network\McParser.h	/^    virtual ~ServerParseCallback() {}$/;"	f	class:facebook::memcache::McParser::ServerParseCallback
~ServiceInfo	.\ServiceInfo.cpp	/^ServiceInfo::~ServiceInfo() {$/;"	f	class:facebook::memcache::mcrouter::ServiceInfo
~TestType	.\lib\fbi\cpp\test\ObjectPoolTests.cpp	/^  ~TestType() {$/;"	f	struct:TestType
~UniqueIntrusiveList	.\lib\network\UniqueIntrusiveList.h	/^  ~UniqueIntrusiveList() {$/;"	f	class:facebook::memcache::UniqueIntrusiveList
~WriteBuffer	.\lib\network\WriteBuffer.cpp	/^WriteBuffer::~WriteBuffer() {$/;"	f	class:facebook::memcache::WriteBuffer
~WriterLoop	.\lib\network\AsyncMcClientImpl.cpp	/^  ~WriterLoop() {}$/;"	f	class:facebook::memcache::AsyncMcClientImpl::WriterLoop
~mcrouter_t	.\router.cpp	/^mcrouter_t::~mcrouter_t() {}$/;"	f	class:facebook::memcache::mcrouter::mcrouter_t
~proxy_pool_shadowing_policy_t	.\proxy.cpp	/^proxy_pool_shadowing_policy_t::~proxy_pool_shadowing_policy_t() {$/;"	f	class:facebook::memcache::mcrouter::proxy_pool_shadowing_policy_t
~proxy_request_t	.\proxy.cpp	/^proxy_request_t::~proxy_request_t() {$/;"	f	class:facebook::memcache::mcrouter::proxy_request_t
~proxy_t	.\proxy.cpp	/^proxy_t::~proxy_t() {$/;"	f	class:facebook::memcache::mcrouter::proxy_t
